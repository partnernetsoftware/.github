TCC源码差异报告
===============

比对时间: Sat Sep 27 10:55:50 AM CST 2025
原始版本: ba0899d9094afe64e9271c226752857e71dab80e (2025-09-21 14:06:59 +0200)
原始提交: tccasm.c: Make .init and .fini sections executable
本地目录: tcc/src/
原始目录: tinycc/

差异统计:
新增文件: 15 个
删除文件: 3 个
修改文件: 50 个
---------

文件状态概览:
============

新增文件 (15 个):
-------------------
./c2str.c
./config.h
./config.texi
./crt1.c
./crti.c
./crtn.c
./linux_crt1.c
./linux_crti.c
./linux_crtn.c
./minimal_libc.c
./modular_libc.h
./tccdefs_.h
./tcc_libc.c
./tcc_runtime_config.h
./test.c

删除文件 (3 个):
-------------------
./tests/tests2/133_old_func.c
./tests/tests2/137_funcall_struct_args.c
./win32/include/tcc/tcc_libm.h

修改文件详细差异:
=================

--- 文件: ./arm64-gen.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./arm64-gen.c	2025-09-27 10:22:27.964982409 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./arm64-gen.c	2025-07-24 10:06:35.130441518 +0800
@@ -997,8 +997,6 @@
     int variadic = (vtop[-nb_args].type.ref->f.func_type == FUNC_ELLIPSIS);
     int var_nb_arg = n_func_args(&vtop[-nb_args].type);
 
-    save_regs(nb_args + 1);
-
 #ifdef CONFIG_TCC_BCHECK
     if (tcc_state->do_bounds_check)
         gbound_args(nb_args);
@@ -1128,6 +1126,7 @@
             vswap();
     }
 
+    save_regs(0);
     arm64_gen_bl_or_b(0);
     --vtop;
     if (stack & 0xfff)
@@ -1242,8 +1241,9 @@
         int off = (a[i] < 16 ? 160 + a[i] / 2 * 8 :
                    a[i] < 32 ? 16 + (a[i] - 16) / 2 * 16 :
                    224 + ((a[i] - 32) >> 1 << 1));
-
-        gfunc_set_param(sym, off, a[i] & 1);
+        sym_push(sym->v & ~SYM_FIELD, &sym->type,
+                 (a[i] & 1 ? VT_LLOCAL : VT_LOCAL) | VT_LVAL,
+                 off);
 
         if (a[i] < 16) {
             int align, size = type_size(&sym->type, &align);

--- 文件: ./arm-gen.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./arm-gen.c	2025-09-27 10:22:27.960982390 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./arm-gen.c	2025-07-24 10:06:35.130441518 +0800
@@ -310,7 +310,7 @@
     if(c<256) /* catch undefined <<32 */
       return op|c;
     for(i=2;i<32;i+=2) {
-      m=(0xffu>>i)|(0xffu<<(32-i));
+      m=(0xff>>i)|(0xff<<(32-i));
       if(!(c&~m))
 	return op|(i<<7)|(c<<i)|(c>>(32-i));
     }
@@ -593,7 +593,7 @@
     sign=0;
   else {
     sign=1;
-    fc=-(unsigned)fc;
+    fc=-fc;
   }
 
   v = fr & VT_VALMASK;
@@ -1311,6 +1311,10 @@
   if (++pass < 2)
     goto again;
 
+  /* Manually free remaining registers since next parameters are loaded
+   * manually, without the help of gv(int). */
+  save_regs(nb_args);
+
   if(todo) {
     o(0xE8BD0000|todo); /* pop {todo} */
     for(pplan = plan->clsplans[CORE_STRUCT_CLASS]; pplan; pplan = pplan->prev) {
@@ -1350,8 +1354,6 @@
     gbound_args(nb_args);
 #endif
 
-  save_regs(nb_args + 1);
-
 #ifdef TCC_ARM_EABI
   if (float_abi == ARM_HARD_FLOAT) {
     variadic = (vtop[-nb_args].type.ref->f.func_type == FUNC_ELLIPSIS);
@@ -1493,7 +1495,8 @@
       addr = (n + nf + sn) * 4;
       sn += size;
     }
-    gfunc_set_param(sym, addr + 12, 0);
+    sym_push(sym->v & ~SYM_FIELD, type, VT_LOCAL | VT_LVAL,
+             addr + 12);
   }
   last_itod_magic=0;
   leaffunc = 1;

--- 文件: ./arm-link.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./arm-link.c	2025-09-27 10:22:27.960982390 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./arm-link.c	2025-07-24 10:06:35.130441518 +0800
@@ -194,18 +194,17 @@
         case R_ARM_PLT32:
             {
                 int x, is_thumb, is_call, h, blx_avail, is_bl, th_ko;
-                unsigned code = read32le(ptr);
-                x = code & 0x00ffffff;
+                x = (*(int *) ptr) & 0xffffff;
 #ifdef DEBUG_RELOC
 		printf ("reloc %d: x=0x%x val=0x%x ", type, x, val);
 #endif
-                code &= 0xff000000;
+                (*(int *)ptr) &= 0xff000000;
+                if (x & 0x800000)
+                    x -= 0x1000000;
                 x <<= 2;
-                if (x & 0x2000000)
-                    x -= 0x4000000;
                 blx_avail = (CONFIG_TCC_CPUVER >= 5);
                 is_thumb = val & 1;
-                is_bl = code == 0xeb000000;
+                is_bl = (*(unsigned *) ptr) >> 24 == 0xeb;
                 is_call = (type == R_ARM_CALL || (type == R_ARM_PC24 && is_bl));
                 x += val - addr;
 #ifdef DEBUG_RELOC
@@ -221,9 +220,9 @@
                 /* Only reached if blx is avail and it is a call */
                 if (is_thumb) {
                     x |= h << 24;
-                    code = 0xfa000000; /* bl -> blx */
+                    (*(int *)ptr) = 0xfa << 24; /* bl -> blx */
                 }
-                write32le(ptr, code | x);
+                (*(int *) ptr) |= x;
             }
             return;
         /* Since these relocations only concern Thumb-2 and blx instruction was
@@ -242,8 +241,8 @@
                     return;
 
                 /* Get initial offset */
-                hi = read16le(ptr);
-                lo = read16le(ptr+2);
+                hi = (*(uint16_t *)ptr);
+                lo = (*(uint16_t *)(ptr+2));
                 s = (hi >> 10) & 1;
                 j1 = (lo >> 13) & 1;
                 j2 = (lo >> 11) & 1;
@@ -314,11 +313,11 @@
                 j2 = s ^ (i2 ^ 1);
                 imm10 = (x >> 12) & 0x3ff;
                 imm11 = (x >> 1) & 0x7ff;
-                write16le(ptr, (hi & 0xf800) |
-                               (s << 10) | imm10);
-                write16le(ptr+2, (lo & 0xc000) |
-                                 (j1 << 13) | blx_bit | (j2 << 11) |
-                                 imm11);
+                (*(uint16_t *)ptr) = (uint16_t) ((hi & 0xf800) |
+                                     (s << 10) | imm10);
+                (*(uint16_t *)(ptr+2)) = (uint16_t) ((lo & 0xc000) |
+                                (j1 << 13) | blx_bit | (j2 << 11) |
+                                imm11);
             }
             return;
         case R_ARM_MOVT_ABS:
@@ -331,23 +330,23 @@
                 imm4 = (val >> 12) & 0xf;
                 x = (imm4 << 16) | imm12;
                 if (type == R_ARM_THM_MOVT_ABS)
-                    write32le(ptr, read32le(ptr) | x);
+                    *(int *)ptr |= x;
                 else
-                    add32le(ptr, x);
+                    *(int *)ptr += x;
             }
             return;
         case R_ARM_MOVT_PREL:
         case R_ARM_MOVW_PREL_NC:
             {
-		int insn = read32le(ptr);
+		int insn = *(int *)ptr;
                 int addend = ((insn >> 4) & 0xf000) | (insn & 0xfff);
 
 		addend = (addend ^ 0x8000) - 0x8000;
 		val += addend - addr;
 		if (type == R_ARM_MOVT_PREL)
 		    val >>= 16;
-		write32le(ptr, (insn & 0xfff0f000) |
-			       ((val & 0xf000) << 4) | (val & 0xfff));
+		*(int *)ptr = (insn & 0xfff0f000) |
+			      ((val & 0xf000) << 4) | (val & 0xfff);
             }
             return;
         case R_ARM_THM_MOVT_ABS:
@@ -362,21 +361,21 @@
                 imm4 = (val >> 12) & 0xf;
                 x = (imm3 << 28) | (imm8 << 16) | (i << 10) | imm4;
                 if (type == R_ARM_THM_MOVT_ABS)
-                    write32le(ptr, read32le(ptr) | x);
+                    *(int *)ptr |= x;
                 else
-                    add32le(ptr, x);
+                    *(int *)ptr += x;
             }
             return;
         case R_ARM_PREL31:
             {
                 int x;
-                x = read32le(ptr) & 0x7fffffff;
-                write32le(ptr, read32le(ptr) & 0x80000000);
+                x = (*(int *)ptr) & 0x7fffffff;
+                (*(int *)ptr) &= 0x80000000;
                 x = (x * 2) / 2;
                 x += val - addr;
                 if((x^(x>>1))&0x40000000)
                     tcc_error_noabort("can't relocate value at %x,%d",addr, type);
-                write32le(ptr, read32le(ptr) | (x & 0x7fffffff));
+                (*(int *)ptr) |= x & 0x7fffffff;
             }
             return;
         case R_ARM_ABS32:
@@ -393,37 +392,37 @@
                     qrel++;
                 }
             }
-            add32le(ptr, val);
+            *(int *)ptr += val;
             return;
         case R_ARM_REL32:
-            add32le(ptr, val - addr);
+            *(int *)ptr += val - addr;
             return;
         case R_ARM_GOTPC:
-            add32le(ptr, s1->got->sh_addr - addr);
+            *(int *)ptr += s1->got->sh_addr - addr;
             return;
         case R_ARM_GOTOFF:
-            add32le(ptr, val - s1->got->sh_addr);
+            *(int *)ptr += val - s1->got->sh_addr;
             return;
         case R_ARM_GOT32:
             /* we load the got offset */
-            add32le(ptr, get_sym_attr(s1, sym_index, 0)->got_offset);
+            *(int *)ptr += get_sym_attr(s1, sym_index, 0)->got_offset;
             return;
 	case R_ARM_GOT_PREL:
             /* we load the pc relative got offset */
-            add32le(ptr, s1->got->sh_addr +
-			 get_sym_attr(s1, sym_index, 0)->got_offset -
-			 addr);
+            *(int *)ptr += s1->got->sh_addr +
+			   get_sym_attr(s1, sym_index, 0)->got_offset -
+			   addr;
             return;
         case R_ARM_COPY:
             return;
         case R_ARM_V4BX:
             /* trade Thumb support for ARMv4 support */
-            if ((0x0ffffff0 & read32le(ptr)) == 0x012FFF10)
-                write32le(ptr, read32le(ptr) ^ 0xE12FFF10 ^ 0xE1A0F000); /* BX Rm -> MOV PC, Rm */
+            if ((0x0ffffff0 & *(int*)ptr) == 0x012FFF10)
+                *(int*)ptr ^= 0xE12FFF10 ^ 0xE1A0F000; /* BX Rm -> MOV PC, Rm */
             return;
         case R_ARM_GLOB_DAT:
         case R_ARM_JUMP_SLOT:
-            write32le(ptr, val);
+            *(addr_t *)ptr = val;
             return;
         case R_ARM_NONE:
             /* Nothing to do.  Normally used to indicate a dependency

--- 文件: ./c67-gen.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./c67-gen.c	2025-09-27 10:22:27.968982428 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./c67-gen.c	2025-07-24 10:06:35.130441518 +0800
@@ -1968,7 +1968,7 @@
     /* define parameters */
     while ((sym = sym->next) != NULL) {
 	type = &sym->type;
-	gfunc_set_param(sym, addr, 0);
+	sym_push(sym->v & ~SYM_FIELD, type, VT_LOCAL | VT_LVAL, addr);
 	size = type_size(type, &align);
 	size = (size + 3) & ~3;
 

--- 文件: ./configure ---
--- /workspace/self-evolve-ai/third_party/tinycc/./configure	2025-09-27 10:22:27.968982428 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./configure	2025-07-24 10:06:35.130441518 +0800
@@ -27,7 +27,6 @@
 infodir=""
 sysroot=""
 cross_prefix=""
-os_release=""
 cc="gcc"
 ar="ar"
 bigendian="no"
@@ -124,8 +123,6 @@
   ;;
   --cross-prefix=*) assign_opt "$opt" cross_prefix
   ;;
-  --os-release=*) assign_opt "$opt" os_release
-  ;;
   --cc=*) assign_opt "$opt"
   ;;
   --ar=*) assign_opt "$opt" ; ar_set="yes"
@@ -234,7 +231,6 @@
 Cross build options (experimental):
   --cpu=CPU                target CPU [$cpu]
   --targetos=...           target OS (Darwin,WIN32,Android/Termux) [$targetos]
-  --os-release=x.y.z       target os release x.y.z [$os_release] (with BSD systems)
   --cross-prefix=PREFIX    use PREFIX for compile tools [$cross_prefix]
 EOF
 exit 1
@@ -260,7 +256,6 @@
 # OS specific
 buildos=$(uname)
 cpu_sys=$(uname -m)
-default os_release "$(uname -r)"
 
 case $buildos in
   Windows_NT|MINGW*|MSYS*|CYGWIN*)
@@ -709,7 +704,6 @@
 print_str CONFIG_TCC_SWITCHES "$tcc_switches"
 print_str CONFIG_LDDIR "$tcc_lddir"
 print_str CONFIG_TRIPLET "$triplet"
-print_str CONFIG_OS_RELEASE "$os_release"
 echo "#endif" >> $TMPH && echo >> $TMPH
 
 print_str CONFIG_SYSROOT "$sysroot" x

--- 文件: ./i386-asm.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./i386-asm.c	2025-09-27 10:22:27.972982446 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./i386-asm.c	2025-07-24 10:06:35.130441518 +0800
@@ -136,7 +136,7 @@
 # define OP_EA32  0
 #endif
 
-#define OP_EA     0x40000000u
+#define OP_EA     0x40000000
 #define OP_REG    (OP_REG8 | OP_REG16 | OP_REG32 | OP_REG64)
 
 #ifdef TCC_TARGET_X86_64
@@ -722,7 +722,7 @@
         }
         parse_operand(s1, pop);
         if (tok == ':') {
-           if (!(pop->type & OP_SEG) || seg_prefix)
+           if (pop->type != OP_SEG || seg_prefix)
                tcc_error("incorrect prefix");
            seg_prefix = segment_prefixes[pop->reg];
            next();
@@ -852,7 +852,7 @@
         if (opcode >= TOK_ASM_first && opcode <= TOK_ASM_last) {
             int b;
             b = op0_codes[opcode - TOK_ASM_first];
-            if (b & 0xff00)
+            if (b & 0xff00) 
                 g(b >> 8);
             g(b);
             return;
@@ -1002,24 +1002,21 @@
     modrm_index = -1;
     modreg_index = -1;
     if (pa->instr_type & OPC_MODRM) {
+#ifdef TCC_TARGET_X86_64
 	if (!nb_ops) {
 	    /* A modrm opcode without operands is a special case (e.g. mfence).
 	       It has a group and acts as if there's an register operand 0 */
 	    i = 0;
 	    ops[i].type = OP_REG;
-#ifdef TCC_TARGET_X86_64
 	    if (pa->sym == TOK_ASM_endbr64)
 	      ops[i].reg = 2; // dx
 	    else if (pa->sym >= TOK_ASM_lfence && pa->sym <= TOK_ASM_sfence)
   	      ops[i].reg = 0; // ax
-#else
-	    if (pa->sym == TOK_ASM_endbr32)
-	      ops[i].reg = 3; // bx
-#endif
 	    else
 	      tcc_error("bad MODR/M opcode without operands");
 	    goto modrm_found;
 	}
+#endif
         /* first look for an ea operand */
         for(i = 0;i < nb_ops; i++) {
             if (op_type[i] & OP_EA)
@@ -1233,8 +1230,8 @@
     return p;
 }
 
-/* If t (a token) is of the form "%reg" or "reg" return the register number and
-   type, otherwise return -1. With GCC the % is optional, too. */
+/* If T (a token) is of the form "%reg" returns the register
+   number and type, otherwise return -1.  */
 ST_FUNC int asm_parse_regvar (int t)
 {
     const char *s;
@@ -1242,14 +1239,13 @@
     if (t < TOK_IDENT || (t & SYM_FIELD))
         return -1;
     s = table_ident[t - TOK_IDENT]->str;
-    if (s[0] == '%')
-        ++s;
-    t = tok_alloc_const(s);
+    if (s[0] != '%')
+        return -1;
+    t = tok_alloc_const(s + 1);
     unget_tok(t);
-    /* Internally the % prefix is required. */
     unget_tok('%');
     parse_operand(tcc_state, &op);
-    /* Accept only integer regs for now. */
+    /* Accept only integer regs for now.  */
     if (op.type & OP_REG)
         return op.reg;
     else
@@ -1417,7 +1413,7 @@
             /* any general register */
             if ((reg = op->reg) >= 0)
                 goto reg_found;
-            else for(reg = 0; reg < NB_ASM_REGS; reg++) {
+            else for(reg = 0; reg < 8; reg++) {
                 if (!is_reg_allocated(reg))
                     goto reg_found;
             }
@@ -1452,7 +1448,7 @@
             if (j < nb_outputs || c == 'm') {
                 if ((op->vt->r & VT_VALMASK) == VT_LLOCAL) {
                     /* any general register */
-                    for(reg = 0; reg < NB_ASM_REGS; reg++) {
+                    for(reg = 0; reg < 8; reg++) {
                         if (!(regs_allocated[reg] & REG_IN_MASK))
                             goto reg_found1;
                     }
@@ -1485,7 +1481,7 @@
         if (op->reg >= 0 &&
             (op->vt->r & VT_VALMASK) == VT_LLOCAL  &&
             !op->is_memory) {
-            for(reg = 0; reg < NB_ASM_REGS; reg++) {
+            for(reg = 0; reg < 8; reg++) {
                 if (!(regs_allocated[reg] & REG_OUT_MASK))
                     goto reg_found2;
             }

--- 文件: ./i386-asm.h ---
--- /workspace/self-evolve-ai/third_party/tinycc/./i386-asm.h	2025-09-27 10:22:27.972982446 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./i386-asm.h	2025-07-24 10:06:35.130441518 +0800
@@ -37,10 +37,7 @@
      DEF_ASM_OP0(pause, 0xf390)
      DEF_ASM_OP0(xlat, 0xd7)
 
-    /* Control-Flow Enforcement */
-    DEF_ASM_OP0L(endbr32, 0xf30f1e, 7, OPC_MODRM)
-
-    /* strings */
+     /* strings */
 ALT(DEF_ASM_OP0L(cmpsb, 0xa6, 0, OPC_BWLX))
 ALT(DEF_ASM_OP0L(scmpb, 0xa6, 0, OPC_BWLX))
 

--- 文件: ./i386-gen.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./i386-gen.c	2025-09-27 10:22:27.972982446 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./i386-gen.c	2025-07-24 10:06:35.134441538 +0800
@@ -406,8 +406,6 @@
         gbound_args(nb_args);
 #endif
 
-    save_regs(nb_args + 1);
-
     args_size = 0;
     for(i = 0;i < nb_args; i++) {
         if ((vtop->type.t & VT_BTYPE) == VT_STRUCT) {
@@ -417,7 +415,6 @@
             /* allocate the necessary size on stack */
 #ifdef TCC_TARGET_PE
             if (size >= 4096) {
-                save_reg(TREG_EDX);
                 r = get_reg(RC_EAX);
                 oad(0x68, size); // push size
                 /* cannot call normal 'alloca' with bound checking */
@@ -466,7 +463,7 @@
         }
         vtop--;
     }
-
+    save_regs(0); /* save used temporary registers */
     func_sym = vtop->type.ref;
     func_call = func_sym->f.func_call;
     /* fast call case */
@@ -578,7 +575,8 @@
             param_addr = addr;
             addr += size;
         }
-        gfunc_set_param(sym, param_addr, 0);
+        sym_push(sym->v & ~SYM_FIELD, type,
+                 VT_LOCAL | VT_LVAL, param_addr);
         param_index++;
     }
     func_ret_sub = 0;

--- 文件: ./include/stdatomic.h ---
--- /workspace/self-evolve-ai/third_party/tinycc/./include/stdatomic.h	2025-09-27 10:22:27.972982446 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./include/stdatomic.h	2025-07-24 10:06:35.134441538 +0800
@@ -80,6 +80,16 @@
 #define ATOMIC_FLAG_INIT {0}
 #define ATOMIC_VAR_INIT(value) (value)
 
+#define atomic_flag_test_and_set_explicit(object, order)                  \
+    __atomic_test_and_set((void *)(&((object)->value)), order)
+#define atomic_flag_test_and_set(object)                                  \
+    atomic_flag_test_and_set_explicit(object, __ATOMIC_SEQ_CST)
+
+#define atomic_flag_clear_explicit(object, order)                         \
+    __atomic_clear((bool *)(&((object)->value)), order)
+#define atomic_flag_clear(object) \
+    atomic_flag_clear_explicit(object, __ATOMIC_SEQ_CST)
+
 /* Generic routines */
 #define atomic_init(object, desired)                                      \
     atomic_store_explicit(object, desired, __ATOMIC_RELAXED)
@@ -157,15 +167,15 @@
 #define atomic_fetch_and_explicit __atomic_fetch_and
 
 extern void atomic_thread_fence (memory_order);
-#define __atomic_thread_fence(order) atomic_thread_fence (order)
+extern void __atomic_thread_fence (memory_order);
+#define atomic_thread_fence(order) __atomic_thread_fence (order)
 extern void atomic_signal_fence (memory_order);
-#define __atomic_signal_fence(order) atomic_signal_fence(order)
+extern void __atomic_signal_fence (memory_order);
 #define atomic_signal_fence(order) __atomic_signal_fence  (order)
 extern bool __atomic_is_lock_free(size_t size, void *ptr);
 #define atomic_is_lock_free(OBJ) __atomic_is_lock_free (sizeof (*(OBJ)), (OBJ))
 
-extern bool atomic_flag_test_and_set(void *object);
-extern bool atomic_flag_test_and_set_explicit(void *object, memory_order order);
-extern void atomic_flag_clear(void *object);
-extern void atomic_flag_clear_explicit(void *object, memory_order order);
+extern bool __atomic_test_and_set (void *, memory_order);
+extern void __atomic_clear (bool *, memory_order);
+
 #endif /* _STDATOMIC_H */

--- 文件: ./include/stddef.h ---
--- /workspace/self-evolve-ai/third_party/tinycc/./include/stddef.h	2025-09-27 10:22:27.972982446 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./include/stddef.h	2025-07-24 10:06:35.134441538 +0800
@@ -1,6 +1,5 @@
 #ifndef _STDDEF_H
 #define _STDDEF_H
-#define _TINYC_STDDEF
 
 typedef __SIZE_TYPE__ size_t;
 typedef __PTRDIFF_TYPE__ ssize_t;
@@ -18,7 +17,7 @@
 #endif
 
 #undef offsetof
-#define offsetof(type, field) __builtin_offsetof(type, field)
+#define offsetof(type, field) ((size_t)&((type *)0)->field)
 
 #if defined __i386__ || defined __x86_64__
 void *alloca(size_t size);

--- 文件: ./include/tccdefs.h ---
--- /workspace/self-evolve-ai/third_party/tinycc/./include/tccdefs.h	2025-09-27 10:22:27.972982446 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./include/tccdefs.h	2025-07-24 10:06:35.134441538 +0800
@@ -310,7 +310,6 @@
     __MAYBE_REDIR(void, free, (void*))
 #if defined __i386__ || defined __x86_64__
     __BOTH(void*, alloca, (__SIZE_TYPE__))
-    void *alloca(__SIZE_TYPE__);
 #else
     __BUILTIN(void*, alloca, (__SIZE_TYPE__))
 #endif

--- 文件: ./lib/alloca-bt.S ---
--- /workspace/self-evolve-ai/third_party/tinycc/./lib/alloca-bt.S	2025-09-27 10:22:27.972982446 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./lib/alloca-bt.S	2025-07-24 10:06:35.134441538 +0800
@@ -15,15 +15,14 @@
     pop     %edx
     pop     %eax
     mov     %eax, %ecx
-    test    %eax,%eax
-    jz      p6
-    add     $3 + 1,%eax
+    add     $3+1,%eax
     and     $-4,%eax
+    jz      p6
 
 #ifdef _WIN32
 p4:
     cmp     $4096,%eax
-    jb      p5
+    jbe     p5
     test    %eax,-4096(%esp)
     sub     $4096,%esp
     sub     $4096,%eax
@@ -71,11 +70,12 @@
 #else
     pop     %rdx
     mov     %rdi,%rax
-    and     %eax,%eax
-    jz      p3
     mov     %rax,%rsi	# size, a second parm to the __bound_new_region
+
     add     $15 + 1,%rax  # add one extra to separate regions
     and     $-16,%rax
+    jz      p3
+
 
     sub     %rax,%rsp
     mov     %rsp,%rdi	# pointer, a first parm to the __bound_new_region

--- 文件: ./lib/alloca.S ---
--- /workspace/self-evolve-ai/third_party/tinycc/./lib/alloca.S	2025-09-27 10:22:27.972982446 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./lib/alloca.S	2025-07-24 10:06:35.134441538 +0800
@@ -13,27 +13,27 @@
 .globl _(alloca), _(__alloca)
 _(alloca):
 _(__alloca):
-    pop     %edx
-    pop     %eax
+    push    %ebp
+    mov     %esp,%ebp
+    mov     8(%ebp),%eax
     add     $3,%eax
     and     $-4,%eax
-    jz      p3
-
 #ifdef _WIN32
+    jmp     .+16 #p2
 p1:
-    cmp     $4096,%eax
-    jb      p2
-    test    %eax,-4096(%esp)
     sub     $4096,%esp
     sub     $4096,%eax
-    jmp     p1
+    test    %eax,(%esp)
 p2:
+    cmp     $4096,%eax
+    jae     p1
 #endif
     sub     %eax,%esp
-    mov     %esp,%eax
-p3:
-    push    %edx
-    push    %edx
+    mov     4(%ebp),%eax
+    mov     0(%ebp),%ebp
+    add     $8,%esp
+    push    %eax
+    lea     8(%esp),%eax
     ret
 
 /* ---------------------------------------------- */
@@ -54,7 +54,7 @@
 #ifdef _WIN32
 p1:
     cmp     $4096,%rax
-    jb      p2
+    jbe     p2
     test    %rax,-4096(%rsp)
     sub     $4096,%rsp
     sub     $4096,%rax

--- 文件: ./lib/armeabi.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./lib/armeabi.c	2025-09-27 10:22:27.972982446 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./lib/armeabi.c	2025-07-24 10:06:35.134441538 +0800
@@ -177,7 +177,7 @@
         ret.high = 0;                                                        \
         ret.low = 1 << exp;                                                  \
         if (exp > DOUBLE_FRAC_BITS - 32) {                                   \
-            high_shift = exp - (DOUBLE_FRAC_BITS - 32);                      \
+            high_shift = exp - DOUBLE_FRAC_BITS - 32;                        \
             ret.low |= val.high << high_shift;                               \
             ret.low |= val.low >> (32 - high_shift);                         \
         } else                                                               \

--- 文件: ./lib/atomic.S ---
--- /workspace/self-evolve-ai/third_party/tinycc/./lib/atomic.S	2025-09-27 10:22:27.976982465 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./lib/atomic.S	2025-07-24 10:06:35.134441538 +0800
@@ -1,2669 +1,858 @@
 /* ---------------------------------------------- */
-/* This file is extracted from `gcc` v15.1.0 `libatomic.a`. */
-/* This file is generated by https://github.com/kbkpbot/gen_atomic.git */
-/* This file is generated at 2025-06-24 21:37. */
-/* This file implements for i386/x86_64/arm/aarch64/riscv:
- * __atomic_load_[1,2,4,8]
- * __atomic_store_[1,2,4,8]
- * __atomic_compare_exchange_[1,2,4,8]
- * __atomic_test_and_set_[1,2,4,8]
- * atomic_thread_fence
- * atomic_signal_fence
- * atomic_flag_test_and_set
- * atomic_flag_test_and_set_explicit
- * atomic_flag_clear
- * atomic_flag_clear_explicit
- */
-/* SPDX-License-Identifier: GPL-3.0-or-later WITH GCC-exception-3.1
- * Copyright (C) 2012-2025 Free Software Foundation, Inc.
+/* This file implements for arm/arm64/riscv:
+ * __atomic_compare_exchange_1
+ * __atomic_compare_exchange_2
+ * __atomic_compare_exchange_4
+ * __atomic_compare_exchange_8
  */
+
 #ifdef __leading_underscore
 # define _(s) _##s
 #else
 # define _(s) s
 #endif
 
-
-/* ---------------------------------------------- */
 #if defined __i386__
-
-#define endbr32
-
         .text
+        .align  2
 
-        .global _(__atomic_load_1)
-        .type   _(__atomic_load_1), %function
-_(__atomic_load_1):
-        endbr32
-        mov    0x4(%esp),%eax
-        movzbl (%eax),%eax
-        ret
-	.size   _(__atomic_load_1), .-_(__atomic_load_1)
-
-        .global _(__atomic_load_2)
-        .type   _(__atomic_load_2), %function
-_(__atomic_load_2):
-        endbr32
-        mov    0x4(%esp),%eax
-        movzwl (%eax),%eax
-        ret
-	.size   _(__atomic_load_2), .-_(__atomic_load_2)
-
-        .global _(__atomic_load_4)
-        .type   _(__atomic_load_4), %function
-_(__atomic_load_4):
-        endbr32
-        mov    0x4(%esp),%eax
-        mov    (%eax),%eax
-        ret
-	.size   _(__atomic_load_4), .-_(__atomic_load_4)
-
-        .global _(__atomic_load_8)
-        .type   _(__atomic_load_8), %function
-_(__atomic_load_8):
-        endbr32
-        sub    $0xc,%esp
-        mov    0x10(%esp),%eax
-        fildll (%eax)
-        fistpll (%esp)
-        mov    (%esp),%eax
-        mov    0x4(%esp),%edx
-        add    $0xc,%esp
-        ret
-	.size   _(__atomic_load_8), .-_(__atomic_load_8)
-
-        .global _(__atomic_store_1)
-        .type   _(__atomic_store_1), %function
-_(__atomic_store_1):
-        endbr32
-        mov    0x4(%esp),%edx
-        mov    0x8(%esp),%eax
-        xchg   %al,(%edx)
-        ret
-	.size   _(__atomic_store_1), .-_(__atomic_store_1)
-
-        .global _(__atomic_store_2)
-        .type   _(__atomic_store_2), %function
-_(__atomic_store_2):
-        endbr32
-        mov    0x4(%esp),%edx
-        mov    0x8(%esp),%eax
-        xchg   %ax,(%edx)
-        ret
-	.size   _(__atomic_store_2), .-_(__atomic_store_2)
-
-        .global _(__atomic_store_4)
-        .type   _(__atomic_store_4), %function
-_(__atomic_store_4):
-        endbr32
-        mov    0x4(%esp),%edx
-        mov    0x8(%esp),%eax
-        xchg   %eax,(%edx)
-        ret
-	.size   _(__atomic_store_4), .-_(__atomic_store_4)
-
-        .global _(__atomic_store_8)
-        .type   _(__atomic_store_8), %function
-_(__atomic_store_8):
-        endbr32
-        push   %ebx
-        sub    $0x8,%esp
-        mov    0x18(%esp),%ebx
-        mov    0x14(%esp),%ecx
-        mov    %ecx,(%esp)
-        mov    %ebx,0x4(%esp)
-        fildll (%esp)
-        mov    0x10(%esp),%eax
-        fistpll (%eax)
-        lock orl $0x0,(%esp)
-        add    $0x8,%esp
-        pop    %ebx
-        ret
-	.size   _(__atomic_store_8), .-_(__atomic_store_8)
-
-        .global _(__atomic_compare_exchange_1)
-        .type   _(__atomic_compare_exchange_1), %function
-_(__atomic_compare_exchange_1):
-        endbr32
-        push   %ebx
-        mov    0xc(%esp),%ecx
-        mov    0x8(%esp),%edx
-        movzbl 0x10(%esp),%ebx
-        movzbl (%ecx),%eax
-        lock cmpxchg %bl,(%edx)
-        sete   %dl
-        je      .L___atomic_compare_exchange_1_020
-        mov    %al,(%ecx)
-.L___atomic_compare_exchange_1_020:
-        mov    %edx,%eax
-        pop    %ebx
-        ret
-	.size   _(__atomic_compare_exchange_1), .-_(__atomic_compare_exchange_1)
-
-        .global _(__atomic_compare_exchange_2)
-        .type   _(__atomic_compare_exchange_2), %function
-_(__atomic_compare_exchange_2):
-        endbr32
-        push   %ebx
-        mov    0xc(%esp),%ecx
-        mov    0x8(%esp),%edx
-        movzwl 0x10(%esp),%ebx
-        movzwl (%ecx),%eax
-        lock cmpxchg %bx,(%edx)
-        sete   %dl
-        je      .L___atomic_compare_exchange_2_022
-        mov    %ax,(%ecx)
-.L___atomic_compare_exchange_2_022:
-        mov    %edx,%eax
-        pop    %ebx
-        ret
-	.size   _(__atomic_compare_exchange_2), .-_(__atomic_compare_exchange_2)
-
-        .global _(__atomic_compare_exchange_4)
-        .type   _(__atomic_compare_exchange_4), %function
-_(__atomic_compare_exchange_4):
-        endbr32
-        push   %ebx
-        mov    0xc(%esp),%ecx
-        mov    0x8(%esp),%edx
-        mov    0x10(%esp),%ebx
-        mov    (%ecx),%eax
-        lock cmpxchg %ebx,(%edx)
-        sete   %dl
-        je      .L___atomic_compare_exchange_4_01e
-        mov    %eax,(%ecx)
-.L___atomic_compare_exchange_4_01e:
-        mov    %edx,%eax
-        pop    %ebx
-        ret
-	.size   _(__atomic_compare_exchange_4), .-_(__atomic_compare_exchange_4)
-
-        .global _(__atomic_compare_exchange_8)
-        .type   _(__atomic_compare_exchange_8), %function
-_(__atomic_compare_exchange_8):
-        endbr32
-        push   %edi
-        push   %esi
-        push   %ebx
-        mov    0x14(%esp),%esi
-        mov    0x1c(%esp),%ecx
-        mov    0x10(%esp),%edi
-        mov    (%esi),%eax
-        mov    0x4(%esi),%edx
-        mov    0x18(%esp),%ebx
-        lock cmpxchg8b (%edi)
-        sete   %cl
-        je      .L___atomic_compare_exchange_8_02a
-        mov    %eax,(%esi)
-        mov    %edx,0x4(%esi)
-.L___atomic_compare_exchange_8_02a:
-        pop    %ebx
-        mov    %ecx,%eax
-        pop    %esi
-        pop    %edi
-        ret
-	.size   _(__atomic_compare_exchange_8), .-_(__atomic_compare_exchange_8)
-
-        .global _(__atomic_test_and_set_1)
-        .type   _(__atomic_test_and_set_1), %function
-_(__atomic_test_and_set_1):
-        endbr32
-        mov    0x4(%esp),%edx
-        mov    $0x1,%eax
-        xchg   %al,(%edx)
-        ret
-	.size   _(__atomic_test_and_set_1), .-_(__atomic_test_and_set_1)
-
-        .global _(__atomic_test_and_set_2)
-        .type   _(__atomic_test_and_set_2), %function
-_(__atomic_test_and_set_2):
-        endbr32
-        mov    0x4(%esp),%edx
-        mov    $0x1,%eax
-        xchg   %al,(%edx)
-        ret
-	.size   _(__atomic_test_and_set_2), .-_(__atomic_test_and_set_2)
-
-        .global _(__atomic_test_and_set_4)
-        .type   _(__atomic_test_and_set_4), %function
-_(__atomic_test_and_set_4):
-        endbr32
-        mov    0x4(%esp),%edx
-        mov    $0x1,%eax
-        xchg   %al,(%edx)
-        ret
-	.size   _(__atomic_test_and_set_4), .-_(__atomic_test_and_set_4)
-
-        .global _(__atomic_test_and_set_8)
-        .type   _(__atomic_test_and_set_8), %function
-_(__atomic_test_and_set_8):
-        endbr32
-        mov    0x4(%esp),%edx
-        mov    $0x1,%eax
-        xchg   %al,(%edx)
-        ret
-	.size   _(__atomic_test_and_set_8), .-_(__atomic_test_and_set_8)
-
-        .global _(atomic_thread_fence)
-        .type   _(atomic_thread_fence), %function
-_(atomic_thread_fence):
-        endbr32
-        lock orl $0x0,(%esp)
-        ret
-	.size   _(atomic_thread_fence), .-_(atomic_thread_fence)
-
-        .global _(atomic_signal_fence)
-        .type   _(atomic_signal_fence), %function
-_(atomic_signal_fence):
-        endbr32
-        ret
-	.size   _(atomic_signal_fence), .-_(atomic_signal_fence)
-
-        .global _(atomic_flag_test_and_set)
-        .type   _(atomic_flag_test_and_set), %function
-_(atomic_flag_test_and_set):
-        endbr32
-        mov    0x4(%esp),%edx
-        mov    $0x1,%eax
-        xchg   %al,(%edx)
-        ret
-	.size   _(atomic_flag_test_and_set), .-_(atomic_flag_test_and_set)
-
-        .global _(atomic_flag_test_and_set_explicit)
-        .type   _(atomic_flag_test_and_set_explicit), %function
-_(atomic_flag_test_and_set_explicit):
-        endbr32
-        mov    0x4(%esp),%edx
-        mov    $0x1,%eax
-        xchg   %al,(%edx)
+        .global _(__atomic_test_and_set)
+        .type   _(__atomic_test_and_set), %function
+_(__atomic_test_and_set):
+        movl    4(%esp), %edx
+        movl    $1, %eax
+        xchgb   (%edx), %al
+        ret
+	.size   _(__atomic_test_and_set), .-_(__atomic_test_and_set)
+
+        .global _(__atomic_clear)
+        .type   _(__atomic_clear), %function
+_(__atomic_clear):
+        movl    4(%esp), %edx
+        xorl    %eax, %eax
+        xchgb   (%edx), %al
         ret
-	.size   _(atomic_flag_test_and_set_explicit), .-_(atomic_flag_test_and_set_explicit)
-
-        .global _(atomic_flag_clear)
-        .type   _(atomic_flag_clear), %function
-_(atomic_flag_clear):
-        endbr32
-        mov    0x4(%esp),%edx
-        xor    %eax,%eax
-        xchg   %al,(%edx)
-        ret
-	.size   _(atomic_flag_clear), .-_(atomic_flag_clear)
-
-        .global _(atomic_flag_clear_explicit)
-        .type   _(atomic_flag_clear_explicit), %function
-_(atomic_flag_clear_explicit):
-        endbr32
-        mov    0x4(%esp),%edx
-        xor    %eax,%eax
-        xchg   %al,(%edx)
-        ret
-	.size   _(atomic_flag_clear_explicit), .-_(atomic_flag_clear_explicit)
-
-#endif //__i386__
-
-/* ---------------------------------------------- */
-#if defined __x86_64__ && !defined _WIN32
-
-#define endbr64
+	.size   _(__atomic_clear), .-_(__atomic_clear)
 
+#elif defined __x86_64__
         .text
+        .align  2
 
-        .global _(__atomic_load_1)
-        .type   _(__atomic_load_1), %function
-_(__atomic_load_1):
-        endbr64
-        movzbl (%rdi),%eax
-        ret
-	.size   _(__atomic_load_1), .-_(__atomic_load_1)
-
-        .global _(__atomic_load_2)
-        .type   _(__atomic_load_2), %function
-_(__atomic_load_2):
-        endbr64
-        movzwl (%rdi),%eax
+        .global _(__atomic_test_and_set)
+        .type   _(__atomic_test_and_set), %function
+_(__atomic_test_and_set):
+        movl    $1, %eax
+        xchgb   (%rdi), %al
         ret
-	.size   _(__atomic_load_2), .-_(__atomic_load_2)
+	.size   _(__atomic_test_and_set), .-_(__atomic_test_and_set)
 
-        .global _(__atomic_load_4)
-        .type   _(__atomic_load_4), %function
-_(__atomic_load_4):
-        endbr64
-        mov    (%rdi),%eax
+        .global _(__atomic_clear)
+        .type   _(__atomic_clear), %function
+_(__atomic_clear):
+        xorl    %eax, %eax
+        xchgb   (%rdi), %al
         ret
-	.size   _(__atomic_load_4), .-_(__atomic_load_4)
+	.size   _(__atomic_clear), .-_(__atomic_clear)
 
-        .global _(__atomic_load_8)
-        .type   _(__atomic_load_8), %function
-_(__atomic_load_8):
-        endbr64
-        mov    (%rdi),%rax
-        ret
-	.size   _(__atomic_load_8), .-_(__atomic_load_8)
-
-        .global _(__atomic_store_1)
-        .type   _(__atomic_store_1), %function
-_(__atomic_store_1):
-        endbr64
-        xchg   %sil,(%rdi)
-        ret
-	.size   _(__atomic_store_1), .-_(__atomic_store_1)
-
-        .global _(__atomic_store_2)
-        .type   _(__atomic_store_2), %function
-_(__atomic_store_2):
-        endbr64
-        xchg   %si,(%rdi)
-        ret
-	.size   _(__atomic_store_2), .-_(__atomic_store_2)
-
-        .global _(__atomic_store_4)
-        .type   _(__atomic_store_4), %function
-_(__atomic_store_4):
-        endbr64
-        xchg   %esi,(%rdi)
-        ret
-	.size   _(__atomic_store_4), .-_(__atomic_store_4)
-
-        .global _(__atomic_store_8)
-        .type   _(__atomic_store_8), %function
-_(__atomic_store_8):
-        endbr64
-        xchg   %rsi,(%rdi)
-        ret
-	.size   _(__atomic_store_8), .-_(__atomic_store_8)
+#elif defined __arm__
 
-        .global _(__atomic_compare_exchange_1)
-        .type   _(__atomic_compare_exchange_1), %function
-_(__atomic_compare_exchange_1):
-        endbr64
-        movzbl (%rsi),%eax
-        lock cmpxchg %dl,(%rdi)
-        sete   %dl
-        je      .L___atomic_compare_exchange_1_012
-        mov    %al,(%rsi)
-.L___atomic_compare_exchange_1_012:
-        mov    %edx,%eax
-        ret
-	.size   _(__atomic_compare_exchange_1), .-_(__atomic_compare_exchange_1)
-
-        .global _(__atomic_compare_exchange_2)
-        .type   _(__atomic_compare_exchange_2), %function
-_(__atomic_compare_exchange_2):
-        endbr64
-        movzwl (%rsi),%eax
-        lock cmpxchg %dx,(%rdi)
-        sete   %dl
-        je      .L___atomic_compare_exchange_2_014
-        mov    %ax,(%rsi)
-.L___atomic_compare_exchange_2_014:
-        mov    %edx,%eax
-        ret
-	.size   _(__atomic_compare_exchange_2), .-_(__atomic_compare_exchange_2)
-
-        .global _(__atomic_compare_exchange_4)
-        .type   _(__atomic_compare_exchange_4), %function
-_(__atomic_compare_exchange_4):
-        endbr64
-        mov    (%rsi),%eax
-        lock cmpxchg %edx,(%rdi)
-        sete   %dl
-        je      .L___atomic_compare_exchange_4_011
-        mov    %eax,(%rsi)
-.L___atomic_compare_exchange_4_011:
-        mov    %edx,%eax
-        ret
-	.size   _(__atomic_compare_exchange_4), .-_(__atomic_compare_exchange_4)
-
-        .global _(__atomic_compare_exchange_8)
-        .type   _(__atomic_compare_exchange_8), %function
-_(__atomic_compare_exchange_8):
-        endbr64
-        mov    (%rsi),%rax
-        lock cmpxchg %rdx,(%rdi)
-        sete   %dl
-        je      .L___atomic_compare_exchange_8_014
-        mov    %rax,(%rsi)
-.L___atomic_compare_exchange_8_014:
-        mov    %edx,%eax
-        ret
-	.size   _(__atomic_compare_exchange_8), .-_(__atomic_compare_exchange_8)
-
-        .global _(__atomic_test_and_set_1)
-        .type   _(__atomic_test_and_set_1), %function
-_(__atomic_test_and_set_1):
-        endbr64
-        mov    $0x1,%eax
-        xchg   %al,(%rdi)
-        ret
-	.size   _(__atomic_test_and_set_1), .-_(__atomic_test_and_set_1)
-
-        .global _(__atomic_test_and_set_2)
-        .type   _(__atomic_test_and_set_2), %function
-_(__atomic_test_and_set_2):
-        endbr64
-        mov    $0x1,%eax
-        xchg   %al,(%rdi)
-        ret
-	.size   _(__atomic_test_and_set_2), .-_(__atomic_test_and_set_2)
-
-        .global _(__atomic_test_and_set_4)
-        .type   _(__atomic_test_and_set_4), %function
-_(__atomic_test_and_set_4):
-        endbr64
-        mov    $0x1,%eax
-        xchg   %al,(%rdi)
-        ret
-	.size   _(__atomic_test_and_set_4), .-_(__atomic_test_and_set_4)
-
-        .global _(__atomic_test_and_set_8)
-        .type   _(__atomic_test_and_set_8), %function
-_(__atomic_test_and_set_8):
-        endbr64
-        mov    $0x1,%eax
-        xchg   %al,(%rdi)
-        ret
-	.size   _(__atomic_test_and_set_8), .-_(__atomic_test_and_set_8)
-
-        .global _(atomic_thread_fence)
-        .type   _(atomic_thread_fence), %function
-_(atomic_thread_fence):
-        endbr64
-        lock orq $0x0,(%rsp)
-        ret
-	.size   _(atomic_thread_fence), .-_(atomic_thread_fence)
-
-        .global _(atomic_signal_fence)
-        .type   _(atomic_signal_fence), %function
-_(atomic_signal_fence):
-        endbr64
-        ret
-	.size   _(atomic_signal_fence), .-_(atomic_signal_fence)
-
-        .global _(atomic_flag_test_and_set)
-        .type   _(atomic_flag_test_and_set), %function
-_(atomic_flag_test_and_set):
-        endbr64
-        mov    $0x1,%eax
-        xchg   %al,(%rdi)
-        ret
-	.size   _(atomic_flag_test_and_set), .-_(atomic_flag_test_and_set)
-
-        .global _(atomic_flag_test_and_set_explicit)
-        .type   _(atomic_flag_test_and_set_explicit), %function
-_(atomic_flag_test_and_set_explicit):
-        endbr64
-        mov    $0x1,%eax
-        xchg   %al,(%rdi)
-        ret
-	.size   _(atomic_flag_test_and_set_explicit), .-_(atomic_flag_test_and_set_explicit)
-
-        .global _(atomic_flag_clear)
-        .type   _(atomic_flag_clear), %function
-_(atomic_flag_clear):
-        endbr64
-        xor    %eax,%eax
-        xchg   %al,(%rdi)
-        ret
-	.size   _(atomic_flag_clear), .-_(atomic_flag_clear)
-
-        .global _(atomic_flag_clear_explicit)
-        .type   _(atomic_flag_clear_explicit), %function
-_(atomic_flag_clear_explicit):
-        endbr64
-        xor    %eax,%eax
-        xchg   %al,(%rdi)
-        ret
-	.size   _(atomic_flag_clear_explicit), .-_(atomic_flag_clear_explicit)
-
-#endif //__x86_64__ && !_WIN32
-
-/* ---------------------------------------------- */
-#if defined __x86_64__ && defined _WIN32
-        .text
-
-        .global _(__atomic_load_1)
-        .type   _(__atomic_load_1), %function
-_(__atomic_load_1):
-        movzbl (%rcx),%eax
-        ret
-	.size   _(__atomic_load_1), .-_(__atomic_load_1)
-
-        .global _(__atomic_load_2)
-        .type   _(__atomic_load_2), %function
-_(__atomic_load_2):
-        movzwl (%rcx),%eax
-        ret
-	.size   _(__atomic_load_2), .-_(__atomic_load_2)
-
-        .global _(__atomic_load_4)
-        .type   _(__atomic_load_4), %function
-_(__atomic_load_4):
-        mov    (%rcx),%eax
-        ret
-	.size   _(__atomic_load_4), .-_(__atomic_load_4)
-
-        .global _(__atomic_load_8)
-        .type   _(__atomic_load_8), %function
-_(__atomic_load_8):
-        mov    (%rcx),%rax
-        ret
-	.size   _(__atomic_load_8), .-_(__atomic_load_8)
-
-        .global _(__atomic_store_1)
-        .type   _(__atomic_store_1), %function
-_(__atomic_store_1):
-        xchg   %dl,(%rcx)
-        ret
-	.size   _(__atomic_store_1), .-_(__atomic_store_1)
-
-        .global _(__atomic_store_2)
-        .type   _(__atomic_store_2), %function
-_(__atomic_store_2):
-        xchg   %dx,(%rcx)
-        ret
-	.size   _(__atomic_store_2), .-_(__atomic_store_2)
-
-        .global _(__atomic_store_4)
-        .type   _(__atomic_store_4), %function
-_(__atomic_store_4):
-        xchg   %edx,(%rcx)
-        ret
-	.size   _(__atomic_store_4), .-_(__atomic_store_4)
-
-        .global _(__atomic_store_8)
-        .type   _(__atomic_store_8), %function
-_(__atomic_store_8):
-        xchg   %rdx,(%rcx)
-        ret
-	.size   _(__atomic_store_8), .-_(__atomic_store_8)
-
-        .global _(__atomic_compare_exchange_1)
-        .type   _(__atomic_compare_exchange_1), %function
-_(__atomic_compare_exchange_1):
-        movzbl (%rdx),%eax
-        lock cmpxchg %r8b,(%rcx)
-        sete   %cl
-        je      .L___atomic_compare_exchange_1_00f
-        mov    %al,(%rdx)
-.L___atomic_compare_exchange_1_00f:
-        mov    %ecx,%eax
-        ret
-	.size   _(__atomic_compare_exchange_1), .-_(__atomic_compare_exchange_1)
-
-        .global _(__atomic_compare_exchange_2)
-        .type   _(__atomic_compare_exchange_2), %function
-_(__atomic_compare_exchange_2):
-        movzwl (%rdx),%eax
-        lock cmpxchg %r8w,(%rcx)
-        sete   %cl
-        je      .L___atomic_compare_exchange_2_011
-        mov    %ax,(%rdx)
-.L___atomic_compare_exchange_2_011:
-        mov    %ecx,%eax
-        ret
-	.size   _(__atomic_compare_exchange_2), .-_(__atomic_compare_exchange_2)
-
-        .global _(__atomic_compare_exchange_4)
-        .type   _(__atomic_compare_exchange_4), %function
-_(__atomic_compare_exchange_4):
-        mov    (%rdx),%eax
-        lock cmpxchg %r8d,(%rcx)
-        sete   %cl
-        je      .L___atomic_compare_exchange_4_00e
-        mov    %eax,(%rdx)
-.L___atomic_compare_exchange_4_00e:
-        mov    %ecx,%eax
-        ret
-	.size   _(__atomic_compare_exchange_4), .-_(__atomic_compare_exchange_4)
-
-        .global _(__atomic_compare_exchange_8)
-        .type   _(__atomic_compare_exchange_8), %function
-_(__atomic_compare_exchange_8):
-        mov    (%rdx),%rax
-        lock cmpxchg %r8,(%rcx)
-        sete   %cl
-        je      .L___atomic_compare_exchange_8_010
-        mov    %rax,(%rdx)
-.L___atomic_compare_exchange_8_010:
-        mov    %ecx,%eax
-        ret
-	.size   _(__atomic_compare_exchange_8), .-_(__atomic_compare_exchange_8)
-
-        .global _(__atomic_test_and_set_1)
-        .type   _(__atomic_test_and_set_1), %function
-_(__atomic_test_and_set_1):
-        mov    $0x1,%eax
-        xchg   %al,(%rcx)
-        ret
-	.size   _(__atomic_test_and_set_1), .-_(__atomic_test_and_set_1)
-
-        .global _(__atomic_test_and_set_2)
-        .type   _(__atomic_test_and_set_2), %function
-_(__atomic_test_and_set_2):
-        mov    $0x1,%eax
-        xchg   %al,(%rcx)
-        ret
-	.size   _(__atomic_test_and_set_2), .-_(__atomic_test_and_set_2)
-
-        .global _(__atomic_test_and_set_4)
-        .type   _(__atomic_test_and_set_4), %function
-_(__atomic_test_and_set_4):
-        mov    $0x1,%eax
-        xchg   %al,(%rcx)
-        ret
-	.size   _(__atomic_test_and_set_4), .-_(__atomic_test_and_set_4)
-
-        .global _(__atomic_test_and_set_8)
-        .type   _(__atomic_test_and_set_8), %function
-_(__atomic_test_and_set_8):
-        mov    $0x1,%eax
-        xchg   %al,(%rcx)
-        ret
-	.size   _(__atomic_test_and_set_8), .-_(__atomic_test_and_set_8)
-
-        .global _(atomic_thread_fence)
-        .type   _(atomic_thread_fence), %function
-_(atomic_thread_fence):
-        lock orq $0x0,(%rsp)
-        ret
-	.size   _(atomic_thread_fence), .-_(atomic_thread_fence)
-
-        .global _(atomic_signal_fence)
-        .type   _(atomic_signal_fence), %function
-_(atomic_signal_fence):
-        ret
-	.size   _(atomic_signal_fence), .-_(atomic_signal_fence)
-
-        .global _(atomic_flag_test_and_set)
-        .type   _(atomic_flag_test_and_set), %function
-_(atomic_flag_test_and_set):
-        mov    $0x1,%eax
-        xchg   %al,(%rcx)
-        ret
-	.size   _(atomic_flag_test_and_set), .-_(atomic_flag_test_and_set)
-
-        .global _(atomic_flag_test_and_set_explicit)
-        .type   _(atomic_flag_test_and_set_explicit), %function
-_(atomic_flag_test_and_set_explicit):
-        mov    $0x1,%eax
-        xchg   %al,(%rcx)
-        ret
-	.size   _(atomic_flag_test_and_set_explicit), .-_(atomic_flag_test_and_set_explicit)
-
-        .global _(atomic_flag_clear)
-        .type   _(atomic_flag_clear), %function
-_(atomic_flag_clear):
-        xor    %eax,%eax
-        xchg   %al,(%rcx)
-        ret
-	.size   _(atomic_flag_clear), .-_(atomic_flag_clear)
-
-        .global _(atomic_flag_clear_explicit)
-        .type   _(atomic_flag_clear_explicit), %function
-_(atomic_flag_clear_explicit):
-        xor    %eax,%eax
-        xchg   %al,(%rcx)
-        ret
-	.size   _(atomic_flag_clear_explicit), .-_(atomic_flag_clear_explicit)
-
-#endif //__x86_64__ && _WIN32
-
-/* ---------------------------------------------- */
-#if defined __arm__
-        .text
 #ifndef __TINYC__
-        .arch   armv6k
-        .syntax unified
-#endif
-
-        .global _(__atomic_load_1)
-        .type   _(__atomic_load_1), %function
-_(__atomic_load_1):
-#ifdef __TINYC__
-        .int 0xe3510000
-        .int 0x1a000002
-        .int 0xe5d00000
-        .int 0xe6ef0070
-        .int 0xe12fff1e
-        .int 0xee070fba
-        .int 0xe5d00000
-        .int 0xee070fba
-        .int 0xe6ef0070
-        .int 0xe12fff1e
-#else
-        cmp r1, #0
-        bne  .L___atomic_load_1_014
-        ldrb    r0, [r0]
-        uxtb    r0, r0
-        bx  lr
-.L___atomic_load_1_014:
-        mcr     p15, #0, r0, c7, c10, #5
-        ldrb    r0, [r0]
-        mcr     p15, #0, r0, c7, c10, #5
-        uxtb    r0, r0
-        bx  lr
-	.size   _(__atomic_load_1), .-_(__atomic_load_1)
-
+	.arch armv6k
+	.syntax unified
 #endif
-        .global _(__atomic_load_2)
-        .type   _(__atomic_load_2), %function
-_(__atomic_load_2):
-#ifdef __TINYC__
-        .int 0xe3510000
-        .int 0x1a000002
-        .int 0xe1d000b0
-        .int 0xe6ff0070
-        .int 0xe12fff1e
-        .int 0xee070fba
-        .int 0xe1d000b0
-        .int 0xee070fba
-        .int 0xe6ff0070
-        .int 0xe12fff1e
-#else
-        cmp r1, #0
-        bne  .L___atomic_load_2_03c
-        ldrh    r0, [r0]
-        uxth    r0, r0
-        bx  lr
-.L___atomic_load_2_03c:
-        mcr     p15, #0, r0, c7, c10, #5
-        ldrh    r0, [r0]
-        mcr     p15, #0, r0, c7, c10, #5
-        uxth    r0, r0
-        bx  lr
-	.size   _(__atomic_load_2), .-_(__atomic_load_2)
-
-#endif
-        .global _(__atomic_load_4)
-        .type   _(__atomic_load_4), %function
-_(__atomic_load_4):
-#ifdef __TINYC__
-        .int 0xe3510000
-        .int 0x1a000001
-        .int 0xe5900000
-        .int 0xe12fff1e
-        .int 0xee070fba
-        .int 0xe5900000
-        .int 0xee070fba
-        .int 0xe12fff1e
-#else
-        cmp r1, #0
-        bne  .L___atomic_load_4_060
-        ldr r0, [r0]
-        bx  lr
-.L___atomic_load_4_060:
-        mcr     p15, #0, r0, c7, c10, #5
-        ldr r0, [r0]
-        mcr     p15, #0, r0, c7, c10, #5
-        bx  lr
-	.size   _(__atomic_load_4), .-_(__atomic_load_4)
-
-#endif
-        .global _(__atomic_load_8)
-        .type   _(__atomic_load_8), %function
-_(__atomic_load_8):
-#ifdef __TINYC__
-        .int 0xe3510000
-        .int 0x1a000001
-        .int 0xe1b00f9f
-        .int 0xe12fff1e
-        .int 0xee070fba
-        .int 0xe1b00f9f
-        .int 0xee070fba
-        .int 0xe12fff1e
-#else
-        cmp r1, #0
-        bne  .L___atomic_load_8_080
-        ldrexd  r0, [r0]
-        bx  lr
-.L___atomic_load_8_080:
-        mcr     p15, #0, r0, c7, c10, #5
-        ldrexd  r0, [r0]
-        mcr     p15, #0, r0, c7, c10, #5
-        bx  lr
-	.size   _(__atomic_load_8), .-_(__atomic_load_8)
-
-#endif
-        .global _(__atomic_store_1)
-        .type   _(__atomic_store_1), %function
-_(__atomic_store_1):
-#ifdef __TINYC__
-        .int 0xe3520000
-        .int 0x1a000001
-        .int 0xe5c01000
-        .int 0xe12fff1e
-        .int 0xee070fba
-        .int 0xe5c01000
-        .int 0xee070fba
-        .int 0xe12fff1e
-#else
-        cmp r2, #0
-        bne  .L___atomic_store_1_0a0
-        strb    r1, [r0]
-        bx  lr
-.L___atomic_store_1_0a0:
-        mcr     p15, #0, r0, c7, c10, #5
-        strb    r1, [r0]
-        mcr     p15, #0, r0, c7, c10, #5
-        bx  lr
-	.size   _(__atomic_store_1), .-_(__atomic_store_1)
-
-#endif
-        .global _(__atomic_store_2)
-        .type   _(__atomic_store_2), %function
-_(__atomic_store_2):
-#ifdef __TINYC__
-        .int 0xe3520000
-        .int 0x1a000001
-        .int 0xe1c010b0
-        .int 0xe12fff1e
-        .int 0xee070fba
-        .int 0xe1c010b0
-        .int 0xee070fba
-        .int 0xe12fff1e
-#else
-        cmp r2, #0
-        bne  .L___atomic_store_2_0c0
-        strh    r1, [r0]
-        bx  lr
-.L___atomic_store_2_0c0:
-        mcr     p15, #0, r0, c7, c10, #5
-        strh    r1, [r0]
-        mcr     p15, #0, r0, c7, c10, #5
-        bx  lr
-	.size   _(__atomic_store_2), .-_(__atomic_store_2)
-
-#endif
-        .global _(__atomic_store_4)
-        .type   _(__atomic_store_4), %function
-_(__atomic_store_4):
-#ifdef __TINYC__
-        .int 0xe3520000
-        .int 0x1a000001
-        .int 0xe5801000
-        .int 0xe12fff1e
-        .int 0xee070fba
-        .int 0xe5801000
-        .int 0xee070fba
-        .int 0xe12fff1e
-#else
-        cmp r2, #0
-        bne  .L___atomic_store_4_0e0
-        str r1, [r0]
-        bx  lr
-.L___atomic_store_4_0e0:
-        mcr     p15, #0, r0, c7, c10, #5
-        str r1, [r0]
-        mcr     p15, #0, r0, c7, c10, #5
-        bx  lr
-	.size   _(__atomic_store_4), .-_(__atomic_store_4)
+        .text
+        .align  2
 
+        .global _(fetch_and_add_arm)
+        .type   _(fetch_and_add_arm), %function
+_(fetch_and_add_arm):
+        mcr     p15, #0, r0, c7, c10, #5
+.L0:
+        ldrex   r3, [r0]
+        add     r3, r3, r1
+        strex   r2, r3, [r0]
+        cmp     r2, #0
+        bne     .L0
+        mcr     p15, #0, r0, c7, c10, #5
+        bx      lr
+        .size   _(fetch_and_add_arm), .-_(fetch_and_add_arm)
+
+        .global _(__atomic_test_and_set)
+        .type   _(__atomic_test_and_set), %function
+_(__atomic_test_and_set):
+#ifdef __TINYC__
+	.int	0xe92d4030
+	.int	0xee070fba
+	.int	0xe5d03000
+	.int	0xe24dd014
+	.int	0xe1a05000
+	.int	0xe2533000
+	.int	0xe1a04001
+	.int	0x13a03001
+	.int	0xee070fba
+	.int	0xe5cd300f
+	.int	0xe3a03001
+	.int	0xe1a02003
+	.int	0xe28d100f
+	.int	0xe1a00005
+	.int	0xe58d4004
+	.int	0xe58d4000
+	.int	0xeb000009
+	.int	0xe3500000
+	.int	0x0afffff6
+	.int	0xe5dd000f
+	.int	0xe28dd014
+	.int	0xe8bd8030
+#else
+        push    {r4, r5, lr}
+        mcr     p15, 0, r0, c7, c10, 5
+        ldrb    r3, [r0]
+        sub     sp, sp, #20
+        mov     r5, r0
+        subs    r3, r3, #0
+        mov     r4, r1
+        movne   r3, #1
+        mcr     p15, 0, r0, c7, c10, 5
+        strb    r3, [sp, #15]
+.L20:
+        mov     r3, #1
+        mov     r2, r3
+        add     r1, sp, #15
+        mov     r0, r5
+        str     r4, [sp, #4]
+        str     r4, [sp]
+        bl      __atomic_compare_exchange_1
+        cmp     r0, #0
+        beq     .L20
+        ldrb    r0, [sp, #15]
+        add     sp, sp, #20
+        pop     {r4, r5, pc}
+#endif
+	.size   _(__atomic_test_and_set), .-_(__atomic_test_and_set)
+
+        .global _(__atomic_clear)
+        .type   _(__atomic_clear), %function
+_(__atomic_clear):
+#ifdef __TINYC__
+	.int	0xe3a03000
+	.int	0xee070fba
+	.int	0xe5c03000
+	.int	0xee070fba
+	.int	0xe12fff1e
+#else
+         mov     r3, #0
+         mcr     p15, 0, r0, c7, c10, 5
+         strb    r3, [r0]
+         mcr     p15, 0, r0, c7, c10, 5
+         bx      lr
 #endif
-        .global _(__atomic_store_8)
-        .type   _(__atomic_store_8), %function
-_(__atomic_store_8):
-#ifdef __TINYC__
-        .int 0xe92d0030
-        .int 0xe1a04002
-        .int 0xe59d1008
-        .int 0xe1a05003
-        .int 0xe3510000
-        .int 0x1a000005
-        .int 0xe1b02f9f
-        .int 0xe1a01f94
-        .int 0xe3510000
-        .int 0x1afffffb
-        .int 0xe8bd0030
-        .int 0xe12fff1e
-        .int 0xee070fba
-        .int 0xe1b02f9f
-        .int 0xe1a01f94
-        .int 0xe3510000
-        .int 0x1afffffb
-        .int 0xee070fba
-        .int 0xe8bd0030
-        .int 0xe12fff1e
-#else
-        push    {r4, r5}
-        mov r4, r2
-        ldr r1, [sp, #8]
-        mov r5, r3
-        cmp r1, #0
-        bne  .L___atomic_store_8_120
-.L___atomic_store_8_108:
-        ldrexd  r2, [r0]
-        strexd  r1, r4, [r0]
-        cmp r1, #0
-        bne  .L___atomic_store_8_108
-        pop {r4, r5}
-        bx  lr
-.L___atomic_store_8_120:
-        mcr     p15, #0, r0, c7, c10, #5
-.L___atomic_store_8_124:
-        ldrexd  r2, [r0]
-        strexd  r1, r4, [r0]
-        cmp r1, #0
-        bne  .L___atomic_store_8_124
-        mcr     p15, #0, r0, c7, c10, #5
-        pop {r4, r5}
-        bx  lr
-	.size   _(__atomic_store_8), .-_(__atomic_store_8)
+	.size   _(__atomic_clear), .-_(__atomic_clear)
 
-#endif
         .global _(__atomic_compare_exchange_1)
         .type   _(__atomic_compare_exchange_1), %function
 _(__atomic_compare_exchange_1):
 #ifdef __TINYC__
-        .int 0xe52de004
-        .int 0xe3530000
-        .int 0x1a00000a
-        .int 0xe5d13000
-        .int 0xe1d0cf9f
-        .int 0xe15c0003
-        .int 0x1a000002
-        .int 0xe1c0ef92
-        .int 0xe35e0000
-        .int 0x1afffff9
-        .int 0x03a00001
-        .int 0x13a00000
-        .int 0x15c1c000
-        .int 0xe49df004
-        .int 0xe5d13000
-        .int 0xee070fba
-        .int 0xe1d0cf9f
-        .int 0xe15c0003
-        .int 0x1afffff6
-        .int 0xe1c0ef92
-        .int 0xe35e0000
-        .int 0x1afffff9
-        .int 0xee070fba
-        .int 0xeafffff1
+	.int	0xe52de004
+	.int	0xe5d13000
+	.int	0xf57ff05b
+	.int	0xe1d0cf9f
+	.int	0xe15c0003
+	.int	0x1a000002
+	.int	0xe1c0ef92
+	.int	0xe35e0000
+	.int	0x1afffff9
+	.int	0x03a00001
+	.int	0x13a00000
+	.int	0xf57ff05b
+	.int	0x15c1c000
+	.int	0xe49df004
 #else
-        push    {lr}        @ (str lr, [sp, #-4]!)
-        cmp r3, #0
-        bne  .L___atomic_compare_exchange_1_178
+        str     lr, [sp, #-4]!
         ldrb    r3, [r1]
-.L___atomic_compare_exchange_1_150:
+        mcr     p15, 0, r0, c7, c10, 5
+.L1:
         ldrexb  ip, [r0]
-        cmp ip, r3
-        bne  .L___atomic_compare_exchange_1_168
+        cmp     ip, r3
+        bne     .L2
         strexb  lr, r2, [r0]
-        cmp lr, #0
-        bne  .L___atomic_compare_exchange_1_150
-.L___atomic_compare_exchange_1_168:
+        cmp     lr, #0
+        bne     .L1
+.L2:
+        mcr     p15, 0, r0, c7, c10, 5
         moveq   r0, #1
         movne   r0, #0
         strbne  ip, [r1]
-        pop {pc}        @ (ldr pc, [sp], #4)
-.L___atomic_compare_exchange_1_178:
-        ldrb    r3, [r1]
-        mcr     p15, #0, r0, c7, c10, #5
-.L___atomic_compare_exchange_1_180:
-        ldrexb  ip, [r0]
-        cmp ip, r3
-        bne  .L___atomic_compare_exchange_1_168
-        strexb  lr, r2, [r0]
-        cmp lr, #0
-        bne  .L___atomic_compare_exchange_1_180
-        mcr     p15, #0, r0, c7, c10, #5
-        b    .L___atomic_compare_exchange_1_168
+        ldr     pc, [sp], #4
+#endif
 	.size   _(__atomic_compare_exchange_1), .-_(__atomic_compare_exchange_1)
 
-#endif
         .global _(__atomic_compare_exchange_2)
         .type   _(__atomic_compare_exchange_2), %function
 _(__atomic_compare_exchange_2):
 #ifdef __TINYC__
-        .int 0xe52de004
-        .int 0xe3530000
-        .int 0x1a00000a
-        .int 0xe1d130b0
-        .int 0xe1f0cf9f
-        .int 0xe15c0003
-        .int 0x1a000002
-        .int 0xe1e0ef92
-        .int 0xe35e0000
-        .int 0x1afffff9
-        .int 0x03a00001
-        .int 0x13a00000
-        .int 0x11c1c0b0
-        .int 0xe49df004
-        .int 0xe1d130b0
-        .int 0xee070fba
-        .int 0xe1f0cf9f
-        .int 0xe15c0003
-        .int 0x1afffff6
-        .int 0xe1e0ef92
-        .int 0xe35e0000
-        .int 0x1afffff9
-        .int 0xee070fba
-        .int 0xeafffff1
+	.int	0xe52de004
+	.int	0xe1d130b0
+	.int	0xf57ff05b
+	.int	0xe1f0cf9f
+	.int	0xe15c0003
+	.int	0x1a000002
+	.int	0xe1e0ef92
+	.int	0xe35e0000
+	.int	0x1afffff9
+	.int	0x03a00001
+	.int	0x13a00000
+	.int	0xf57ff05b
+	.int	0x11c1c0b0
+	.int	0xe49df004
 #else
-        push    {lr}        @ (str lr, [sp, #-4]!)
-        cmp r3, #0
-        bne  .L___atomic_compare_exchange_2_1d8
+        str     lr, [sp, #-4]!
         ldrh    r3, [r1]
-.L___atomic_compare_exchange_2_1b0:
+        mcr     p15, 0, r0, c7, c10, 5
+.L3:
         ldrexh  ip, [r0]
-        cmp ip, r3
-        bne  .L___atomic_compare_exchange_2_1c8
+        cmp     ip, r3
+        bne     .L4
         strexh  lr, r2, [r0]
-        cmp lr, #0
-        bne  .L___atomic_compare_exchange_2_1b0
-.L___atomic_compare_exchange_2_1c8:
+        cmp     lr, #0
+        bne     .L3
+.L4:
+        mcr     p15, 0, r0, c7, c10, 5
         moveq   r0, #1
         movne   r0, #0
         strhne  ip, [r1]
-        pop {pc}        @ (ldr pc, [sp], #4)
-.L___atomic_compare_exchange_2_1d8:
-        ldrh    r3, [r1]
-        mcr     p15, #0, r0, c7, c10, #5
-.L___atomic_compare_exchange_2_1e0:
-        ldrexh  ip, [r0]
-        cmp ip, r3
-        bne  .L___atomic_compare_exchange_2_1c8
-        strexh  lr, r2, [r0]
-        cmp lr, #0
-        bne  .L___atomic_compare_exchange_2_1e0
-        mcr     p15, #0, r0, c7, c10, #5
-        b    .L___atomic_compare_exchange_2_1c8
+	ldr     pc, [sp], #4
+#endif
 	.size   _(__atomic_compare_exchange_2), .-_(__atomic_compare_exchange_2)
 
-#endif
         .global _(__atomic_compare_exchange_4)
         .type   _(__atomic_compare_exchange_4), %function
 _(__atomic_compare_exchange_4):
 #ifdef __TINYC__
-        .int 0xe52d4004
-        .int 0xe3530000
-        .int 0x1a00000b
-        .int 0xe5913000
-        .int 0xe1904f9f
-        .int 0xe1540003
-        .int 0x1a000002
-        .int 0xe180cf92
-        .int 0xe35c0000
-        .int 0x1afffff9
-        .int 0x03a00001
-        .int 0x13a00000
-        .int 0x15814000
-        .int 0xe49d4004
-        .int 0xe12fff1e
-        .int 0xe5913000
-        .int 0xee070fba
-        .int 0xe1904f9f
-        .int 0xe1540003
-        .int 0x1afffff5
-        .int 0xe180cf92
-        .int 0xe35c0000
-        .int 0x1afffff9
-        .int 0xee070fba
-        .int 0xeafffff0
-#else
-        push    {r4}        @ (str r4, [sp, #-4]!)
-        cmp r3, #0
-        bne  .L___atomic_compare_exchange_4_23c
-        ldr r3, [r1]
-.L___atomic_compare_exchange_4_210:
-        ldrex   r4, [r0]
-        cmp r4, r3
-        bne  .L___atomic_compare_exchange_4_228
-        strex   ip, r2, [r0]
-        cmp ip, #0
-        bne  .L___atomic_compare_exchange_4_210
-.L___atomic_compare_exchange_4_228:
+	.int	0xe52de004
+	.int	0xe5913000
+	.int	0xf57ff05b
+	.int	0xe190cf9f
+	.int	0xe15c0003
+	.int	0x1a000002
+	.int	0xe180ef92
+	.int	0xe35e0000
+	.int	0x1afffff9
+	.int	0x03a00001
+	.int	0x13a00000
+	.int	0xf57ff05b
+	.int	0x1581c000
+	.int	0xe49df004
+#else
+        str     lr, [sp, #-4]!
+        ldr     r3, [r1]
+        mcr     p15, 0, r0, c7, c10, 5
+.L5:
+        ldrex   ip, [r0]
+        cmp     ip, r3
+        bne     .L6
+        strex   lr, r2, [r0]
+        cmp     lr, #0
+        bne     .L5
+.L6:
+        mcr     p15, 0, r0, c7, c10, 5
         moveq   r0, #1
         movne   r0, #0
-        strne   r4, [r1]
-        pop {r4}        @ (ldr r4, [sp], #4)
-        bx  lr
-.L___atomic_compare_exchange_4_23c:
-        ldr r3, [r1]
-        mcr     p15, #0, r0, c7, c10, #5
-.L___atomic_compare_exchange_4_244:
-        ldrex   r4, [r0]
-        cmp r4, r3
-        bne  .L___atomic_compare_exchange_4_228
-        strex   ip, r2, [r0]
-        cmp ip, #0
-        bne  .L___atomic_compare_exchange_4_244
-        mcr     p15, #0, r0, c7, c10, #5
-        b    .L___atomic_compare_exchange_4_228
-	.size   _(__atomic_compare_exchange_4), .-_(__atomic_compare_exchange_4)
-
-#endif
-        .global _(__atomic_compare_exchange_8)
-        .type   _(__atomic_compare_exchange_8), %function
-_(__atomic_compare_exchange_8):
-#ifdef __TINYC__
-        .int 0xe92d00f0
-        .int 0xe1a05003
-        .int 0xe59d3010
-        .int 0xe1a04002
-        .int 0xe3530000
-        .int 0x1a00000c
-        .int 0xe1c120d0
-        .int 0xe1b06f9f
-        .int 0xe1570003
-        .int 0x01560002
-        .int 0x1a000002
-        .int 0xe1a0cf94
-        .int 0xe35c0000
-        .int 0x1afffff8
-        .int 0x03a00001
-        .int 0x13a00000
-        .int 0x11c160f0
-        .int 0xe8bd00f0
-        .int 0xe12fff1e
-        .int 0xe1c120d0
-        .int 0xee070fba
-        .int 0xe1b06f9f
-        .int 0xe1570003
-        .int 0x01560002
-        .int 0x1afffff4
-        .int 0xe1a0cf94
-        .int 0xe35c0000
-        .int 0x1afffff8
-        .int 0xee070fba
-        .int 0xeaffffef
-#else
-        push    {r4, r5, r6, r7}
-        mov r5, r3
-        ldr r3, [sp, #16]
-        mov r4, r2
-        cmp r3, #0
-        bne  .L___atomic_compare_exchange_8_2b0
-        ldrd    r2, [r1]
-.L___atomic_compare_exchange_8_280:
-        ldrexd  r6, [r0]
-        cmp r7, r3
-        cmpeq   r6, r2
-        bne  .L___atomic_compare_exchange_8_29c
-        strexd  ip, r4, [r0]
-        cmp ip, #0
-        bne  .L___atomic_compare_exchange_8_280
-.L___atomic_compare_exchange_8_29c:
-        moveq   r0, #1
-        movne   r0, #0
-        strdne  r6, [r1]
-        pop {r4, r5, r6, r7}
-        bx  lr
-.L___atomic_compare_exchange_8_2b0:
-        ldrd    r2, [r1]
-        mcr     p15, #0, r0, c7, c10, #5
-.L___atomic_compare_exchange_8_2b8:
-        ldrexd  r6, [r0]
-        cmp r7, r3
-        cmpeq   r6, r2
-        bne  .L___atomic_compare_exchange_8_29c
-        strexd  ip, r4, [r0]
-        cmp ip, #0
-        bne  .L___atomic_compare_exchange_8_2b8
-        mcr     p15, #0, r0, c7, c10, #5
-        b    .L___atomic_compare_exchange_8_29c
-	.size   _(__atomic_compare_exchange_8), .-_(__atomic_compare_exchange_8)
-
-#endif
-        .global _(__atomic_test_and_set_1)
-        .type   _(__atomic_test_and_set_1), %function
-_(__atomic_test_and_set_1):
-#ifdef __TINYC__
-        .int 0xe3a02001
-        .int 0xe3510000
-        .int 0x1a000005
-        .int 0xe1d03f9f
-        .int 0xe1c01f92
-        .int 0xe3510000
-        .int 0x1afffffb
-        .int 0xe6ef0073
-        .int 0xe12fff1e
-        .int 0xee070fba
-        .int 0xe1d03f9f
-        .int 0xe1c01f92
-        .int 0xe3510000
-        .int 0x1afffffb
-        .int 0xe6ef0073
-        .int 0xee070fba
-        .int 0xe12fff1e
-#else
-        mov r2, #1
-        cmp r1, #0
-        bne  .L___atomic_test_and_set_1_300
-.L___atomic_test_and_set_1_2e8:
-        ldrexb  r3, [r0]
-        strexb  r1, r2, [r0]
-        cmp r1, #0
-        bne  .L___atomic_test_and_set_1_2e8
-        uxtb    r0, r3
-        bx  lr
-.L___atomic_test_and_set_1_300:
-        mcr     p15, #0, r0, c7, c10, #5
-.L___atomic_test_and_set_1_304:
-        ldrexb  r3, [r0]
-        strexb  r1, r2, [r0]
-        cmp r1, #0
-        bne  .L___atomic_test_and_set_1_304
-        uxtb    r0, r3
-        mcr     p15, #0, r0, c7, c10, #5
-        bx  lr
-	.size   _(__atomic_test_and_set_1), .-_(__atomic_test_and_set_1)
-
-#endif
-        .global _(__atomic_test_and_set_2)
-        .type   _(__atomic_test_and_set_2), %function
-_(__atomic_test_and_set_2):
-#ifdef __TINYC__
-        .int 0xe3a02001
-        .int 0xe3510000
-        .int 0x1a000005
-        .int 0xe1d03f9f
-        .int 0xe1c01f92
-        .int 0xe3510000
-        .int 0x1afffffb
-        .int 0xe6ef0073
-        .int 0xe12fff1e
-        .int 0xee070fba
-        .int 0xe1d03f9f
-        .int 0xe1c01f92
-        .int 0xe3510000
-        .int 0x1afffffb
-        .int 0xe6ef0073
-        .int 0xee070fba
-        .int 0xe12fff1e
-#else
-        mov r2, #1
-        cmp r1, #0
-        bne  .L___atomic_test_and_set_2_344
-.L___atomic_test_and_set_2_32c:
-        ldrexb  r3, [r0]
-        strexb  r1, r2, [r0]
-        cmp r1, #0
-        bne  .L___atomic_test_and_set_2_32c
-        uxtb    r0, r3
-        bx  lr
-.L___atomic_test_and_set_2_344:
-        mcr     p15, #0, r0, c7, c10, #5
-.L___atomic_test_and_set_2_348:
-        ldrexb  r3, [r0]
-        strexb  r1, r2, [r0]
-        cmp r1, #0
-        bne  .L___atomic_test_and_set_2_348
-        uxtb    r0, r3
-        mcr     p15, #0, r0, c7, c10, #5
-        bx  lr
-	.size   _(__atomic_test_and_set_2), .-_(__atomic_test_and_set_2)
-
-#endif
-        .global _(__atomic_test_and_set_4)
-        .type   _(__atomic_test_and_set_4), %function
-_(__atomic_test_and_set_4):
-#ifdef __TINYC__
-        .int 0xe3a02001
-        .int 0xe3510000
-        .int 0x1a000005
-        .int 0xe1d03f9f
-        .int 0xe1c01f92
-        .int 0xe3510000
-        .int 0x1afffffb
-        .int 0xe6ef0073
-        .int 0xe12fff1e
-        .int 0xee070fba
-        .int 0xe1d03f9f
-        .int 0xe1c01f92
-        .int 0xe3510000
-        .int 0x1afffffb
-        .int 0xe6ef0073
-        .int 0xee070fba
-        .int 0xe12fff1e
-#else
-        mov r2, #1
-        cmp r1, #0
-        bne  .L___atomic_test_and_set_4_388
-.L___atomic_test_and_set_4_370:
-        ldrexb  r3, [r0]
-        strexb  r1, r2, [r0]
-        cmp r1, #0
-        bne  .L___atomic_test_and_set_4_370
-        uxtb    r0, r3
-        bx  lr
-.L___atomic_test_and_set_4_388:
-        mcr     p15, #0, r0, c7, c10, #5
-.L___atomic_test_and_set_4_38c:
-        ldrexb  r3, [r0]
-        strexb  r1, r2, [r0]
-        cmp r1, #0
-        bne  .L___atomic_test_and_set_4_38c
-        uxtb    r0, r3
-        mcr     p15, #0, r0, c7, c10, #5
-        bx  lr
-	.size   _(__atomic_test_and_set_4), .-_(__atomic_test_and_set_4)
-
-#endif
-        .global _(__atomic_test_and_set_8)
-        .type   _(__atomic_test_and_set_8), %function
-_(__atomic_test_and_set_8):
-#ifdef __TINYC__
-        .int 0xe3a02001
-        .int 0xe3510000
-        .int 0x1a000005
-        .int 0xe1d03f9f
-        .int 0xe1c01f92
-        .int 0xe3510000
-        .int 0x1afffffb
-        .int 0xe6ef0073
-        .int 0xe12fff1e
-        .int 0xee070fba
-        .int 0xe1d03f9f
-        .int 0xe1c01f92
-        .int 0xe3510000
-        .int 0x1afffffb
-        .int 0xe6ef0073
-        .int 0xee070fba
-        .int 0xe12fff1e
-#else
-        mov r2, #1
-        cmp r1, #0
-        bne  .L___atomic_test_and_set_8_3cc
-.L___atomic_test_and_set_8_3b4:
-        ldrexb  r3, [r0]
-        strexb  r1, r2, [r0]
-        cmp r1, #0
-        bne  .L___atomic_test_and_set_8_3b4
-        uxtb    r0, r3
-        bx  lr
-.L___atomic_test_and_set_8_3cc:
-        mcr     p15, #0, r0, c7, c10, #5
-.L___atomic_test_and_set_8_3d0:
-        ldrexb  r3, [r0]
-        strexb  r1, r2, [r0]
-        cmp r1, #0
-        bne  .L___atomic_test_and_set_8_3d0
-        uxtb    r0, r3
-        mcr     p15, #0, r0, c7, c10, #5
-        bx  lr
-	.size   _(__atomic_test_and_set_8), .-_(__atomic_test_and_set_8)
-
-#endif
-        .global _(atomic_thread_fence)
-        .type   _(atomic_thread_fence), %function
-_(atomic_thread_fence):
-#ifdef __TINYC__
-        .int 0xee070fba
-        .int 0xe12fff1e
-#else
-        mcr     p15, #0, r0, c7, c10, #5
-        bx  lr
-	.size   _(atomic_thread_fence), .-_(atomic_thread_fence)
-
-#endif
-        .global _(atomic_signal_fence)
-        .type   _(atomic_signal_fence), %function
-_(atomic_signal_fence):
-#ifdef __TINYC__
-        .int 0xe12fff1e
-#else
-        bx  lr
-	.size   _(atomic_signal_fence), .-_(atomic_signal_fence)
-
-#endif
-        .global _(atomic_flag_test_and_set)
-        .type   _(atomic_flag_test_and_set), %function
-_(atomic_flag_test_and_set):
-#ifdef __TINYC__
-        .int 0xe3a02001
-        .int 0xee070fba
-        .int 0xe1d03f9f
-        .int 0xe1c01f92
-        .int 0xe3510000
-        .int 0x1afffffb
-        .int 0xe6ef0073
-        .int 0xee070fba
-        .int 0xe12fff1e
-#else
-        mov r2, #1
-        mcr     p15, #0, r0, c7, c10, #5
-.L_atomic_flag_test_and_set_400:
-        ldrexb  r3, [r0]
-        strexb  r1, r2, [r0]
-        cmp r1, #0
-        bne  .L_atomic_flag_test_and_set_400
-        uxtb    r0, r3
-        mcr     p15, #0, r0, c7, c10, #5
-        bx  lr
-	.size   _(atomic_flag_test_and_set), .-_(atomic_flag_test_and_set)
-
-#endif
-        .global _(atomic_flag_test_and_set_explicit)
-        .type   _(atomic_flag_test_and_set_explicit), %function
-_(atomic_flag_test_and_set_explicit):
-#ifdef __TINYC__
-        .int 0xe3a02001
-        .int 0xee070fba
-        .int 0xe1d03f9f
-        .int 0xe1c01f92
-        .int 0xe3510000
-        .int 0x1afffffb
-        .int 0xe6ef0073
-        .int 0xee070fba
-        .int 0xe12fff1e
-#else
-        mov r2, #1
-        mcr     p15, #0, r0, c7, c10, #5
-.L_atomic_flag_test_and_set_explicit_424:
-        ldrexb  r3, [r0]
-        strexb  r1, r2, [r0]
-        cmp r1, #0
-        bne  .L_atomic_flag_test_and_set_explicit_424
-        uxtb    r0, r3
-        mcr     p15, #0, r0, c7, c10, #5
-        bx  lr
-	.size   _(atomic_flag_test_and_set_explicit), .-_(atomic_flag_test_and_set_explicit)
-
+        strne   ip, [r1]
+        ldr     pc, [sp], #4
 #endif
-        .global _(atomic_flag_clear)
-        .type   _(atomic_flag_clear), %function
-_(atomic_flag_clear):
-#ifdef __TINYC__
-        .int 0xe3b03000
-        .int 0xee070fba
-        .int 0xe5c03000
-        .int 0xee070fba
-        .int 0xe12fff1e
-#else
-        movs    r3, #0
-        mcr     p15, #0, r0, c7, c10, #5
-        strb    r3, [r0]
-        mcr     p15, #0, r0, c7, c10, #5
-        bx  lr
-	.size   _(atomic_flag_clear), .-_(atomic_flag_clear)
-
-#endif
-        .global _(atomic_flag_clear_explicit)
-        .type   _(atomic_flag_clear_explicit), %function
-_(atomic_flag_clear_explicit):
-#ifdef __TINYC__
-        .int 0xe3b03000
-        .int 0xee070fba
-        .int 0xe5c03000
-        .int 0xee070fba
-        .int 0xe12fff1e
-#else
-        movs    r3, #0
-        mcr     p15, #0, r0, c7, c10, #5
-        strb    r3, [r0]
-        mcr     p15, #0, r0, c7, c10, #5
-        bx  lr
-	.size   _(atomic_flag_clear_explicit), .-_(atomic_flag_clear_explicit)
-
-#endif
-#endif //__arm__
+	.size   _(__atomic_compare_exchange_4), .-_(__atomic_compare_exchange_4)
 
 /* ---------------------------------------------- */
-#if defined __aarch64__
-        .text
-
-        .global _(__atomic_load_1)
-        .type   _(__atomic_load_1), %function
-_(__atomic_load_1):
-#ifdef __TINYC__
-        .int 0x35000081
-        .int 0x39400000
-        .int 0x12001c00
-        .int 0xd65f03c0
-        .int 0x08dffc00
-        .int 0x12001c00
-        .int 0xd65f03c0
-#else
-        cbnz    w1,  .L___atomic_load_1_010
-        ldrb    w0, [x0]
-        and w0, w0, #0xff
-        ret
-.L___atomic_load_1_010:
-        ldarb   w0, [x0]
-        and w0, w0, #0xff
-        ret
-	.size   _(__atomic_load_1), .-_(__atomic_load_1)
-
-#endif
-        .global _(__atomic_load_2)
-        .type   _(__atomic_load_2), %function
-_(__atomic_load_2):
-#ifdef __TINYC__
-        .int 0x35000081
-        .int 0x79400000
-        .int 0x12003c00
-        .int 0xd65f03c0
-        .int 0x48dffc00
-        .int 0x12003c00
-        .int 0xd65f03c0
-#else
-        cbnz    w1,  .L___atomic_load_2_010
-        ldrh    w0, [x0]
-        and w0, w0, #0xffff
-        ret
-.L___atomic_load_2_010:
-        ldarh   w0, [x0]
-        and w0, w0, #0xffff
-        ret
-	.size   _(__atomic_load_2), .-_(__atomic_load_2)
-
-#endif
-        .global _(__atomic_load_4)
-        .type   _(__atomic_load_4), %function
-_(__atomic_load_4):
-#ifdef __TINYC__
-        .int 0x35000061
-        .int 0xb9400000
-        .int 0xd65f03c0
-        .int 0x88dffc00
-        .int 0xd65f03c0
-#else
-        cbnz    w1,  .L___atomic_load_4_00c
-        ldr w0, [x0]
-        ret
-.L___atomic_load_4_00c:
-        ldar    w0, [x0]
-        ret
-	.size   _(__atomic_load_4), .-_(__atomic_load_4)
-
-#endif
-        .global _(__atomic_load_8)
-        .type   _(__atomic_load_8), %function
-_(__atomic_load_8):
-#ifdef __TINYC__
-        .int 0x35000061
-        .int 0xf9400000
-        .int 0xd65f03c0
-        .int 0xc8dffc00
-        .int 0xd65f03c0
-#else
-        cbnz    w1,  .L___atomic_load_8_00c
-        ldr x0, [x0]
-        ret
-.L___atomic_load_8_00c:
-        ldar    x0, [x0]
-        ret
-	.size   _(__atomic_load_8), .-_(__atomic_load_8)
+#elif defined __aarch64__
 
-#endif
-        .global _(__atomic_store_1)
-        .type   _(__atomic_store_1), %function
-_(__atomic_store_1):
-#ifdef __TINYC__
-        .int 0x12001c21
-        .int 0x35000062
-        .int 0x39000001
-        .int 0xd65f03c0
-        .int 0x089ffc01
-        .int 0xd65f03c0
-#else
-        and w1, w1, #0xff
-        cbnz    w2,  .L___atomic_store_1_010
-        strb    w1, [x0]
-        ret
-.L___atomic_store_1_010:
-        stlrb   w1, [x0]
-        ret
-	.size   _(__atomic_store_1), .-_(__atomic_store_1)
+        .text
+        .align  2
 
-#endif
-        .global _(__atomic_store_2)
-        .type   _(__atomic_store_2), %function
-_(__atomic_store_2):
-#ifdef __TINYC__
-        .int 0x12003c21
-        .int 0x35000062
-        .int 0x79000001
-        .int 0xd65f03c0
-        .int 0x489ffc01
+        .global _(fetch_and_add_arm64)
+        .type   _(fetch_and_add_arm64), %function
+_(fetch_and_add_arm64):
+#ifdef __TINYC__
+        .int 0x885f7c02
+        .int 0x0b010042
+        .int 0x8803fc02
+        .int 0x35ffffa3
+        .int 0xd5033bbf
         .int 0xd65f03c0
 #else
-        and w1, w1, #0xffff
-        cbnz    w2,  .L___atomic_store_2_010
-        strh    w1, [x0]
-        ret
-.L___atomic_store_2_010:
-        stlrh   w1, [x0]
-        ret
-	.size   _(__atomic_store_2), .-_(__atomic_store_2)
-
-#endif
-        .global _(__atomic_store_4)
-        .type   _(__atomic_store_4), %function
-_(__atomic_store_4):
+        ldxr    w2, [x0]
+        add     w2, w2, w1
+        stlxr   w3, w2, [x0]
+        cbnz    w3, _(fetch_and_add_arm64)
+        dmb     ish
+        ret
+#endif
+        .size   _(fetch_and_add_arm64), .-_(fetch_and_add_arm64)
+
+        .global _(__atomic_test_and_set)
+        .type   _(__atomic_test_and_set), %function
+_(__atomic_test_and_set):
+#ifdef __TINYC__
+	.int	0xa9bf7bfd
+	.int	0xaa0003e1
+	.int	0x52800020
+	.int	0x910003fd
+	.int	0x2a0003f0
+	.int	0x085ffc20
+	.int	0x0811fc30
+	.int	0x35ffffd1
+	.int	0xa8c17bfd
+	.int	0xd65f03c0
+#else
+         stp     x29, x30, [sp, -16]!
+         mov     x1, x0
+         mov     w0, 1
+         mov     x29, sp
+         mov     w16, w0
+.L20:
+         ldaxrb  w0, [x1]
+         stlxrb  w17, w16, [x1]
+         cbnz    w17, .L20
+         ldp     x29, x30, [sp], 16
+	 ret
+#endif
+	.size   _(__atomic_test_and_set), .-_(__atomic_test_and_set)
+
+        .global _(__atomic_clear)
+        .type   _(__atomic_clear), %function
+_(__atomic_clear):
 #ifdef __TINYC__
-        .int 0x35000062
-        .int 0xb9000001
-        .int 0xd65f03c0
-        .int 0x889ffc01
-        .int 0xd65f03c0
+	.int	0x089ffc1f
+	.int	0xd65f03c0
 #else
-        cbnz    w2,  .L___atomic_store_4_00c
-        str w1, [x0]
-        ret
-.L___atomic_store_4_00c:
-        stlr    w1, [x0]
+         stlrb   wzr, [x0]
         ret
-	.size   _(__atomic_store_4), .-_(__atomic_store_4)
-
 #endif
-        .global _(__atomic_store_8)
-        .type   _(__atomic_store_8), %function
-_(__atomic_store_8):
-#ifdef __TINYC__
-        .int 0x35000062
-        .int 0xf9000001
-        .int 0xd65f03c0
-        .int 0xc89ffc01
-        .int 0xd65f03c0
-#else
-        cbnz    w2,  .L___atomic_store_8_00c
-        str x1, [x0]
-        ret
-.L___atomic_store_8_00c:
-        stlr    x1, [x0]
-        ret
-	.size   _(__atomic_store_8), .-_(__atomic_store_8)
+	.size   _(__atomic_clear), .-_(__atomic_clear)
 
-#endif
         .global _(__atomic_compare_exchange_1)
         .type   _(__atomic_compare_exchange_1), %function
 _(__atomic_compare_exchange_1):
 #ifdef __TINYC__
-        .int 0x12001c42
-        .int 0x35000143
-        .int 0x39400023
-        .int 0x085f7c04
-        .int 0x6b23009f
-        .int 0x54000061
-        .int 0x08057c02
-        .int 0x35ffff85
-        .int 0x1a9f17e0
-        .int 0x54000141
-        .int 0xd65f03c0
-        .int 0x39400023
-        .int 0x085ffc04
-        .int 0x6b23009f
-        .int 0x54000061
-        .int 0x0805fc02
-        .int 0x35ffff85
-        .int 0x1a9f17e0
-        .int 0x54ffff00
-        .int 0x39000024
-        .int 0xd65f03c0
-#else
-        and w2, w2, #0xff
-        cbnz    w3,  .L___atomic_compare_exchange_1_02c
-        ldrb    w3, [x1]
-.L___atomic_compare_exchange_1_00c:
-        ldxrb   w4, [x0]
-        cmp w4, w3, uxtb
-        b.ne     .L___atomic_compare_exchange_1_020
-        stxrb   w5, w2, [x0]
-        cbnz    w5,  .L___atomic_compare_exchange_1_00c
-.L___atomic_compare_exchange_1_020:
-        cset    w0, eq  // eq = none
-        b.ne     .L___atomic_compare_exchange_1_04c
-.L___atomic_compare_exchange_1_028:
-        ret
-.L___atomic_compare_exchange_1_02c:
-        ldrb    w3, [x1]
-.L___atomic_compare_exchange_1_030:
-        ldaxrb  w4, [x0]
-        cmp w4, w3, uxtb
-        b.ne     .L___atomic_compare_exchange_1_044
-        stlxrb  w5, w2, [x0]
-        cbnz    w5,  .L___atomic_compare_exchange_1_030
-.L___atomic_compare_exchange_1_044:
-        cset    w0, eq  // eq = none
-        b.eq     .L___atomic_compare_exchange_1_028
-.L___atomic_compare_exchange_1_04c:
-        strb    w4, [x1]
+	.int	0xa9be7bfd
+	.int	0x910003fd
+	.int	0xa90153f3
+	.int	0xaa0103f3
+	.int	0x12001c41
+	.int	0xaa0003e2
+	.int	0x39400274
+	.int	0x2a1403e0
+	.int	0x53001c10
+	.int	0x085ffc40
+	.int	0x6b10001f
+	.int	0x54000061
+	.int	0x0811fc41
+	.int	0x35ffff91
+	.int	0x6b34001f
+	.int	0x1a9f17e1
+	.int	0x54000040
+	.int	0x39000260
+	.int	0x2a0103e0
+	.int	0xa94153f3
+	.int	0xa8c27bfd
+	.int	0xd65f03c0
+#else
+        stp     x29, x30, [sp, -32]!
+        mov     x29, sp
+        stp     x19, x20, [sp, 16]
+        mov     x19, x1
+        and     w1, w2, 255
+        mov     x2, x0
+        ldrb    w20, [x19]
+        mov     w0, w20
+	uxtb    w16, w0
+.L1:
+	ldaxrb  w0, [x2]
+	cmp     w0, w16
+	b.ne    .L2
+	stlxrb  w17, w1, [x2]
+	cbnz    w17, .L1
+.L2:
+        cmp     w0, w20, uxtb
+        cset    w1, eq
+        beq     .L3
+        strb    w0, [x19]
+.L3:
+        mov     w0, w1
+        ldp     x19, x20, [sp, 16]
+        ldp     x29, x30, [sp], 32
         ret
-	.size   _(__atomic_compare_exchange_1), .-_(__atomic_compare_exchange_1)
-
 #endif
+        .size   _(__atomic_compare_exchange_1), .-_(__atomic_compare_exchange_1)
+
         .global _(__atomic_compare_exchange_2)
         .type   _(__atomic_compare_exchange_2), %function
 _(__atomic_compare_exchange_2):
 #ifdef __TINYC__
-        .int 0x12003c42
-        .int 0x35000143
-        .int 0x79400023
-        .int 0x485f7c04
-        .int 0x6b23209f
-        .int 0x54000061
-        .int 0x48057c02
-        .int 0x35ffff85
-        .int 0x1a9f17e0
-        .int 0x54000141
-        .int 0xd65f03c0
-        .int 0x79400023
-        .int 0x485ffc04
-        .int 0x6b23209f
-        .int 0x54000061
-        .int 0x4805fc02
-        .int 0x35ffff85
-        .int 0x1a9f17e0
-        .int 0x54ffff00
-        .int 0x79000024
-        .int 0xd65f03c0
-#else
-        and w2, w2, #0xffff
-        cbnz    w3,  .L___atomic_compare_exchange_2_02c
-        ldrh    w3, [x1]
-.L___atomic_compare_exchange_2_00c:
-        ldxrh   w4, [x0]
-        cmp w4, w3, uxth
-        b.ne     .L___atomic_compare_exchange_2_020
-        stxrh   w5, w2, [x0]
-        cbnz    w5,  .L___atomic_compare_exchange_2_00c
-.L___atomic_compare_exchange_2_020:
-        cset    w0, eq  // eq = none
-        b.ne     .L___atomic_compare_exchange_2_04c
-.L___atomic_compare_exchange_2_028:
-        ret
-.L___atomic_compare_exchange_2_02c:
-        ldrh    w3, [x1]
-.L___atomic_compare_exchange_2_030:
-        ldaxrh  w4, [x0]
-        cmp w4, w3, uxth
-        b.ne     .L___atomic_compare_exchange_2_044
-        stlxrh  w5, w2, [x0]
-        cbnz    w5,  .L___atomic_compare_exchange_2_030
-.L___atomic_compare_exchange_2_044:
-        cset    w0, eq  // eq = none
-        b.eq     .L___atomic_compare_exchange_2_028
-.L___atomic_compare_exchange_2_04c:
-        strh    w4, [x1]
+	.int	0xa9be7bfd
+	.int	0x910003fd
+	.int	0xa90153f3
+	.int	0xaa0103f3
+	.int	0x12003c41
+	.int	0xaa0003e2
+	.int	0x79400274
+	.int	0x2a1403e0
+	.int	0x53003c10
+	.int	0x485ffc40
+	.int	0x6b10001f
+	.int	0x54000061
+	.int	0x4811fc41
+	.int	0x35ffff91
+	.int	0x6b34201f
+	.int	0x1a9f17e1
+	.int	0x54000040
+	.int	0x79000260
+	.int	0x2a0103e0
+	.int	0xa94153f3
+	.int	0xa8c27bfd
+	.int	0xd65f03c0
+#else
+        stp     x29, x30, [sp, -32]!
+        mov     x29, sp
+        stp     x19, x20, [sp, 16]
+        mov     x19, x1
+        and     w1, w2, 65535
+        mov     x2, x0
+        ldrh    w20, [x19]
+        mov     w0, w20
+	uxth    w16, w0
+.L4:
+	ldaxrh  w0, [x2]
+	cmp     w0, w16
+	b.ne    .L5
+	stlxrh  w17, w1, [x2]
+	cbnz    w17, .L4
+.L5:
+        cmp     w0, w20, uxth
+        cset    w1, eq
+        beq     .L6
+        strh    w0, [x19]
+.L6:
+        mov     w0, w1
+        ldp     x19, x20, [sp, 16]
+        ldp     x29, x30, [sp], 32
         ret
-	.size   _(__atomic_compare_exchange_2), .-_(__atomic_compare_exchange_2)
-
 #endif
+        .size   _(__atomic_compare_exchange_2), .-_(__atomic_compare_exchange_2)
+
         .global _(__atomic_compare_exchange_4)
         .type   _(__atomic_compare_exchange_4), %function
 _(__atomic_compare_exchange_4):
 #ifdef __TINYC__
-        .int 0x35000143
-        .int 0xb9400023
-        .int 0x885f7c04
-        .int 0x6b03009f
-        .int 0x54000061
-        .int 0x88057c02
-        .int 0x35ffff85
-        .int 0x1a9f17e0
-        .int 0x54000141
-        .int 0xd65f03c0
-        .int 0xb9400023
-        .int 0x885ffc04
-        .int 0x6b03009f
-        .int 0x54000061
-        .int 0x8805fc02
-        .int 0x35ffff85
-        .int 0x1a9f17e0
-        .int 0x54ffff00
-        .int 0xb9000024
-        .int 0xd65f03c0
-#else
-        cbnz    w3,  .L___atomic_compare_exchange_4_028
-        ldr w3, [x1]
-.L___atomic_compare_exchange_4_008:
-        ldxr    w4, [x0]
-        cmp w4, w3
-        b.ne     .L___atomic_compare_exchange_4_01c
-        stxr    w5, w2, [x0]
-        cbnz    w5,  .L___atomic_compare_exchange_4_008
-.L___atomic_compare_exchange_4_01c:
-        cset    w0, eq  // eq = none
-        b.ne     .L___atomic_compare_exchange_4_048
-.L___atomic_compare_exchange_4_024:
-        ret
-.L___atomic_compare_exchange_4_028:
-        ldr w3, [x1]
-.L___atomic_compare_exchange_4_02c:
-        ldaxr   w4, [x0]
-        cmp w4, w3
-        b.ne     .L___atomic_compare_exchange_4_040
-        stlxr   w5, w2, [x0]
-        cbnz    w5,  .L___atomic_compare_exchange_4_02c
-.L___atomic_compare_exchange_4_040:
-        cset    w0, eq  // eq = none
-        b.eq     .L___atomic_compare_exchange_4_024
-.L___atomic_compare_exchange_4_048:
-        str w4, [x1]
+	.int	0xa9be7bfd
+	.int	0x910003fd
+	.int	0xa90153f3
+	.int	0xaa0103f3
+	.int	0x2a0203e1
+	.int	0xaa0003e2
+	.int	0xb9400274
+	.int	0x2a1403e0
+	.int	0x2a0003f0
+	.int	0x885ffc40
+	.int	0x6b10001f
+	.int	0x54000061
+	.int	0x8811fc41
+	.int	0x35ffff91
+	.int	0x6b14001f
+	.int	0x1a9f17e1
+	.int	0x54000040
+	.int	0xb9000260
+	.int	0x2a0103e0
+	.int	0xa94153f3
+	.int	0xa8c27bfd
+	.int	0xd65f03c0
+#else
+        stp     x29, x30, [sp, -32]!
+        mov     x29, sp
+        stp     x19, x20, [sp, 16]
+        mov     x19, x1
+        mov     w1, w2
+        mov     x2, x0
+        ldr     w20, [x19]
+        mov     w0, w20
+	mov     w16, w0
+.L7:
+	ldaxr   w0, [x2]
+	cmp     w0, w16
+	b.ne    .L8
+	stlxr   w17, w1, [x2]
+	cbnz    w17, .L7
+.L8:
+        cmp     w0, w20
+        cset    w1, eq
+        beq     .L9
+        str     w0, [x19]
+.L9:
+        mov     w0, w1
+        ldp     x19, x20, [sp, 16]
+        ldp     x29, x30, [sp], 32
         ret
-	.size   _(__atomic_compare_exchange_4), .-_(__atomic_compare_exchange_4)
-
 #endif
+        .size   _(__atomic_compare_exchange_4), .-_(__atomic_compare_exchange_4)
+
         .global _(__atomic_compare_exchange_8)
         .type   _(__atomic_compare_exchange_8), %function
 _(__atomic_compare_exchange_8):
 #ifdef __TINYC__
-        .int 0x35000143
-        .int 0xf9400023
-        .int 0xc85f7c04
-        .int 0xeb03009f
-        .int 0x54000061
-        .int 0xc8057c02
-        .int 0x35ffff85
-        .int 0x1a9f17e0
-        .int 0x54000141
-        .int 0xd65f03c0
-        .int 0xf9400023
-        .int 0xc85ffc04
-        .int 0xeb03009f
-        .int 0x54000061
-        .int 0xc805fc02
-        .int 0x35ffff85
-        .int 0x1a9f17e0
-        .int 0x54ffff00
-        .int 0xf9000024
-        .int 0xd65f03c0
-#else
-        cbnz    w3,  .L___atomic_compare_exchange_8_028
-        ldr x3, [x1]
-.L___atomic_compare_exchange_8_008:
-        ldxr    x4, [x0]
-        cmp x4, x3
-        b.ne     .L___atomic_compare_exchange_8_01c
-        stxr    w5, x2, [x0]
-        cbnz    w5,  .L___atomic_compare_exchange_8_008
-.L___atomic_compare_exchange_8_01c:
-        cset    w0, eq  // eq = none
-        b.ne     .L___atomic_compare_exchange_8_048
-.L___atomic_compare_exchange_8_024:
+	.int	0xa9be7bfd
+	.int	0x910003fd
+	.int	0xa90153f3
+	.int	0xaa0103f3
+	.int	0xaa0203e1
+	.int	0xaa0003e2
+	.int	0xf9400274
+	.int	0xaa1403e0
+	.int	0xaa0003f0
+	.int	0xc85ffc40
+	.int	0xeb10001f
+	.int	0x54000061
+	.int	0xc811fc41
+	.int	0x35ffff91
+	.int	0xeb14001f
+	.int	0x1a9f17e1
+	.int	0x54000040
+	.int	0xf9000260
+	.int	0x2a0103e0
+	.int	0xa94153f3
+	.int	0xa8c27bfd
+	.int	0xd65f03c0
+#else
+        stp     x29, x30, [sp, -32]!
+        mov     x29, sp
+        stp     x19, x20, [sp, 16]
+        mov     x19, x1
+        mov     x1, x2
+        mov     x2, x0
+        ldr     x20, [x19]
+        mov     x0, x20
+	mov     x16, x0
+.L10:
+	ldaxr   x0, [x2]
+	cmp     x0, x16
+	b.ne    .L11
+	stlxr   w17, x1, [x2]
+	cbnz    w17, .L10
+.L11:
+        cmp     x0, x20
+        cset    w1, eq
+        beq     .L12
+        str     x0, [x19]
+.L12:
+        mov     w0, w1
+        ldp     x19, x20, [sp, 16]
+        ldp     x29, x30, [sp], 32
         ret
-.L___atomic_compare_exchange_8_028:
-        ldr x3, [x1]
-.L___atomic_compare_exchange_8_02c:
-        ldaxr   x4, [x0]
-        cmp x4, x3
-        b.ne     .L___atomic_compare_exchange_8_040
-        stlxr   w5, x2, [x0]
-        cbnz    w5,  .L___atomic_compare_exchange_8_02c
-.L___atomic_compare_exchange_8_040:
-        cset    w0, eq  // eq = none
-        b.eq     .L___atomic_compare_exchange_8_024
-.L___atomic_compare_exchange_8_048:
-        str x4, [x1]
-        ret
-	.size   _(__atomic_compare_exchange_8), .-_(__atomic_compare_exchange_8)
-
 #endif
-        .global _(__atomic_test_and_set_1)
-        .type   _(__atomic_test_and_set_1), %function
-_(__atomic_test_and_set_1):
-#ifdef __TINYC__
-        .int 0x52800022
-        .int 0x350000c1
-        .int 0x085f7c01
-        .int 0x08037c02
-        .int 0x35ffffc3
-        .int 0x12001c20
-        .int 0xd65f03c0
-        .int 0x085ffc01
-        .int 0x0803fc02
-        .int 0x35ffffc3
-        .int 0x12001c20
-        .int 0xd65f03c0
-#else
-        mov w2, #0x1                    // #1
-        cbnz    w1,  .L___atomic_test_and_set_1_01c
-.L___atomic_test_and_set_1_008:
-        ldxrb   w1, [x0]
-        stxrb   w3, w2, [x0]
-        cbnz    w3,  .L___atomic_test_and_set_1_008
-        and w0, w1, #0xff
-        ret
-.L___atomic_test_and_set_1_01c:
-        ldaxrb  w1, [x0]
-        stlxrb  w3, w2, [x0]
-        cbnz    w3,  .L___atomic_test_and_set_1_01c
-        and w0, w1, #0xff
-        ret
-	.size   _(__atomic_test_and_set_1), .-_(__atomic_test_and_set_1)
-
-#endif
-        .global _(__atomic_test_and_set_2)
-        .type   _(__atomic_test_and_set_2), %function
-_(__atomic_test_and_set_2):
-#ifdef __TINYC__
-        .int 0x52800022
-        .int 0x350000c1
-        .int 0x085f7c01
-        .int 0x08037c02
-        .int 0x35ffffc3
-        .int 0x12001c20
-        .int 0xd65f03c0
-        .int 0x085ffc01
-        .int 0x0803fc02
-        .int 0x35ffffc3
-        .int 0x12001c20
-        .int 0xd65f03c0
-#else
-        mov w2, #0x1                    // #1
-        cbnz    w1,  .L___atomic_test_and_set_2_01c
-.L___atomic_test_and_set_2_008:
-        ldxrb   w1, [x0]
-        stxrb   w3, w2, [x0]
-        cbnz    w3,  .L___atomic_test_and_set_2_008
-        and w0, w1, #0xff
-        ret
-.L___atomic_test_and_set_2_01c:
-        ldaxrb  w1, [x0]
-        stlxrb  w3, w2, [x0]
-        cbnz    w3,  .L___atomic_test_and_set_2_01c
-        and w0, w1, #0xff
-        ret
-	.size   _(__atomic_test_and_set_2), .-_(__atomic_test_and_set_2)
-
-#endif
-        .global _(__atomic_test_and_set_4)
-        .type   _(__atomic_test_and_set_4), %function
-_(__atomic_test_and_set_4):
-#ifdef __TINYC__
-        .int 0x52800022
-        .int 0x350000c1
-        .int 0x085f7c01
-        .int 0x08037c02
-        .int 0x35ffffc3
-        .int 0x12001c20
-        .int 0xd65f03c0
-        .int 0x085ffc01
-        .int 0x0803fc02
-        .int 0x35ffffc3
-        .int 0x12001c20
-        .int 0xd65f03c0
-#else
-        mov w2, #0x1                    // #1
-        cbnz    w1,  .L___atomic_test_and_set_4_01c
-.L___atomic_test_and_set_4_008:
-        ldxrb   w1, [x0]
-        stxrb   w3, w2, [x0]
-        cbnz    w3,  .L___atomic_test_and_set_4_008
-        and w0, w1, #0xff
-        ret
-.L___atomic_test_and_set_4_01c:
-        ldaxrb  w1, [x0]
-        stlxrb  w3, w2, [x0]
-        cbnz    w3,  .L___atomic_test_and_set_4_01c
-        and w0, w1, #0xff
-        ret
-	.size   _(__atomic_test_and_set_4), .-_(__atomic_test_and_set_4)
-
-#endif
-        .global _(__atomic_test_and_set_8)
-        .type   _(__atomic_test_and_set_8), %function
-_(__atomic_test_and_set_8):
-#ifdef __TINYC__
-        .int 0x52800022
-        .int 0x350000c1
-        .int 0x085f7c01
-        .int 0x08037c02
-        .int 0x35ffffc3
-        .int 0x12001c20
-        .int 0xd65f03c0
-        .int 0x085ffc01
-        .int 0x0803fc02
-        .int 0x35ffffc3
-        .int 0x12001c20
-        .int 0xd65f03c0
-#else
-        mov w2, #0x1                    // #1
-        cbnz    w1,  .L___atomic_test_and_set_8_01c
-.L___atomic_test_and_set_8_008:
-        ldxrb   w1, [x0]
-        stxrb   w3, w2, [x0]
-        cbnz    w3,  .L___atomic_test_and_set_8_008
-        and w0, w1, #0xff
-        ret
-.L___atomic_test_and_set_8_01c:
-        ldaxrb  w1, [x0]
-        stlxrb  w3, w2, [x0]
-        cbnz    w3,  .L___atomic_test_and_set_8_01c
-        and w0, w1, #0xff
-        ret
-	.size   _(__atomic_test_and_set_8), .-_(__atomic_test_and_set_8)
-
-#endif
-        .global _(atomic_thread_fence)
-        .type   _(atomic_thread_fence), %function
-_(atomic_thread_fence):
-#ifdef __TINYC__
-        .int 0xd5033bbf
-        .int 0xd65f03c0
-#else
-        dmb ish
-        ret
-	.size   _(atomic_thread_fence), .-_(atomic_thread_fence)
-
-#endif
-        .global _(atomic_signal_fence)
-        .type   _(atomic_signal_fence), %function
-_(atomic_signal_fence):
-#ifdef __TINYC__
-        .int 0xd65f03c0
-#else
-        ret
-	.size   _(atomic_signal_fence), .-_(atomic_signal_fence)
-
-#endif
-        .global _(atomic_flag_test_and_set)
-        .type   _(atomic_flag_test_and_set), %function
-_(atomic_flag_test_and_set):
-#ifdef __TINYC__
-        .int 0xaa0003e1
-        .int 0x52800022
-        .int 0x085ffc20
-        .int 0x0803fc22
-        .int 0x35ffffc3
-        .int 0xd65f03c0
-#else
-        mov x1, x0
-        mov w2, #0x1                    // #1
-.L_atomic_flag_test_and_set_008:
-        ldaxrb  w0, [x1]
-        stlxrb  w3, w2, [x1]
-        cbnz    w3,  .L_atomic_flag_test_and_set_008
-        ret
-	.size   _(atomic_flag_test_and_set), .-_(atomic_flag_test_and_set)
-
-#endif
-        .global _(atomic_flag_test_and_set_explicit)
-        .type   _(atomic_flag_test_and_set_explicit), %function
-_(atomic_flag_test_and_set_explicit):
-#ifdef __TINYC__
-        .int 0xaa0003e1
-        .int 0x52800022
-        .int 0x085ffc20
-        .int 0x0803fc22
-        .int 0x35ffffc3
-        .int 0xd65f03c0
-#else
-        mov x1, x0
-        mov w2, #0x1                    // #1
-.L_atomic_flag_test_and_set_explicit_020:
-        ldaxrb  w0, [x1]
-        stlxrb  w3, w2, [x1]
-        cbnz    w3,  .L_atomic_flag_test_and_set_explicit_020
-        ret
-	.size   _(atomic_flag_test_and_set_explicit), .-_(atomic_flag_test_and_set_explicit)
-
-#endif
-        .global _(atomic_flag_clear)
-        .type   _(atomic_flag_clear), %function
-_(atomic_flag_clear):
-#ifdef __TINYC__
-        .int 0x089ffc1f
-        .int 0xd65f03c0
-#else
-        stlrb   wzr, [x0]
-        ret
-	.size   _(atomic_flag_clear), .-_(atomic_flag_clear)
-
-#endif
-        .global _(atomic_flag_clear_explicit)
-        .type   _(atomic_flag_clear_explicit), %function
-_(atomic_flag_clear_explicit):
-#ifdef __TINYC__
-        .int 0x089ffc1f
-        .int 0xd65f03c0
-#else
-        stlrb   wzr, [x0]
-        ret
-	.size   _(atomic_flag_clear_explicit), .-_(atomic_flag_clear_explicit)
-
-#endif
-#endif //__aarch64__
+        .size   _(__atomic_compare_exchange_8), .-_(__atomic_compare_exchange_8)
 
 /* ---------------------------------------------- */
-#if defined __riscv
+#elif defined __riscv
+
         .text
+        .align  2
 
-        .global _(__atomic_load_1)
-        .type   _(__atomic_load_1), %function
-_(__atomic_load_1):
+        .global _(fetch_and_add_riscv64)
+        .type   _(fetch_and_add_riscv64), %function
+_(fetch_and_add_riscv64):
 #ifdef __TINYC__
-        .int 0x0330000f
-        .int 0x00054503
-        .int 0x0330000f
+        .int   0x0f50000f
+        .int   0x004b5202f
         .short 0x8082
 #else
-        fence   rw,rw
-        lbu a0,0(a0)
-        fence   rw,rw
+        fence iorw,ow
+        amoadd.w.aq zero,a1,0(a0)
         ret
-	.size   _(__atomic_load_1), .-_(__atomic_load_1)
-
 #endif
-        .global _(__atomic_load_2)
-        .type   _(__atomic_load_2), %function
-_(__atomic_load_2):
-#ifdef __TINYC__
-        .int 0x0330000f
-        .int 0x00055503
-        .int 0x0330000f
-        .short 0x8082
-#else
-        fence   rw,rw
-        lhu a0,0(a0)
-        fence   rw,rw
-        ret
-	.size   _(__atomic_load_2), .-_(__atomic_load_2)
+        .size   _(fetch_and_add_riscv64), .-_(fetch_and_add_riscv64)
 
-#endif
-        .global _(__atomic_load_4)
-        .type   _(__atomic_load_4), %function
-_(__atomic_load_4):
+        .global _(__atomic_test_and_set)
+        .type   _(__atomic_test_and_set), %function
+_(__atomic_test_and_set):
 #ifdef __TINYC__
-        .int 0x0330000f
-        .short 0x4108
-        .int 0x0230000f
-        .short 0x2501
-        .short 0x8082
+	.int	0x00357793
+	.int	0x0037979b
+	.short	0x4685
+	.short	0x9971
+	.int	0x00f696bb
+	.int	0x0f50000f
+	.int	0x44d5272f
+	.int	0x00f7553b
+	.int	0x0ff57513
+	.short	0x8082
 #else
-        fence   rw,rw
-        lw  a0,0(a0)
-        fence   r,rw
-        sext.w  a0,a0
+        andi    a5,a0,3
+        slliw   a5,a5,3
+        li      a3,1
+        andi    a0,a0,-4
+        sllw    a3,a3,a5
+        fence iorw,ow; amoor.w.aq a4,a3,0(a0)
+        srlw    a0,a4,a5
+        andi    a0,a0,0xff
         ret
-	.size   _(__atomic_load_4), .-_(__atomic_load_4)
-
 #endif
-        .global _(__atomic_load_8)
-        .type   _(__atomic_load_8), %function
-_(__atomic_load_8):
-#ifdef __TINYC__
-        .int 0x0330000f
-        .short 0x6108
-        .int 0x0230000f
-        .short 0x8082
-#else
-        fence   rw,rw
-        ld  a0,0(a0)
-        fence   r,rw
-        ret
-	.size   _(__atomic_load_8), .-_(__atomic_load_8)
+	.size   _(__atomic_test_and_set), .-_(__atomic_test_and_set)
 
-#endif
-        .global _(__atomic_store_1)
-        .type   _(__atomic_store_1), %function
-_(__atomic_store_1):
+        .global _(__atomic_clear)
+        .type   _(__atomic_clear), %function
+_(__atomic_clear):
 #ifdef __TINYC__
-        .int 0x0330000f
-        .int 0x00b50023
-        .int 0x0330000f
-        .short 0x8082
+	.int	0x0ff0000f
+	.int	0x00050023
+	.int	0x0ff0000f
+	.short	0x8082
 #else
-        fence   rw,rw
-        sb  a1,0(a0)
-        fence   rw,rw
+        fence   iorw,iorw
+        sb      zero,0(a0)
+        fence   iorw,iorw
         ret
-	.size   _(__atomic_store_1), .-_(__atomic_store_1)
-
 #endif
-        .global _(__atomic_store_2)
-        .type   _(__atomic_store_2), %function
-_(__atomic_store_2):
-#ifdef __TINYC__
-        .int 0x0330000f
-        .int 0x00b51023
-        .int 0x0330000f
-        .short 0x8082
-#else
-        fence   rw,rw
-        sh  a1,0(a0)
-        fence   rw,rw
-        ret
-	.size   _(__atomic_store_2), .-_(__atomic_store_2)
+	.size   _(__atomic_clear), .-_(__atomic_clear)
 
-#endif
-        .global _(__atomic_store_4)
-        .type   _(__atomic_store_4), %function
-_(__atomic_store_4):
-#ifdef __TINYC__
-        .int 0x0310000f
-        .short 0xc10c
-        .int 0x0330000f
-        .short 0x8082
-#else
-        fence   rw,w
-        sw  a1,0(a0)
-        fence   rw,rw
-        ret
-	.size   _(__atomic_store_4), .-_(__atomic_store_4)
-
-#endif
-        .global _(__atomic_store_8)
-        .type   _(__atomic_store_8), %function
-_(__atomic_store_8):
-#ifdef __TINYC__
-        .int 0x0310000f
-        .short 0xe10c
-        .int 0x0330000f
-        .short 0x8082
-#else
-        fence   rw,w
-        sd  a1,0(a0)
-        fence   rw,rw
-        ret
-	.size   _(__atomic_store_8), .-_(__atomic_store_8)
-
-#endif
         .global _(__atomic_compare_exchange_1)
         .type   _(__atomic_compare_exchange_1), %function
 _(__atomic_compare_exchange_1):
 #ifdef __TINYC__
-        .int 0x0005c683
-        .int 0x00357793
-        .int 0x0037979b
-        .int 0x0ff00713
-        .int 0x00f7173b
-        .int 0x00f698bb
-        .int 0x00f6163b
-        .short 0x9971
-        .int 0xfff74313
-        .int 0x00e8f8b3
-        .short 0x8e79
-        .int 0x1605282f
-        .int 0x00e87e33
-        .int 0x011e1a63
-        .int 0x00687e33
-        .int 0x00ce6e33
-        .int 0x1bc52e2f
-        .int 0xfe0e14e3
-        .int 0x40f8583b
-        .int 0x0188179b
-        .int 0x0186969b
-        .int 0x4187d79b
-        .int 0x4186d69b
-        .short 0x9f95
-        .int 0x0017b513
-        .short 0xc399
-        .int 0x01058023
-        .short 0x8905
-        .short 0x8082
-#else
-        lbu a3,0(a1)
-        andi    a5,a0,3
-        slliw   a5,a5,0x3
-        li  a4,255
-        sllw    a4,a4,a5
-        sllw    a7,a3,a5
-        sllw    a2,a2,a5
-        andi    a0,a0,-4
-        not t1,a4
-        and a7,a7,a4
-        and a2,a2,a4
-.L___atomic_compare_exchange_1_028:
-        lr.w.aqrl   a6,(a0)
-        and t3,a6,a4
-        bne t3,a7, .L___atomic_compare_exchange_1_044
-        and t3,a6,t1
-        or  t3,t3,a2
-        sc.w.rl t3,t3,(a0)
-        bnez    t3, .L___atomic_compare_exchange_1_028
-.L___atomic_compare_exchange_1_044:
-        sraw    a6,a6,a5
-        slliw   a5,a6,0x18
-        slliw   a3,a3,0x18
-        sraiw   a5,a5,0x18
-        sraiw   a3,a3,0x18
-        subw    a5,a5,a3
-        seqz    a0,a5
-        beqz    a5, .L___atomic_compare_exchange_1_064
-        sb  a6,0(a1)
-.L___atomic_compare_exchange_1_064:
-        andi    a0,a0,1
-        ret
-	.size   _(__atomic_compare_exchange_1), .-_(__atomic_compare_exchange_1)
-
+	.short	0x1141
+	.short	0x86ba
+	.short	0x873e
+	.short	0xe406
+	.int	0x0ff0000f
+	.int	0x0005c803
+	.int	0xff857893
+	.int	0x0008b783
+	.short	0x891d
+	.short	0x050e
+	.int	0x0ff00693
+	.int	0x00a696b3
+	.int	0x00a81833
+	.int	0x00a61633
+	.int	0xfff6c713
+	.short	0x8f7d
+	.int	0x00f6f333
+	.short	0x8f51
+	.int	0x03031263
+	.int	0x1008b32f
+	.int	0x00f31663
+	.int	0x18e8be2f
+	.int	0xfe0e1ae3
+	.int	0x40f30733
+	.short	0x879a
+	.short	0xff69
+	.int	0x0ff0000f
+	.short	0x4505
+	.short	0xa801
+	.int	0x00a7d7b3
+	.int	0x00f58023
+	.int	0x0ff0000f
+	.short	0x4501
+	.short	0x60a2
+	.short	0x0141
+	.short	0x8082
+#else
+        addi    sp,sp,-16
+        mv      a3,a4
+        mv      a4,a5
+        sd      ra,8(sp)
+	fence
+	lbu     a6,0(a1)
+	andi    a7,a0,-8
+	ld      a5,0(a7)
+	andi    a0,a0,7
+	slli    a0,a0,0x3
+	li      a3,255
+	sll     a3,a3,a0
+	sll     a6,a6,a0
+	sll     a2,a2,a0
+.L1:
+	not     a4,a3
+	and     a4,a4,a5
+	and     t1,a3,a5
+	or      a4,a4,a2
+	bne     t1,a6,.L4
+.L2:
+	lr.d    t1,(a7)
+	bne     t1,a5,.L3
+	sc.d    t3,a4,(a7)
+	bnez    t3,.L2
+.L3:
+	sub     a4,t1,a5
+	mv      a5,t1
+	bnez    a4,.L1
+	fence
+	li      a0,1
+	j	.L5
+.L4:
+	srl     a5,a5,a0
+	sb      a5,0(a1)
+	fence
+	li      a0,0
+.L5:
+        ld      ra,8(sp)
+        addi    sp,sp,16
+        jr      ra
 #endif
+        .size   _(__atomic_compare_exchange_1), .-_(__atomic_compare_exchange_1)
+
         .global _(__atomic_compare_exchange_2)
         .type   _(__atomic_compare_exchange_2), %function
 _(__atomic_compare_exchange_2):
 #ifdef __TINYC__
-        .int 0x0005d683
-        .int 0x00357713
-        .short 0x67c1
-        .int 0x0037171b
-        .short 0x37fd
-        .int 0x00e797bb
-        .int 0x00e698bb
-        .int 0x00e6163b
-        .short 0x9971
-        .int 0xfff7c313
-        .int 0x00f8f8b3
-        .short 0x8e7d
-        .int 0x1605282f
-        .int 0x00f87e33
-        .int 0x011e1a63
-        .int 0x00687e33
-        .int 0x00ce6e33
-        .int 0x1bc52e2f
-        .int 0xfe0e14e3
-        .int 0x40e8583b
-        .int 0x0108179b
-        .int 0x0106969b
-        .int 0x4107d79b
-        .int 0x4106d69b
-        .short 0x9f95
-        .int 0x0017b513
-        .short 0xc399
-        .int 0x01059023
-        .short 0x8905
-        .short 0x8082
-#else
-        lhu a3,0(a1)
-        andi    a4,a0,3
-        lui a5,0x10
-        slliw   a4,a4,0x3
-        addiw   a5,a5,-1 # ffff <.LASF16+0xfec8>
-        sllw    a5,a5,a4
-        sllw    a7,a3,a4
-        sllw    a2,a2,a4
-        andi    a0,a0,-4
-        not t1,a5
-        and a7,a7,a5
-        and a2,a2,a5
-.L___atomic_compare_exchange_2_028:
-        lr.w.aqrl   a6,(a0)
-        and t3,a6,a5
-        bne t3,a7, .L___atomic_compare_exchange_2_044
-        and t3,a6,t1
-        or  t3,t3,a2
-        sc.w.rl t3,t3,(a0)
-        bnez    t3, .L___atomic_compare_exchange_2_028
-.L___atomic_compare_exchange_2_044:
-        sraw    a6,a6,a4
-        slliw   a5,a6,0x10
-        slliw   a3,a3,0x10
-        sraiw   a5,a5,0x10
-        sraiw   a3,a3,0x10
-        subw    a5,a5,a3
-        seqz    a0,a5
-        beqz    a5, .L___atomic_compare_exchange_2_064
-        sh  a6,0(a1)
-.L___atomic_compare_exchange_2_064:
-        andi    a0,a0,1
-        ret
-	.size   _(__atomic_compare_exchange_2), .-_(__atomic_compare_exchange_2)
-
+	.short	0x1141
+	.short	0x86ba
+	.short	0x873e
+	.short	0xe406
+	.int	0x0ff0000f
+	.int	0x0005d803
+	.int	0xff857893
+	.short	0x67c1
+	.short	0x891d
+	.int	0x0008b703
+	.short	0x050e
+	.short	0x17fd
+	.int	0x00a797b3
+	.int	0x00a81833
+	.int	0x00a61633
+	.int	0xfff7c693
+	.short	0x8ef9
+	.int	0x00e7f333
+	.short	0x8ed1
+	.int	0x03031263
+	.int	0x1008b32f
+	.int	0x00e31663
+	.int	0x18d8be2f
+	.int	0xfe0e1ae3
+	.int	0x40e306b3
+	.short	0x871a
+	.short	0xfee9
+	.int	0x0ff0000f
+	.short	0x4505
+	.short	0xa801
+	.int	0x00a75733
+	.int	0x00e59023
+	.int	0x0ff0000f
+	.short	0x4501
+	.short	0x60a2
+	.short	0x0141
+	.short	0x8082
+#else
+        addi    sp,sp,-16
+        mv      a3,a4
+        mv      a4,a5
+        sd      ra,8(sp)
+	fence
+	lhu     a6,0(a1)
+	andi    a7,a0,-8
+	lui     a5,0x10
+	andi    a0,a0,7
+	ld      a4,0(a7)
+	slli    a0,a0,0x3
+	addi    a5,a5,-1
+	sll     a5,a5,a0
+	sll     a6,a6,a0
+	sll     a2,a2,a0
+.L6:
+	not     a3,a5
+	and     a3,a3,a4
+	and     t1,a5,a4
+	or      a3,a3,a2
+	bne     t1,a6,.L9
+.L7:
+	lr.d    t1,(a7)
+	bne     t1,a4,.L8
+	sc.d    t3,a3,(a7)
+	bnez    t3,.L7
+.L8:
+	sub     a3,t1,a4
+	mv      a4,t1
+	bnez    a3,.L6
+	fence
+	li      a0,1
+	j	.L10
+.L9:
+	srl     a4,a4,a0
+	sh      a4,0(a1)
+	fence
+	li      a0,0
+.L10:
+        ld      ra,8(sp)
+        addi    sp,sp,16
+        jr      ra
 #endif
+        .size   _(__atomic_compare_exchange_2), .-_(__atomic_compare_exchange_2)
+
         .global _(__atomic_compare_exchange_4)
         .type   _(__atomic_compare_exchange_4), %function
 _(__atomic_compare_exchange_4):
 #ifdef __TINYC__
         .short 0x419c
-        .int 0x1605272f
-        .int 0x00f71563
-        .int 0x1ac526af
-        .short 0xfaf5
-        .int 0x40f707bb
-        .int 0x0017b513
+        .int   0x0f50000f
+        .int   0x1405272f
+        .int   0x00f71663
+        .int   0x1cc5282f
+        .int   0xfe081ae3
+        .int   0x40f707bb
+        .int   0x0017b513
         .short 0xc391
         .short 0xc198
         .short 0x8905
         .short 0x8082
 #else
-        lw  a5,0(a1)
-.L___atomic_compare_exchange_4_002:
-        lr.w.aqrl   a4,(a0)
-        bne a4,a5, .L___atomic_compare_exchange_4_010
-        sc.w.rl a3,a2,(a0)
-        bnez    a3, .L___atomic_compare_exchange_4_002
-.L___atomic_compare_exchange_4_010:
-        subw    a5,a4,a5
-        seqz    a0,a5
-        beqz    a5, .L___atomic_compare_exchange_4_01c
-        sw  a4,0(a1)
-.L___atomic_compare_exchange_4_01c:
-        andi    a0,a0,1
+	lw      a5,0(a1)
+	fence	iorw,ow;
+.L11:
+	lr.w.aq	a4,0(a0)
+	bne	a4,a5,.L12
+	sc.w.aq	a6,a2,0(a0)
+	bnez	a6,.L11
+.L12:
+	subw    a5,a4,a5
+	seqz    a0,a5
+	beq     a5,zero,.L13
+	sw      a4,0(a1)
+.L13:
+	andi    a0,a0,1
         ret
-	.size   _(__atomic_compare_exchange_4), .-_(__atomic_compare_exchange_4)
-
 #endif
+        .size   _(__atomic_compare_exchange_4), .-_(__atomic_compare_exchange_4)
+
         .global _(__atomic_compare_exchange_8)
         .type   _(__atomic_compare_exchange_8), %function
 _(__atomic_compare_exchange_8):
 #ifdef __TINYC__
         .short 0x619c
-        .int 0x1605372f
-        .int 0x00f71563
-        .int 0x1ac536af
+        .int   0x0f50000f
+        .int   0x1405372f
+        .int   0x00f71563
+        .int   0x1cc536af
         .short 0xfaf5
-        .int 0x40f707b3
-        .int 0x0017b513
+        .int   0x40f707b3
+        .int   0x0017b513
         .short 0xc391
         .short 0xe198
         .short 0x8905
         .short 0x8082
 #else
-        ld  a5,0(a1)
-.L___atomic_compare_exchange_8_002:
-        lr.d.aqrl   a4,(a0)
-        bne a4,a5, .L___atomic_compare_exchange_8_010
-        sc.d.rl a3,a2,(a0)
-        bnez    a3, .L___atomic_compare_exchange_8_002
-.L___atomic_compare_exchange_8_010:
-        sub a5,a4,a5
-        seqz    a0,a5
-        beqz    a5, .L___atomic_compare_exchange_8_01c
-        sd  a4,0(a1)
-.L___atomic_compare_exchange_8_01c:
-        andi    a0,a0,1
-        ret
-	.size   _(__atomic_compare_exchange_8), .-_(__atomic_compare_exchange_8)
-
-#endif
-        .global _(__atomic_test_and_set_1)
-        .type   _(__atomic_test_and_set_1), %function
-_(__atomic_test_and_set_1):
-#ifdef __TINYC__
-        .int 0x00357793
-        .int 0x0037979b
-        .short 0x4685
-        .short 0x9971
-        .int 0x00f696bb
-        .int 0x46d5272f
-        .int 0x00f7553b
-        .int 0x0ff57513
-        .short 0x8082
-#else
-        andi    a5,a0,3
-        slliw   a5,a5,0x3
-        li  a3,1
-        andi    a0,a0,-4
-        sllw    a3,a3,a5
-        amoor.w.aqrl    a4,a3,(a0)
-        srlw    a0,a4,a5
-        zext.b  a0,a0
-        ret
-	.size   _(__atomic_test_and_set_1), .-_(__atomic_test_and_set_1)
-
-#endif
-        .global _(__atomic_test_and_set_2)
-        .type   _(__atomic_test_and_set_2), %function
-_(__atomic_test_and_set_2):
-#ifdef __TINYC__
-        .int 0x00357793
-        .int 0x0037979b
-        .short 0x4685
-        .short 0x9971
-        .int 0x00f696bb
-        .int 0x46d5272f
-        .int 0x00f7553b
-        .int 0x0ff57513
-        .short 0x8082
-#else
-        andi    a5,a0,3
-        slliw   a5,a5,0x3
-        li  a3,1
-        andi    a0,a0,-4
-        sllw    a3,a3,a5
-        amoor.w.aqrl    a4,a3,(a0)
-        srlw    a0,a4,a5
-        zext.b  a0,a0
+	ld      a5,0(a1)
+	fence	iorw,ow;
+.L14:
+	lr.d.aq	a4,0(a0)
+	bne	a4,a5,.L15
+	sc.d.aq	a3,a2,0(a0)
+	bnez	a3,.L14
+.L15:
+	sub	a5,a4,a5
+	seqz    a0,a5
+	beq     a5,zero,.L16
+	sd      a4,0(a1)
+.L16:
+	andi    a0,a0,1
         ret
-	.size   _(__atomic_test_and_set_2), .-_(__atomic_test_and_set_2)
-
 #endif
-        .global _(__atomic_test_and_set_4)
-        .type   _(__atomic_test_and_set_4), %function
-_(__atomic_test_and_set_4):
-#ifdef __TINYC__
-        .int 0x00357793
-        .int 0x0037979b
-        .short 0x4685
-        .short 0x9971
-        .int 0x00f696bb
-        .int 0x46d5272f
-        .int 0x00f7553b
-        .int 0x0ff57513
-        .short 0x8082
-#else
-        andi    a5,a0,3
-        slliw   a5,a5,0x3
-        li  a3,1
-        andi    a0,a0,-4
-        sllw    a3,a3,a5
-        amoor.w.aqrl    a4,a3,(a0)
-        srlw    a0,a4,a5
-        zext.b  a0,a0
-        ret
-	.size   _(__atomic_test_and_set_4), .-_(__atomic_test_and_set_4)
-
-#endif
-        .global _(__atomic_test_and_set_8)
-        .type   _(__atomic_test_and_set_8), %function
-_(__atomic_test_and_set_8):
-#ifdef __TINYC__
-        .int 0x00357793
-        .int 0x0037979b
-        .short 0x4685
-        .short 0x9971
-        .int 0x00f696bb
-        .int 0x46d5272f
-        .int 0x00f7553b
-        .int 0x0ff57513
-        .short 0x8082
-#else
-        andi    a5,a0,3
-        slliw   a5,a5,0x3
-        li  a3,1
-        andi    a0,a0,-4
-        sllw    a3,a3,a5
-        amoor.w.aqrl    a4,a3,(a0)
-        srlw    a0,a4,a5
-        zext.b  a0,a0
-        ret
-	.size   _(__atomic_test_and_set_8), .-_(__atomic_test_and_set_8)
-
-#endif
-        .global _(atomic_thread_fence)
-        .type   _(atomic_thread_fence), %function
-_(atomic_thread_fence):
-#ifdef __TINYC__
-        .int 0x0330000f
-        .short 0x8082
-#else
-        fence   rw,rw
-        ret
-	.size   _(atomic_thread_fence), .-_(atomic_thread_fence)
-
-#endif
-        .global _(atomic_signal_fence)
-        .type   _(atomic_signal_fence), %function
-_(atomic_signal_fence):
-#ifdef __TINYC__
-        .short 0x8082
-#else
-        ret
-	.size   _(atomic_signal_fence), .-_(atomic_signal_fence)
-
-#endif
-        .global _(atomic_flag_test_and_set)
-        .type   _(atomic_flag_test_and_set), %function
-_(atomic_flag_test_and_set):
-#ifdef __TINYC__
-        .int 0x00357793
-        .int 0x0037979b
-        .short 0x4685
-        .short 0x9971
-        .int 0x00f696bb
-        .int 0x46d5272f
-        .int 0x00f7553b
-        .int 0x0ff57513
-        .short 0x8082
-#else
-        andi    a5,a0,3
-        slliw   a5,a5,0x3
-        li  a3,1
-        andi    a0,a0,-4
-        sllw    a3,a3,a5
-        amoor.w.aqrl    a4,a3,(a0)
-        srlw    a0,a4,a5
-        zext.b  a0,a0
-        ret
-	.size   _(atomic_flag_test_and_set), .-_(atomic_flag_test_and_set)
-
-#endif
-        .global _(atomic_flag_test_and_set_explicit)
-        .type   _(atomic_flag_test_and_set_explicit), %function
-_(atomic_flag_test_and_set_explicit):
-#ifdef __TINYC__
-        .int 0x00357793
-        .int 0x0037979b
-        .short 0x4685
-        .short 0x9971
-        .int 0x00f696bb
-        .int 0x46d5272f
-        .int 0x00f7553b
-        .int 0x0ff57513
-        .short 0x8082
-#else
-        andi    a5,a0,3
-        slliw   a5,a5,0x3
-        li  a3,1
-        andi    a0,a0,-4
-        sllw    a3,a3,a5
-        amoor.w.aqrl    a4,a3,(a0)
-        srlw    a0,a4,a5
-        zext.b  a0,a0
-        ret
-	.size   _(atomic_flag_test_and_set_explicit), .-_(atomic_flag_test_and_set_explicit)
-
-#endif
-        .global _(atomic_flag_clear)
-        .type   _(atomic_flag_clear), %function
-_(atomic_flag_clear):
-#ifdef __TINYC__
-        .int 0x0330000f
-        .int 0x00050023
-        .int 0x0330000f
-        .short 0x8082
-#else
-        fence   rw,rw
-        sb  zero,0(a0)
-        fence   rw,rw
-        ret
-	.size   _(atomic_flag_clear), .-_(atomic_flag_clear)
-
-#endif
-        .global _(atomic_flag_clear_explicit)
-        .type   _(atomic_flag_clear_explicit), %function
-_(atomic_flag_clear_explicit):
-#ifdef __TINYC__
-        .int 0x0330000f
-        .int 0x00050023
-        .int 0x0330000f
-        .short 0x8082
-#else
-        fence   rw,rw
-        sb  zero,0(a0)
-        fence   rw,rw
-        ret
-	.size   _(atomic_flag_clear_explicit), .-_(atomic_flag_clear_explicit)
+        .size   _(__atomic_compare_exchange_8), .-_(__atomic_compare_exchange_8)
 
+/* ---------------------------------------------- */
 #endif
-#endif //__riscv

--- 文件: ./lib/bcheck.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./lib/bcheck.c	2025-09-27 10:22:27.976982465 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./lib/bcheck.c	2025-07-24 10:06:35.134441538 +0800
@@ -22,7 +22,6 @@
 #include <stdarg.h>
 #include <string.h>
 #include <setjmp.h>
-#include <stdatomic.h>
 
 #if !defined(__FreeBSD__) \
  && !defined(__FreeBSD_kernel__) \
@@ -351,7 +350,7 @@
 static unsigned char print_statistic;
 static unsigned char no_strdup;
 static unsigned char use_sem;
-static _Atomic int never_fatal;
+static int never_fatal;
 #if HAVE_TLS_FUNC
 #if defined(_WIN32)
 static int no_checking = 0;
@@ -393,7 +392,7 @@
 #define NO_CHECKING_GET()  no_checking
 #define NO_CHECKING_SET(v) no_checking = v 
 #else
-static _Atomic int no_checking = 0;
+static int no_checking = 0;
 #define NO_CHECKING_GET()  no_checking
 #define NO_CHECKING_SET(v) no_checking = v 
 #endif
@@ -484,13 +483,35 @@
     dprintf(stderr, "%s%s, %s(): Not found %p\n", exec, file, function, ptr);
 }
 
+static void fetch_and_add(int* variable, int value)
+{
+#if defined __i386__ || defined __x86_64__
+      __asm__ volatile("lock; addl %0, %1"
+        : "+r" (value), "+m" (*variable) // input+output
+        : // No input-only
+        : "memory"
+      );
+#elif defined __arm__
+      extern void fetch_and_add_arm(int* variable, int value);
+      fetch_and_add_arm(variable, value);
+#elif defined __aarch64__
+      extern void fetch_and_add_arm64(int* variable, int value);
+      fetch_and_add_arm64(variable, value);
+#elif defined __riscv
+      extern void fetch_and_add_riscv64(int* variable, int value);
+      fetch_and_add_riscv64(variable, value);
+#else
+      *variable += value;
+#endif
+}
+
 /* enable/disable checking. This can be used in signal handlers. */
 void __bounds_checking (int no_check)
 {
 #if HAVE_TLS_FUNC || HAVE_TLS_VAR
     NO_CHECKING_SET(NO_CHECKING_GET() + no_check);
 #else
-    atomic_fetch_add (&no_checking, no_check);
+    fetch_and_add (&no_checking, no_check);
 #endif
 }
 
@@ -507,7 +528,7 @@
 /* enable/disable checking. This can be used in signal handlers. */
 void __bound_never_fatal (int neverfatal)
 {
-    atomic_fetch_add (&never_fatal, neverfatal);
+    fetch_and_add (&never_fatal, neverfatal);
 }
 
 /* return '(p + offset)' for pointer arithmetic (a pointer can reach
@@ -588,9 +609,8 @@
         if (addr <= tree->size) {                                              \
             if (tree->is_invalid || addr + offset + dsize > tree->size) {      \
                 POST_SEM ();                                                   \
-                bound_warning("%p (size %d) is outside of the region "         \
-                              "(0x%lx..0x%lx)",                                \
-                              p + offset, dsize, (long)tree->start,            \
+                bound_warning("%p is outside of the region (0x%lx..0x%lx)",    \
+                              p + offset, (long)tree->start,                   \
                               (long)(tree->start + tree->size - 1));           \
                 if (never_fatal <= 0)                                          \
                     return INVALID_POINTER; /* return an invalid pointer */    \

--- 文件: ./lib/stdatomic.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./lib/stdatomic.c	2025-09-27 10:22:27.976982465 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./lib/stdatomic.c	2025-07-24 10:06:35.134441538 +0800
@@ -15,6 +15,47 @@
 #define __ATOMIC_SEQ_CST 5
 typedef __SIZE_TYPE__ size_t;
 
+void __atomic_thread_fence(int memorder);
+#define MemoryBarrier(memorder) __atomic_thread_fence(memorder)
+
+#if defined __i386__ || defined __x86_64__
+#define ATOMIC_COMPARE_EXCHANGE(TYPE, MODE, SUFFIX) \
+    bool __atomic_compare_exchange_##MODE \
+        (volatile void *atom, void *ref, TYPE xchg, \
+         bool weak, int success_memorder, int failure_memorder) \
+    { \
+        TYPE rv; \
+        TYPE cmp = *(TYPE *)ref; \
+        __asm__ volatile( \
+            "lock cmpxchg" SUFFIX " %2,%1\n" \
+            : "=a" (rv), "+m" (*(TYPE *)atom) \
+            : "q" (xchg), "0" (cmp) \
+            : "memory" \
+        ); \
+        *(TYPE *)ref = rv; \
+        return (rv == cmp); \
+    }
+#else
+#define ATOMIC_COMPARE_EXCHANGE(TYPE, MODE, SUFFIX) \
+    extern bool __atomic_compare_exchange_##MODE \
+        (volatile void *atom, void *ref, TYPE xchg, \
+         bool weak, int success_memorder, int failure_memorder);
+#endif
+
+#define ATOMIC_LOAD(TYPE, MODE) \
+    TYPE __atomic_load_##MODE(const volatile void *atom, int memorder) \
+    { \
+        MemoryBarrier(__ATOMIC_ACQUIRE); \
+        return *(volatile TYPE *)atom; \
+    }
+
+#define ATOMIC_STORE(TYPE, MODE) \
+    void __atomic_store_##MODE(volatile void *atom, TYPE value, int memorder) \
+    { \
+        *(volatile TYPE *)atom = value; \
+        MemoryBarrier(__ATOMIC_ACQ_REL); \
+    }
+
 #define ATOMIC_GEN_OP(TYPE, MODE, NAME, OP, RET) \
     TYPE __atomic_##NAME##_##MODE(volatile void *atom, TYPE value, int memorder) \
     { \
@@ -54,7 +95,10 @@
 #define ATOMIC_FETCH_NAND(TYPE, MODE) \
     ATOMIC_GEN_OP(TYPE, MODE, fetch_nand, ~(cmp & value), cmp)
 
-#define ATOMIC_GEN(TYPE, SIZE) \
+#define ATOMIC_GEN(TYPE, SIZE, SUFFIX) \
+    ATOMIC_STORE(TYPE, SIZE) \
+    ATOMIC_LOAD(TYPE, SIZE) \
+    ATOMIC_COMPARE_EXCHANGE(TYPE, SIZE, SUFFIX) \
     ATOMIC_EXCHANGE(TYPE, SIZE) \
     ATOMIC_ADD_FETCH(TYPE, SIZE) \
     ATOMIC_SUB_FETCH(TYPE, SIZE) \
@@ -69,10 +113,12 @@
     ATOMIC_FETCH_XOR(TYPE, SIZE) \
     ATOMIC_FETCH_NAND(TYPE, SIZE)
 
-ATOMIC_GEN(uint8_t, 1)
-ATOMIC_GEN(uint16_t, 2)
-ATOMIC_GEN(uint32_t, 4)
-ATOMIC_GEN(uint64_t, 8)
+ATOMIC_GEN(uint8_t, 1, "b")
+ATOMIC_GEN(uint16_t, 2, "w")
+ATOMIC_GEN(uint32_t, 4, "l")
+#if defined __x86_64__ || defined __aarch64__ || defined __riscv
+ATOMIC_GEN(uint64_t, 8, "q")
+#endif
 
 /* uses alias to allow building with gcc/clang */
 #ifdef __TINYC__
@@ -81,6 +127,25 @@
 #define ATOMIC(x)      __tcc_atomic_##x
 #endif
 
+void ATOMIC(signal_fence) (int memorder)
+{
+}
+
+void ATOMIC(thread_fence) (int memorder)
+{
+#if defined __i386__
+        __asm__ volatile("lock orl $0, (%esp)");
+#elif defined __x86_64__
+        __asm__ volatile("lock orq $0, (%rsp)");
+#elif defined __arm__
+        __asm__ volatile(".int 0xee070fba"); // mcr p15, 0, r0, c7, c10, 5
+#elif defined __aarch64__
+        __asm__ volatile(".int 0xd5033bbf"); // dmb ish
+#elif defined __riscv
+        __asm__ volatile(".int 0x0ff0000f"); // fence iorw,iorw
+#endif
+}
+
 bool ATOMIC(is_lock_free) (unsigned long size, const volatile void *ptr)
 {
     bool ret;
@@ -100,5 +165,7 @@
 }
 
 #ifndef __TINYC__
+void __atomic_signal_fence(int memorder) __attribute__((alias("__tcc_atomic_signal_fence")));
+void __atomic_thread_fence(int memorder) __attribute__((alias("__tcc_atomic_thread_fence")));
 bool __atomic_is_lock_free(unsigned long size, const volatile void *ptr) __attribute__((alias("__tcc_atomic_is_lock_free")));
 #endif

--- 文件: ./libtcc.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./libtcc.c	2025-09-27 10:22:27.976982465 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./libtcc.c	2025-07-24 10:06:35.134441538 +0800
@@ -257,6 +257,9 @@
     free(ptr);
 }
 
+#define free(p) use_tcc_free(p)
+#define realloc(p, s) use_tcc_realloc(p, s)
+
 /* global so that every tcc_alloc()/tcc_free() call doesn't need to be changed */
 static void *(*reallocator)(void*, unsigned long) = default_reallocator;
 
@@ -311,7 +314,7 @@
 #define MEM_DEBUG_MAGIC3 0xFEEDDEB3
 #define MEM_DEBUG_FILE_LEN 40
 #define MEM_DEBUG_CHECK3(header) \
-    (((unsigned char *) header->magic3) + header->size)
+    ((mem_debug_header_t*)((char*)header + header->size))->magic3
 #define MEM_USER_PTR(header) \
     ((char *)header + offsetof(mem_debug_header_t, magic3))
 #define MEM_HEADER_PTR(ptr) \
@@ -323,7 +326,7 @@
     struct mem_debug_header *prev;
     struct mem_debug_header *next;
     int line_num;
-    char file_name[MEM_DEBUG_FILE_LEN];
+    char file_name[MEM_DEBUG_FILE_LEN + 1];
     unsigned magic2;
     ALIGNED(16) unsigned char magic3[4];
 };
@@ -364,8 +367,9 @@
     header->size = size;
     write32le(MEM_DEBUG_CHECK3(header), MEM_DEBUG_MAGIC3);
     header->line_num = line;
-    ofs = strlen(file) + 1 - MEM_DEBUG_FILE_LEN;
-    strcpy(header->file_name, file + (ofs > 0 ? ofs : 0));
+    ofs = strlen(file) - MEM_DEBUG_FILE_LEN;
+    strncpy(header->file_name, file + (ofs > 0 ? ofs : 0), MEM_DEBUG_FILE_LEN);
+    header->file_name[MEM_DEBUG_FILE_LEN] = 0;
     WAIT_SEM(&mem_sem);
     header->next = mem_debug_chain;
     header->prev = NULL;
@@ -800,6 +804,7 @@
     s1->error_set_jmp_enabled = 1;
 
     if (setjmp(s1->error_jmp_buf) == 0) {
+        s1->nb_errors = 0;
 
         if (fd == -1) {
             int len = strlen(str);
@@ -1452,8 +1457,6 @@
             s->filetype |= AFF_WHOLE_ARCHIVE;
         } else if (link_option(&o, "no-whole-archive")) {
             s->filetype &= ~AFF_WHOLE_ARCHIVE;
-        } else if (link_option(&o, "znodelete")) {
-            s->znodelete = 1;
 #ifdef TCC_TARGET_PE
         } else if (link_option(&o, "large-address-aware")) {
             s->pe_characteristics |= 0x20;
@@ -1462,9 +1465,31 @@
         } else if (link_option(&o, "stack=")) {
             s->pe_stack_size = strtoul(o.arg, &end, 10);
         } else if (link_option(&o, "subsystem=")) {
-            if (pe_setsubsy(s, o.arg) < 0)
+#if defined(TCC_TARGET_I386) || defined(TCC_TARGET_X86_64)
+            if (0==strcmp("native", o.arg)) {
+                s->pe_subsystem = 1;
+            } else if (0==strcmp("console", o.arg)) {
+                s->pe_subsystem = 3;
+            } else if (0==strcmp("gui", o.arg) || 0==strcmp("windows", o.arg)) {
+                s->pe_subsystem = 2;
+            } else if (0==strcmp("posix", o.arg)) {
+                s->pe_subsystem = 7;
+            } else if (0==strcmp("efiapp", o.arg)) {
+                s->pe_subsystem = 10;
+            } else if (0==strcmp("efiboot", o.arg)) {
+                s->pe_subsystem = 11;
+            } else if (0==strcmp("efiruntime", o.arg)) {
+                s->pe_subsystem = 12;
+            } else if (0==strcmp("efirom", o.arg)) {
+                s->pe_subsystem = 13;
+#elif defined(TCC_TARGET_ARM)
+            if (0==strcmp("wince", o.arg)) {
+                s->pe_subsystem = 9;
+#endif
+            } else
                 goto err;
-#elif defined TCC_TARGET_MACHO
+#endif /* PE */
+#ifdef TCC_TARGET_MACHO
         } else if (link_option(&o, "all_load")) {
 	    s->filetype |= AFF_WHOLE_ARCHIVE;
         } else if (link_option(&o, "force_load=")) {
@@ -1628,10 +1653,11 @@
     { "w", TCC_OPTION_w, 0 },
     { "E", TCC_OPTION_E, 0},
     { "M", TCC_OPTION_M, 0},
-    { "MM", TCC_OPTION_MM, 0},
-    { "MD", TCC_OPTION_MD, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },
-    { "MMD", TCC_OPTION_MMD, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },
+    { "MD", TCC_OPTION_MD, 0},
     { "MF", TCC_OPTION_MF, TCC_OPTION_HAS_ARG },
+    { "MM", TCC_OPTION_MM, 0},
+    { "MMD,", TCC_OPTION_MMD, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },
+    { "MMD", TCC_OPTION_MMD, 0},
     { "MP", TCC_OPTION_MP, 0},
     { "x", TCC_OPTION_x, TCC_OPTION_HAS_ARG },
     /* tcctools */
@@ -1811,7 +1837,8 @@
     const TCCOption *popt;
     const char *optarg, *r;
     const char *run = NULL;
-    int optind = 1, empty = 1, x;
+    int x;
+    int tool = 0, arg_start = 0, not_empty = 0, optind = 1;
     char **argv = *pargv;
     int argc = *pargc;
 
@@ -1830,16 +1857,21 @@
             continue;
         }
         optind++;
+        if (tool) { /* ignore all except -v and @listfile */
+            s->verbose += !strcmp(r, "-v");
+            continue;
+        }
+
         if (r[0] != '-' || r[1] == '\0') { /* file or '-' (stdin) */
             args_parser_add_file(s, r, s->filetype);
-            empty = 0;
+            not_empty = 1;
         dorun:
             if (run) {
                 /* tcc -run <file> <args...> */
-                if (tcc_set_options(s, run) < 0)
+                if (tcc_set_options(s, run))
                     return -1;
-                x = 0;
-                goto extra_action;
+                arg_start = optind - 1; /* argv[0] will be <file> */
+                break;
             }
             continue;
         }
@@ -1912,16 +1944,14 @@
         case TCC_OPTION_g:
             s->do_debug = 2;
             s->dwarf = CONFIG_DWARF_VERSION;
-        g_redo:
             if (strstart("dwarf", &optarg)) {
                 s->dwarf = (*optarg) ? (0 - atoi(optarg)) : DEFAULT_DWARF_VERSION;
             } else if (0 == strcmp("stabs", optarg)) {
                 s->dwarf = 0;
             } else if (isnum(*optarg)) {
-                x = *optarg++ - '0';
+                x = *optarg - '0';
                 /* -g0 = no info, -g1 = lines/functions only, -g2 = full info */
                 s->do_debug = x > 2 ? 2 : x == 0 && s->do_backtrace ? 1 : x;
-                goto g_redo;
 #ifdef TCC_TARGET_PE
             } else if (0 == strcmp(".pdb", optarg)) {
                 s->dwarf = 5, s->do_debug |= 16;
@@ -2021,6 +2051,7 @@
             }
             break;
         case TCC_OPTION_W:
+            s->warn_none = 0;
             if (optarg[0] && set_flag(s, options_W, optarg) < 0)
                 goto unsupported_option;
             break;
@@ -2044,7 +2075,6 @@
         case TCC_OPTION_P:
             s->Pflag = atoi(optarg) + 1;
             break;
-
         case TCC_OPTION_M:
             s->include_sys_deps = 1;
             // fall through
@@ -2054,31 +2084,29 @@
             if (!s->deps_outfile)
                 tcc_set_str(&s->deps_outfile, "-");
             break;
-        case TCC_OPTION_MD:
-            s->include_sys_deps = 1;
-            // fall through
         case TCC_OPTION_MMD:
             s->gen_deps = 1;
             /* usually, only "-MMD" is used */
             /* but the Linux Kernel uses "-MMD,depfile" */
-            if (*optarg != ',')
-                break;
-            ++optarg;
-            // fall through
+            if ((optarg) && (*optarg != '\0'))
+                tcc_set_str(&s->deps_outfile, optarg);
+            break;
+        case TCC_OPTION_MD:
+            s->gen_deps = 1;
+            s->include_sys_deps = 1;
+            break;
         case TCC_OPTION_MF:
             tcc_set_str(&s->deps_outfile, optarg);
             break;
         case TCC_OPTION_MP:
             s->gen_phony_deps = 1;
             break;
-
         case TCC_OPTION_dumpmachine:
             printf("%s\n", dumpmachine_str);
             exit(0);
         case TCC_OPTION_dumpversion:
             printf ("%s\n", TCC_VERSION);
             exit(0);
-
         case TCC_OPTION_x:
             x = 0;
             if (*optarg == 'c')
@@ -2131,24 +2159,29 @@
         case TCC_OPTION_ar:
             x = OPT_AR;
         extra_action:
-            if (NULL == argv[0]) /* from tcc_set_options() */
-                return -1;
-            if (!empty && x)
+            arg_start = optind - 1;
+            if (not_empty)
                 return tcc_error_noabort("cannot parse %s here", r);
-            --optind;
-            *pargc = argc - optind;
-            *pargv = argv + optind;
-            return x;
+            tool = x;
+            break;
         default:
 unsupported_option:
             tcc_warning_c(warn_unsupported)("unsupported option '%s'", r);
             break;
         }
-        empty = 0;
+        not_empty = 1;
     }
+
     if (s->link_optind < s->link_argc)
         return tcc_error_noabort("argument to '-Wl,%s' is missing", s->link_argv[s->link_optind]);
-    if (!empty)
+    if (NULL == argv[0]) /* from tcc_set_options() */
+        return 0;
+    if (arg_start) {
+        *pargc = argc - arg_start;
+        *pargv = argv + arg_start;
+        return tool;
+    }
+    if (not_empty)
         return 0;
     if (s->verbose == 2)
         return OPT_PRINT_DIRS;

--- 文件: ./Makefile ---
--- /workspace/self-evolve-ai/third_party/tinycc/./Makefile	2025-09-27 10:22:27.952982352 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./Makefile	2025-07-24 10:06:35.126441498 +0800
@@ -252,11 +252,8 @@
 endif
 
 # convert "include/tccdefs.h" to "tccdefs_.h"
-%_.h : include/%.h c2str.exe
-	$S./c2str.exe $< $@
-
-c2str.exe : conftest.c
-	$S$(CC) -DC2STR $< -o $@
+%_.h : include/%.h conftest.c
+	$S$(CC) -DC2STR $(filter %.c,$^) -o c2str.exe && ./c2str.exe $< $@
 
 # target specific object rule
 $(X)%.o : %.c $(LIBTCC_INC)
@@ -467,17 +464,12 @@
 	@$(MAKE) --no-print-directory TCC_LOCAL=$(CURDIR)/$< tes$*
 tcc_c$(EXESUF): $($T_FILES)
 	$S$(TCC) tcc.c -o $@ -ftest-coverage $(DEFINES) $(LIBS)
-# run tests with sanitize option
-sani-tes% : tcc_s$(EXESUF)
-	@$(MAKE) --no-print-directory TCC_LOCAL=$(CURDIR)/$< tes$*
-tcc_s$(EXESUF): $($T_FILES)
-	$S$(CC) tcc.c -o $@ -fsanitize=address,undefined $(DEFINES) $(CFLAGS) $(LIBS)
 # test the installed tcc instead
 test-install: $(TCCDEFS_H)
 	@$(MAKE) -C tests TESTINSTALL=yes #_all
 
 clean:
-	@rm -f tcc *-tcc tcc_p tcc_c tcc_s
+	@rm -f tcc *-tcc tcc_p tcc_c
 	@rm -f tags ETAGS *.o *.a *.so* *.out *.log lib*.def *.exe *.dll
 	@rm -f a.out *.dylib *_.h *.pod *.tcov
 	@$(MAKE) -s -C lib $@
@@ -506,10 +498,8 @@
 	@echo "   run all/single test(s) from tests2, optionally update .expect"
 	@echo "make testspp.all / make testspp.17"
 	@echo "   run all/single test(s) from tests/pp"
-	@echo "make tcov-test / tcov-tests2.37 / tcov-testspp.17"
+	@echo "make tcov-test / tcov-tests2... / tcov-testspp..."
 	@echo "   run tests as above with code coverage. After test(s) see tcc_c$(EXESUF).tcov"
-	@echo "make sani-test / sani-tests2.37 / sani-testspp.17"
-	@echo "   run tests as above with sanitize option."
 	@echo "make test-install"
 	@echo "   run tests with the installed tcc"
 	@echo "Other supported make targets:"

--- 文件: ./riscv64-gen.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./riscv64-gen.c	2025-09-27 10:22:27.980982485 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./riscv64-gen.c	2025-07-24 10:06:35.138441557 +0800
@@ -35,11 +35,6 @@
 #include "tcc.h"
 #include <assert.h>
 
-#define UPPER(x)	(((unsigned)(x) + 0x800u) & 0xfffff000)
-#define LOW_OVERFLOW(x)	UPPER(x)
-#define SIGN7(x)	((((x) & 0xff) ^ 0x80) - 0x80)
-#define SIGN11(x)	((((x) & 0xfff) ^ 0x800) - 0x800)
-
 ST_DATA const char * const target_machine_defs =
     "__riscv\0"
     "__riscv_xlen 64\0"
@@ -136,14 +131,14 @@
 static void EI(uint32_t opcode, uint32_t func3,
                uint32_t rd, uint32_t rs1, uint32_t imm)
 {
-    assert(! LOW_OVERFLOW(imm));
+    assert(! ((imm + (1 << 11)) >> 12));
     EIu(opcode, func3, rd, rs1, imm);
 }
 
 static void ES(uint32_t opcode, uint32_t func3,
                uint32_t rs1, uint32_t rs2, uint32_t imm)
 {
-    assert(! LOW_OVERFLOW(imm));
+    assert(! ((imm + (1 << 11)) >> 12));
     o(opcode | (func3 << 12) | ((imm & 0x1f) << 7) | (rs1 << 15)
       | (rs2 << 20) | ((imm >> 5) << 25));
 }
@@ -159,7 +154,7 @@
         uint32_t r = a - t, imm;
         if ((r + (1 << 21)) & ~((1U << 22) - 2))
           tcc_error("out-of-range branch chain");
-        imm = (((r >> 12) &  0xff) << 12)
+        imm =   (((r >> 12) &  0xff) << 12)
             | (((r >> 11) &     1) << 20)
             | (((r >>  1) & 0x3ff) << 21)
             | (((r >> 20) &     1) << 31);
@@ -168,7 +163,7 @@
     }
 }
 
-static int load_symofs(int r, SValue *sv, int forstore, int *new_fc)
+static int load_symofs(int r, SValue *sv, int forstore)
 {
     int rr, doload = 0, large_addend = 0;
     int fc = sv->c.i, v = sv->r & VT_VALMASK;
@@ -178,9 +173,9 @@
         if (sv->sym->type.t & VT_STATIC) { // XXX do this per linker relax
             greloca(cur_text_section, sv->sym, ind,
                     R_RISCV_PCREL_HI20, sv->c.i);
-            *new_fc = 0;
+            sv->c.i = 0;
         } else {
-            if (LOW_OVERFLOW(fc)){
+            if (((unsigned)fc + (1 << 11)) >> 12){
               large_addend = 1;
             }
             greloca(cur_text_section, sv->sym, ind,
@@ -198,20 +193,20 @@
         if (doload) {
             EI(0x03, 3, rr, rr, 0); // ld RR, 0(RR)
             if (large_addend) {
-                o(0x37 | (6 << 7) | UPPER(fc)); //lui t1, high(fc)
+                o(0x37 | (6 << 7) | ((0x800 + fc) & 0xfffff000)); //lui t1, high(fc)
                 ER(0x33, 0, rr, rr, 6, 0); // add RR, RR, t1
-                *new_fc = SIGN11(fc);
+                sv->c.i = fc << 20 >> 20;
             }
         }
     } else if (v == VT_LOCAL || v == VT_LLOCAL) {
         rr = 8; // s0
         if (fc != sv->c.i)
           tcc_error("unimp: store(giant local off) (0x%lx)", (long)sv->c.i);
-        if (LOW_OVERFLOW(fc)) {
+        if (((unsigned)fc + (1 << 11)) >> 12) {
             rr = is_ireg(r) ? ireg(r) : 5; // t0
-            o(0x37 | (rr << 7) | UPPER(fc)); //lui RR, upper(fc)
+            o(0x37 | (rr << 7) | ((0x800 + fc) & 0xfffff000)); //lui RR, upper(fc)
             ER(0x33, 0, rr, rr, 8, 0); // add RR, RR, s0
-            *new_fc = SIGN11(fc);
+            sv->c.i = fc << 20 >> 20;
         }
     } else
       tcc_error("uhh");
@@ -222,12 +217,13 @@
 {
     if (fc < 0)
 	pi++;
-    o(0x37 | (rr << 7) | UPPER(pi)); // lui RR, up(up(fc))
-    EI(0x13, 0, rr, rr, SIGN11(pi));   // addi RR, RR, lo(up(fc))
+    o(0x37 | (rr << 7) | (((pi + 0x800) & 0xfffff000))); // lui RR, up(up(fc))
+    EI(0x13, 0, rr, rr, (int)pi << 20 >> 20);   // addi RR, RR, lo(up(fc))
     EI(0x13, 1, rr, rr, 12); // slli RR, RR, 12
-    EI(0x13, 0, rr, rr, SIGN11(((unsigned)fc + (1 << 19)) >> 20)); // addi RR, RR, up(lo(fc))
+    EI(0x13, 0, rr, rr, (fc + (1 << 19)) >> 20);  // addi RR, RR, up(lo(fc))
     EI(0x13, 1, rr, rr, 12); // slli RR, RR, 12
-    EI(0x13, 0, rr, rr, SIGN11(((unsigned)fc + (1 << 7)) >> 8));  // addi RR, RR, lo1(lo(fc))
+    fc = fc << 12 >> 12;
+    EI(0x13, 0, rr, rr, fc >> 8);  // addi RR, RR, lo1(lo(fc))
     EI(0x13, 1, rr, rr, 8); // slli RR, RR, 8
 }
 
@@ -249,14 +245,16 @@
         if (size < 4 && !is_float(sv->type.t) && (sv->type.t & VT_UNSIGNED))
           func3 |= 4;
         if (v == VT_LOCAL || (fr & VT_SYM)) {
-            br = load_symofs(r, sv, 0, &fc);
+            br = load_symofs(r, sv, 0);
+            fc = sv->c.i;
         } else if (v < VT_CONST) {
             br = ireg(v);
-            /*if (LOW_OVERFLOW(fc))
+            /*if (((unsigned)fc + (1 << 11)) >> 12)
               tcc_error("unimp: load(large addend) (0x%x)", fc);*/
             fc = 0; // XXX store ofs in LVAL(reg)
         } else if (v == VT_LLOCAL) {
-            br = load_symofs(r, sv, 0, &fc);
+            br = load_symofs(r, sv, 0);
+            fc = sv->c.i;
             EI(0x03, 3, rr, br, fc); // ld RR, fc(BR)
             br = rr;
             fc = 0;
@@ -265,10 +263,10 @@
             si >>= 32;
             if (si != 0) {
 		load_large_constant(rr, fc, si);
-                fc = SIGN7(fc);
+                fc &= 0xff;
             } else {
-                o(0x37 | (rr << 7) | UPPER(fc)); //lui RR, upper(fc)
-                fc = SIGN11(fc);
+                o(0x37 | (rr << 7) | ((0x800 + fc) & 0xfffff000)); //lui RR, upper(fc)
+                fc = fc << 20 >> 20;
 	    }
             br = rr;
 	} else {
@@ -279,17 +277,18 @@
         int rb = 0, do32bit = 8, zext = 0;
         assert((!is_float(sv->type.t) && is_ireg(r)) || bt == VT_LDOUBLE);
         if (fr & VT_SYM) {
-            rb = load_symofs(r, sv, 0, &fc);
+            rb = load_symofs(r, sv, 0);
+            fc = sv->c.i;
             do32bit = 0;
         }
         if (is_float(sv->type.t) && bt != VT_LDOUBLE)
           tcc_error("unimp: load(float)");
-        if (do32bit && fc != sv->c.i) {
+        if (fc != sv->c.i) {
             int64_t si = sv->c.i;
             si >>= 32;
             if (si != 0) {
 		load_large_constant(rr, fc, si);
-                fc = SIGN7(fc);
+                fc &= 0xff;
                 rb = rr;
                 do32bit = 0;
             } else if (bt == VT_LLONG) {
@@ -298,17 +297,18 @@
                 zext = 1;
             }
         }
-        if (LOW_OVERFLOW(fc))
-            o(0x37 | (rr << 7) | UPPER(fc)), rb = rr; //lui RR, upper(fc)
+        if (((unsigned)fc + (1 << 11)) >> 12)
+            o(0x37 | (rr << 7) | ((0x800 + fc) & 0xfffff000)), rb = rr; //lui RR, upper(fc)
         if (fc || (rr != rb) || do32bit || (fr & VT_SYM))
-          EI(0x13 | do32bit, 0, rr, rb, SIGN11(fc)); // addi[w] R, x0|R, FC
+          EI(0x13 | do32bit, 0, rr, rb, fc << 20 >> 20); // addi[w] R, x0|R, FC
         if (zext) {
             EI(0x13, 1, rr, rr, 32); // slli RR, RR, 32
             EI(0x13, 5, rr, rr, 32); // srli RR, RR, 32
         }
     } else if (v == VT_LOCAL) {
-        int br = load_symofs(r, sv, 0, &fc);
+        int br = load_symofs(r, sv, 0);
         assert(is_ireg(r));
+        fc = sv->c.i;
         EI(0x13, 0, rr, br, fc); // addi R, s0, FC
     } else if (v < VT_CONST) { /* reg-reg */
         //assert(!fc); XXX support offseted regs
@@ -323,7 +323,7 @@
               func7 |= 1;
             assert(size == 4 || size == 8);
             o(0x53 | (rr << 7) | ((is_freg(v) ? freg(v) : ireg(v)) << 15)
-              | ((unsigned)func7 << 25)); // fmv.{w.x, x.w, d.x, x.d} RR, VR
+              | (func7 << 25)); // fmv.{w.x, x.w, d.x, x.d} RR, VR
         }
     } else if (v == VT_CMP) {
         int op = vtop->cmp_op;
@@ -390,10 +390,11 @@
       tcc_error("unimp: large sized store");
     assert(sv->r & VT_LVAL);
     if (fr == VT_LOCAL || (sv->r & VT_SYM)) {
-        ptrreg = load_symofs(-1, sv, 1, &fc);
+        ptrreg = load_symofs(-1, sv, 1);
+        fc = sv->c.i;
     } else if (fr < VT_CONST) {
         ptrreg = ireg(fr);
-        /*if (LOW_OVERFLOW(fc))
+        /*if (((unsigned)fc + (1 << 11)) >> 12)
           tcc_error("unimp: store(large addend) (0x%x)", fc);*/
         fc = 0; // XXX support offsets regs
     } else if (fr == VT_CONST) {
@@ -402,10 +403,10 @@
         si >>= 32;
         if (si != 0) {
 	    load_large_constant(ptrreg, fc, si);
-            fc = SIGN7(fc);
+            fc &= 0xff;
         } else {
-            o(0x37 | (ptrreg << 7) | UPPER(fc)); //lui RR, upper(fc)
-            fc = SIGN11(fc);
+            o(0x37 | (ptrreg << 7) | ((0x800 + fc) & 0xfffff000)); //lui RR, upper(fc)
+            fc = fc << 20 >> 20;
 	}
     } else
       tcc_error("implement me: %s(!local)", __FUNCTION__);
@@ -556,7 +557,6 @@
     int i, align, size, areg[2];
     int *info = tcc_malloc((nb_args + 1) * sizeof (int));
     int stack_adj = 0, tempspace = 0, stack_add, ofs, splitofs = 0;
-    int old = (vtop[-nb_args].type.ref->f.func_type == FUNC_OLD);
     SValue *sv;
     Sym *sa;
 
@@ -584,8 +584,8 @@
             size = align = 8;
             byref = 64 | (tempofs << 7);
         }
-        reg_pass(&sv->type, prc, fieldofs, old || sa != 0);
-        if (!old && !sa && align == 2*XLEN && size <= 2*XLEN)
+        reg_pass(&sv->type, prc, fieldofs, sa != 0);
+        if (!sa && align == 2*XLEN && size <= 2*XLEN)
           areg[0] = (areg[0] + 1) & ~1;
         nregs = prc[0];
         if (size == 0)
@@ -600,7 +600,7 @@
             if (align < XLEN)
               align = XLEN;
             stack_adj += (size + align - 1) & -align;
-            if (!old && !sa) /* one vararg on stack forces the rest on stack */
+            if (!sa) /* one vararg on stack forces the rest on stack */
               areg[0] = 8, areg[1] = 16;
         } else {
             info[i] = areg[prc[1] - 1]++;
@@ -630,8 +630,11 @@
 
     if (stack_add) {
         if (stack_add >= 0x800) {
-            o(0x37 | (5 << 7) | UPPER(-stack_add)); //lui t0, upper(v)
-            EI(0x13, 0, 5, 5, SIGN11(-stack_add)); // addi t0, t0, lo(v)
+            unsigned int bit11 = (((unsigned int)-stack_add) >> 11) & 1;
+            o(0x37 | (5 << 7) |
+              ((-stack_add + (bit11 << 12)) & 0xfffff000)); //lui t0, upper(v)
+            EI(0x13, 0, 5, 5, ((-stack_add & 0xfff) - bit11 * (1 << 12)));
+                                                         // addi t0, t0, lo(v)
             ER(0x33, 0, 2, 2, 5, 0); // add sp, sp, t0
         }
         else
@@ -759,8 +762,11 @@
     vtop -= nb_args + 1;
     if (stack_add) {
         if (stack_add >= 0x800) {
-            o(0x37 | (5 << 7) | UPPER(stack_add)); //lui t0, upper(v)
-            EI(0x13, 0, 5, 5, SIGN11(stack_add)); // addi t0, t0, lo(v)
+            unsigned int bit11 = ((unsigned int)stack_add >> 11) & 1;
+            o(0x37 | (5 << 7) |
+              ((stack_add + (bit11 << 12)) & 0xfffff000)); //lui t0, upper(v)
+            EI(0x13, 0, 5, 5, (stack_add & 0xfff) - bit11 * (1 << 12));
+                                                           // addi t0, t0, lo(v)
             ER(0x33, 0, 2, 2, 5, 0); // add sp, sp, t0
         }
         else
@@ -833,7 +839,9 @@
                 }
             }
         }
-        gfunc_set_param(sym, param_addr, byref);
+        sym_push(sym->v & ~SYM_FIELD, &sym->type,
+                 (byref ? VT_LLOCAL : VT_LOCAL) | VT_LVAL,
+                 param_addr);
     }
     func_va_list_ofs = addr;
     num_va_regs = 0;
@@ -899,8 +907,8 @@
 
     if (v >= (1 << 11)) {
         d = 16;
-        o(0x37 | (5 << 7) | UPPER(v-16)); //lui t0, upper(v)
-        EI(0x13, 0, 5, 5, SIGN11(v-16)); // addi t0, t0, lo(v)
+        o(0x37 | (5 << 7) | ((0x800 + (v-16)) & 0xfffff000)); //lui t0, upper(v)
+        EI(0x13, 0, 5, 5, (v-16) << 20 >> 20); // addi t0, t0, lo(v)
         ER(0x33, 0, 2, 2, 5, 0); // add sp, sp, t0
     }
     EI(0x03, 3, 1, 2, d - 8 - num_va_regs * 8);  // ld ra, v-8(sp)
@@ -910,8 +918,8 @@
     large_ofs_ind = ind;
     if (v >= (1 << 11)) {
         EI(0x13, 0, 8, 2, d - num_va_regs * 8);      // addi s0, sp, d
-        o(0x37 | (5 << 7) | UPPER(v-16)); //lui t0, upper(v)
-        EI(0x13, 0, 5, 5, SIGN11(v-16)); // addi t0, t0, lo(v)
+        o(0x37 | (5 << 7) | ((0x800 + (v-16)) & 0xfffff000)); //lui t0, upper(v)
+        EI(0x13, 0, 5, 5, (v-16) << 20 >> 20); // addi t0, t0, lo(v)
         ER(0x33, 0, 2, 2, 5, 0x20); // sub sp, sp, t0
         gjmp_addr(func_sub_sp_offset + 5*4);
     }
@@ -960,8 +968,8 @@
 {
     uint32_t r = a - ind, imm;
     if ((r + (1 << 21)) & ~((1U << 22) - 2)) {
-        o(0x17 | (5 << 7) | UPPER(r)); // lui RR, up(r)
-        r = SIGN11(r);
+        o(0x17 | (5 << 7) | (((r + 0x800) & 0xfffff000))); // lui RR, up(r)
+        r = (int)r << 20 >> 20;
         EI(0x67, 0, 0, 5, r);      // jalr x0, r(t0)
     } else {
         imm = (((r >> 12) &  0xff) << 12)
@@ -1014,7 +1022,7 @@
     ll = ll ? 0 : 8;
     if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST) {
         int fc = vtop->c.i;
-        if (fc == vtop->c.i && !LOW_OVERFLOW(fc)) {
+        if (fc == vtop->c.i && !(((unsigned)fc + (1 << 11)) >> 12)) {
             int cll = 0;
             int m = ll ? 31 : 63;
             vswap();
@@ -1381,10 +1389,10 @@
 
 ST_FUNC void gen_vla_sp_save(int addr)
 {
-    if (LOW_OVERFLOW(addr)) {
-	o(0x37 | (5 << 7) | UPPER(addr)); //lui t0,upper(addr)
+    if (((unsigned)addr + (1 << 11)) >> 12) {
+	o(0x37 | (5 << 7) | ((0x800 + addr) & 0xfffff000)); //lui t0,upper(addr)
         ER(0x33, 0, 5, 5, 8, 0); // add t0, t0, s0
-        ES(0x23, 3, 5, 2, SIGN11(addr)); // sd sp, fc(t0)
+        ES(0x23, 3, 5, 2, (int)addr << 20 >> 20); // sd sp, fc(t0)
     }
     else
         ES(0x23, 3, 8, 2, addr); // sd sp, fc(s0)
@@ -1392,10 +1400,10 @@
 
 ST_FUNC void gen_vla_sp_restore(int addr)
 {
-    if (LOW_OVERFLOW(addr)) {
-	o(0x37 | (5 << 7) | UPPER(addr)); //lui t0,upper(addr)
+    if (((unsigned)addr + (1 << 11)) >> 12) {
+	o(0x37 | (5 << 7) | ((0x800 + addr) & 0xfffff000)); //lui t0,upper(addr)
         ER(0x33, 0, 5, 5, 8, 0); // add t0, t0, s0
-        EI(0x03, 3, 2, 5, SIGN11(addr)); // ld sp, fc(t0)
+        EI(0x03, 3, 2, 5, (int)addr << 20 >> 20); // ld sp, fc(t0)
     }
     else
         EI(0x03, 3, 2, 8, addr); // ld sp, fc(s0)

--- 文件: ./riscv64-link.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./riscv64-link.c	2025-09-27 10:22:27.980982485 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./riscv64-link.c	2025-07-24 10:06:35.138441557 +0800
@@ -347,7 +347,7 @@
         *ptr = (*ptr & ~0xff) | (val & 0xff);
         return;
     case R_RISCV_SET16:
-        write16le(ptr, val);
+        *ptr = (*ptr & ~0xffff) | (val & 0xffff);
         return;
     case R_RISCV_SUB6:
         *ptr = (*ptr & ~0x3f) | ((*ptr - val) & 0x3f);

--- 文件: ./tccasm.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tccasm.c	2025-09-27 10:22:27.984982503 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tccasm.c	2025-07-24 10:06:35.138441557 +0800
@@ -842,7 +842,7 @@
 
             if (!strcmp(newtype, "function") || !strcmp(newtype, "STT_FUNC")) {
                 if (IS_ASM_SYM(sym))
-                    sym->type.t |= VT_ASM_FUNC;
+                    sym->type.t = (sym->type.t & ~VT_ASM) | VT_ASM_FUNC;
                 st_type = STT_FUNC;
             set_st_type:
                 if (sym->c) {
@@ -907,10 +907,6 @@
 	       sets alignment to PTR_SIZE.  The assembler behaves different. */
 	    if (old_nb_section != s1->nb_sections) {
 	        cur_text_section->sh_addralign = 1;
-                /* Make .init and .fini sections executable by default.
-                   GAS does so, too, and musl relies on it. */
-                if (!strcmp(sname, ".init") || !strcmp(sname, ".fini"))
-                    flags |= SHF_EXECINSTR;
 	        cur_text_section->sh_flags = flags;
             }
         }

--- 文件: ./tcc.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tcc.c	2025-09-27 10:22:27.980982485 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tcc.c	2025-07-24 10:06:35.138441557 +0800
@@ -87,7 +87,6 @@
 #ifdef TCC_TARGET_PE
     "  create def file : tcc -impdef lib.dll [-v] [-o lib.def]\n"
 #endif
-    "  report bugs to the mailing list http://lists.nongnu.org/mailman/listinfo/tinycc-devel\n"
     ;
 
 static const char help2[] =
@@ -284,52 +283,53 @@
 #endif
 }
 
-int main(int argc, char **argv)
+int main(int argc0, char **argv0)
 {
     TCCState *s, *s1;
     int ret, opt, n = 0, t = 0, done;
     unsigned start_time = 0, end_time = 0;
     const char *first_file;
-    int argc0 = argc;
-    char **argv0 = argv;
+    int argc; char **argv;
     FILE *ppfp = stdout;
 
 redo:
     argc = argc0, argv = argv0;
     s = s1 = tcc_new();
     opt = tcc_parse_args(s, &argc, &argv);
+    if (opt < 0)
+        return 1;
 
     if (n == 0) {
-        ret = 0;
         if (opt == OPT_HELP) {
             fputs(help, stdout);
-            if (s->verbose)
-                goto help2;
-        } else if (opt == OPT_HELP2) {
-            help2: fputs(help2, stdout);
-        } else if (opt == OPT_M32 || opt == OPT_M64) {
-            ret = tcc_tool_cross(argv, opt);
-        } else if (s->verbose)
+            if (!s->verbose)
+                return 0;
+            ++opt;
+        }
+        if (opt == OPT_HELP2) {
+            fputs(help2, stdout);
+            return 0;
+        }
+        if (opt == OPT_M32 || opt == OPT_M64)
+            return tcc_tool_cross(s, argv, opt);
+        if (s->verbose)
             printf("%s", version);
-
         if (opt == OPT_AR)
-            ret = tcc_tool_ar(argc, argv);
+            return tcc_tool_ar(s, argc, argv);
 #ifdef TCC_TARGET_PE
         if (opt == OPT_IMPDEF)
-            ret = tcc_tool_impdef(argc, argv);
+            return tcc_tool_impdef(s, argc, argv);
 #endif
+        if (opt == OPT_V)
+            return 0;
         if (opt == OPT_PRINT_DIRS) {
             /* initialize search dirs */
             set_environment(s);
             tcc_set_output_type(s, TCC_OUTPUT_MEMORY);
             print_search_dirs(s);
+            return 0;
         }
-        if (opt) {
-            if (opt < 0) err:
-                ret = 1;
-            tcc_delete(s);
-            return ret;
-        }
+
         if (s->nb_files == 0) {
             tcc_error_noabort("no input files");
         } else if (s->output_type == TCC_OUTPUT_PREPROCESS) {
@@ -345,7 +345,7 @@
                 tcc_error_noabort("cannot specify output file with -c many files");
         }
         if (s->nb_errors)
-            goto err;
+            return 1;
         if (s->do_bench)
             start_time = getclock_ms();
     }
@@ -419,6 +419,7 @@
         tcc_print_stats(s, end_time - start_time);
 
     tcc_delete(s);
+
     if (!done)
         goto redo;
     if (ppfp && ppfp != stdout)

--- 文件: ./tccdbg.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tccdbg.c	2025-09-27 10:22:27.984982503 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tccdbg.c	2025-07-24 10:06:35.138441557 +0800
@@ -310,14 +310,6 @@
 /* ------------------------------------------------------------------------- */
 /* debug state */
 
-#define N_STR_HASH (251)
-
-struct dwarf_str_hash {
-    int len;
-    unsigned long data_offset;
-    struct dwarf_str_hash *next;
-};
-
 struct _tccdbg {
 
     int last_line_num, new_file;
@@ -328,25 +320,20 @@
     struct _debug_hash {
         int debug_type;
         Sym *type;
-    } *debug_hash_global, *debug_hash_local;
+    } *debug_hash;
 
-    /* store forward structure/unions types */
-    struct _debug_forw_hash {
+    struct _debug_anon_hash {
         Sym *type;
         int n_debug_type;
         int *debug_type;
-    } *debug_forw_hash_global, *debug_forw_hash_local;
+    } *debug_anon_hash;
 
-    int n_debug_hash_global;
-    int n_debug_hash_local;
-    int n_debug_forw_hash_global;
-    int n_debug_forw_hash_local;
+    int n_debug_hash;
+    int n_debug_anon_hash;
 
     struct _debug_info {
         int start;
         int end;
-        int last_debug_hash;
-        int last_debug_forw_hash;
         int n_sym;
         struct debug_sym {
             int type;
@@ -394,9 +381,6 @@
         int base_type_used[N_DEFAULT_DEBUG];
     } dwarf_info;
 
-    struct dwarf_str_hash *dwarf_str[N_STR_HASH];
-    struct dwarf_str_hash *dwarf_line_str[N_STR_HASH];
-
     /* test coverage */
     struct {
         unsigned long offset;
@@ -405,28 +389,23 @@
         int ind;
         int line;
     } tcov_data;
+
 };
 
-#define last_line_num             s1->dState->last_line_num
-#define new_file                  s1->dState->new_file
-#define section_sym               s1->dState->section_sym
-#define debug_next_type           s1->dState->debug_next_type
-#define debug_hash_global         s1->dState->debug_hash_global
-#define debug_hash_local          s1->dState->debug_hash_local
-#define debug_forw_hash_global    s1->dState->debug_forw_hash_global
-#define debug_forw_hash_local     s1->dState->debug_forw_hash_local
-#define n_debug_hash_global       s1->dState->n_debug_hash_global
-#define n_debug_hash_local        s1->dState->n_debug_hash_local
-#define n_debug_forw_hash_global  s1->dState->n_debug_forw_hash_global
-#define n_debug_forw_hash_local   s1->dState->n_debug_forw_hash_local
-#define debug_info                s1->dState->debug_info
-#define debug_info_root           s1->dState->debug_info_root
-#define dwarf_sym                 s1->dState->dwarf_sym
-#define dwarf_line                s1->dState->dwarf_line
-#define dwarf_info                s1->dState->dwarf_info
-#define dwarf_str                 s1->dState->dwarf_str
-#define dwarf_line_str            s1->dState->dwarf_line_str
-#define tcov_data                 s1->dState->tcov_data
+#define last_line_num       s1->dState->last_line_num
+#define new_file            s1->dState->new_file
+#define section_sym         s1->dState->section_sym
+#define debug_next_type     s1->dState->debug_next_type
+#define debug_hash          s1->dState->debug_hash
+#define debug_anon_hash     s1->dState->debug_anon_hash
+#define n_debug_hash        s1->dState->n_debug_hash
+#define n_debug_anon_hash   s1->dState->n_debug_anon_hash
+#define debug_info          s1->dState->debug_info
+#define debug_info_root     s1->dState->debug_info_root
+#define dwarf_sym           s1->dState->dwarf_sym
+#define dwarf_line          s1->dState->dwarf_line
+#define dwarf_info          s1->dState->dwarf_info
+#define tcov_data           s1->dState->tcov_data
 
 #define	FDE_ENCODING        (DW_EH_PE_udata4 | DW_EH_PE_signed | DW_EH_PE_pcrel)
 
@@ -554,74 +533,19 @@
     put_elf_reloca(symtab_section, s, s->data_offset, rel, sym, 0);
 }
 
-static void free_str(struct dwarf_str_hash **str)
-{
-    int i;
-
-    for (i = 0; i < N_STR_HASH; i++) {
-       while (str[i]) {
-           struct dwarf_str_hash *next = str[i]->next;
-
-           tcc_free(str[i]);
-           str[i] = next;
-       }
-    }
-}
-
-static unsigned str_hash(const char *s)
-{
-    unsigned h = 5381;
-
-    while (*s)
-       h += (*s++ & 0xffu) + h * 31;
-    return h;
-}
-
 static void dwarf_string(Section *s, Section *dw, int sym, const char *str)
 {
     TCCState *s1 = s->s1;
-    int len, hash = str_hash(str) % N_STR_HASH;
+    int offset, len;
     char *ptr;
-    struct dwarf_str_hash *new_hash;
-    struct dwarf_str_hash **dw_hash =
-	dw == dwarf_str_section ? dwarf_str : dwarf_line_str;
 
     len = strlen(str) + 1;
-    new_hash = dw_hash[hash];
-    while (new_hash) {
-	if (new_hash->len == len &&
-	    !memcmp(str, dw->data + new_hash->data_offset, len))
-	    break;
-	new_hash = new_hash->next;
-    }
-    if (new_hash == NULL) {
-	unsigned long offset = dw->data_offset;
-
-        new_hash = dw_hash[hash];
-        while (new_hash) {
-	    unsigned long n = new_hash->data_offset + new_hash->len - len;
-
-	    if (new_hash->len > len &&
-	        !memcmp(str, dw->data + n, len)) {
-		offset = n;
-		break;
-	    }
-	    new_hash = new_hash->next;
-        }
-	if (new_hash == NULL) {
-	    ptr = section_ptr_add(dw, len);
-	    memmove(ptr, str, len);
-	}
-	new_hash = (struct dwarf_str_hash *)
-	    tcc_malloc(sizeof(struct dwarf_str_hash));
-	new_hash->len = len;
-	new_hash->data_offset = offset;
-	new_hash->next = dw_hash[hash];
-	dw_hash[hash] = new_hash;
-    }
+    offset = dw->data_offset;
+    ptr = section_ptr_add(dw, len);
+    memmove(ptr, str, len);
     put_elf_reloca(symtab_section, s, s->data_offset, R_DATA_32DW, sym,
-                   PTR_SIZE == 4 ? 0 : new_hash->data_offset);
-    dwarf_data4(s, PTR_SIZE == 4 ? new_hash->data_offset : 0);
+                   PTR_SIZE == 4 ? 0 : offset);
+    dwarf_data4(s, PTR_SIZE == 4 ? offset : 0);
 }
 
 static void dwarf_strp(Section *s, const char *str)
@@ -1107,14 +1031,10 @@
 
         new_file = last_line_num = 0;
         debug_next_type = N_DEFAULT_DEBUG;
-        debug_hash_global = NULL;
-        debug_hash_local = NULL;
-        debug_forw_hash_global = NULL;
-        debug_forw_hash_local = NULL;
-        n_debug_hash_global = 0;
-        n_debug_hash_local = 0;
-        n_debug_forw_hash_global = 0;
-        n_debug_forw_hash_local = 0;
+        debug_hash = NULL;
+        debug_anon_hash = NULL;
+        n_debug_hash = 0;
+        n_debug_anon_hash = 0;
 
         getcwd(buf, sizeof(buf));
 #ifdef _WIN32
@@ -1272,12 +1192,9 @@
     }
 }
 
-static void fix_debug_forw_hash(TCCState *s1, int global, int start);
-
 /* put end of translation unit info */
 ST_FUNC void tcc_debug_end(TCCState *s1)
 {
-
     if (!s1->do_debug || debug_next_type == 0)
         return;
 
@@ -1285,14 +1202,32 @@
         tcc_debug_funcend(s1, 0); /* free stuff in case of errors */
 
     if (s1->dwarf) {
-	int i;
+	int i, j;
 	int start_aranges;
 	unsigned char *ptr;
 	int text_size = text_section->data_offset;
 
 	/* dwarf_info */
-	fix_debug_forw_hash(s1, 0, 0);
-	fix_debug_forw_hash(s1, 1, 0);
+	for (i = 0; i < n_debug_anon_hash; i++) {
+	    Sym *t = debug_anon_hash[i].type;
+	    int pos = dwarf_info_section->data_offset;
+
+	    dwarf_data1(dwarf_info_section,
+                        IS_UNION (t->type.t) ? DWARF_ABBREV_UNION_EMPTY_TYPE
+                                             : DWARF_ABBREV_STRUCTURE_EMPTY_TYPE);
+            dwarf_strp(dwarf_info_section,
+                       (t->v & ~SYM_STRUCT) >= SYM_FIRST_ANOM
+                       ? "" : get_tok_str(t->v, NULL));
+            dwarf_uleb128(dwarf_info_section, 0);
+            dwarf_uleb128(dwarf_info_section, dwarf_line.cur_file);
+            dwarf_uleb128(dwarf_info_section, file->line_num);
+	    for (j = 0; j < debug_anon_hash[i].n_debug_type; j++)
+		write32le(dwarf_info_section->data +
+			  debug_anon_hash[i].debug_type[j],
+			  pos - dwarf_info.start);
+	    tcc_free (debug_anon_hash[i].debug_type);
+	}
+	tcc_free (debug_anon_hash);
 	dwarf_data1(dwarf_info_section, 0);
 	ptr = dwarf_info_section->data + dwarf_info.start;
 	write32le(ptr, dwarf_info_section->data_offset - dwarf_info.start - 4);
@@ -1393,12 +1328,7 @@
         put_stabs_r(s1, NULL, N_SO, 0, 0,
                     text_section->data_offset, text_section, section_sym);
     }
-    free_str (dwarf_str);
-    free_str (dwarf_line_str);
-    tcc_free (debug_forw_hash_global);
-    tcc_free (debug_forw_hash_local);
-    tcc_free(debug_hash_global);
-    tcc_free(debug_hash_local);
+    tcc_free(debug_hash);
     debug_next_type = 0;
 }
 
@@ -1500,8 +1430,6 @@
 		else {
 	            dwarf_line_op(s1, DW_LNS_advance_line);
 		    dwarf_sleb128_op(s1, len_line);
-                    /* advance by nothing */
-	            dwarf_line_op(s1, DWARF_OPCODE_BASE - DWARF_LINE_BASE);
 		}
 	    }
 	}
@@ -1545,36 +1473,6 @@
         put_stabs (s1, str, type, 0, 0, value);
 }
 
-static void fix_debug_forw_hash(TCCState *s1, int global, int start)
-{
-    if (s1->dwarf) {
-        int i, j, n_hash = global
-		    ? n_debug_forw_hash_global : n_debug_forw_hash_local;
-	struct _debug_forw_hash *hash = global
-	  ? debug_forw_hash_global : debug_forw_hash_local;
-
-	for (i = start; i < n_hash; i++) {
-	    Sym *t = hash[i].type;
-	    int pos = dwarf_info_section->data_offset;
-
-	    dwarf_data1(dwarf_info_section,
-                        IS_UNION (t->type.t) ? DWARF_ABBREV_UNION_EMPTY_TYPE
-                                             : DWARF_ABBREV_STRUCTURE_EMPTY_TYPE);
-            dwarf_strp(dwarf_info_section,
-                       (t->v & ~SYM_STRUCT) >= SYM_FIRST_ANOM
-                       ? "" : get_tok_str(t->v, NULL));
-            dwarf_uleb128(dwarf_info_section, 0);
-            dwarf_uleb128(dwarf_info_section, dwarf_line.cur_file);
-            dwarf_uleb128(dwarf_info_section, file->line_num);
-	    for (j = 0; j < hash[i].n_debug_type; j++)
-		write32le(dwarf_info_section->data +
-			  hash[i].debug_type[j],
-			  pos - dwarf_info.start);
-	    tcc_free (hash[i].debug_type);
-	}
-    }
-}
-
 ST_FUNC void tcc_debug_stabn(TCCState *s1, int type, int value)
 {
     if (!s1->do_debug)
@@ -1584,8 +1482,6 @@
             (struct _debug_info *) tcc_mallocz(sizeof (*info));
 
         info->start = value;
-        info->last_debug_hash = n_debug_hash_local;
-        info->last_debug_forw_hash = n_debug_forw_hash_local;
         info->parent = debug_info;
         if (debug_info) {
             if (debug_info->child) {
@@ -1603,172 +1499,110 @@
         debug_info = info;
     }
     else {
-	fix_debug_forw_hash(s1, 0, debug_info->last_debug_forw_hash);
-        n_debug_hash_local = debug_info->last_debug_hash;
-        n_debug_forw_hash_local = debug_info->last_debug_forw_hash;
         debug_info->end = value;
         debug_info = debug_info->parent;
     }
 }
 
-static int check_global(Sym *t)
-{
-    Sym *g = local_stack;
-
-    while (g) {
-	if (t == g)
-	    return 0;
-	g = g->prev;
-    }
-    return 1;
-}
-
 static int tcc_debug_find(TCCState *s1, Sym *t, int dwarf)
 {
-    int i , g = check_global(t);
-    int n_hash, *n_forw_hash;
-    struct _debug_hash *hash;
-    struct _debug_forw_hash **forw_hash;
-
-    if ((t->type.t & VT_BTYPE) == VT_STRUCT && t->c == -1) {
-        forw_hash = g ? &debug_forw_hash_global : &debug_forw_hash_local;
-        n_forw_hash = g ? &n_debug_forw_hash_global : &n_debug_forw_hash_local;
-	for (i = 0; i < *n_forw_hash; i++)
-            if (t == (*forw_hash)[i].type)
+    int i;
+
+    if (!debug_info && dwarf &&
+	(t->type.t & VT_BTYPE) == VT_STRUCT && t->c == -1) {
+	for (i = 0; i < n_debug_anon_hash; i++)
+            if (t == debug_anon_hash[i].type)
 		return 0;
-	*forw_hash = (struct _debug_forw_hash *)
-            tcc_realloc (*forw_hash,
-                         (*n_forw_hash + 1) * sizeof(**forw_hash));
-        (*forw_hash)[*n_forw_hash].n_debug_type = 0;
-        (*forw_hash)[*n_forw_hash].debug_type = NULL;
-        (*forw_hash)[(*n_forw_hash)++].type = t;
+	debug_anon_hash = (struct _debug_anon_hash *)
+            tcc_realloc (debug_anon_hash,
+                         (n_debug_anon_hash + 1) * sizeof(*debug_anon_hash));
+        debug_anon_hash[n_debug_anon_hash].n_debug_type = 0;
+        debug_anon_hash[n_debug_anon_hash].debug_type = NULL;
+        debug_anon_hash[n_debug_anon_hash++].type = t;
 	return 0;
     }
-    hash = g ? debug_hash_global : debug_hash_local;
-    n_hash = g ? n_debug_hash_global : n_debug_hash_local;
-    for (i = 0; i < n_hash; i++)
-        if (t == hash[i].type)
-	    return hash[i].debug_type;
+    for (i = 0; i < n_debug_hash; i++)
+        if (t == debug_hash[i].type)
+	    return debug_hash[i].debug_type;
     return -1;
 }
 
 static int tcc_get_dwarf_info(TCCState *s1, Sym *s);
 
-static void tcc_debug_check_forw(TCCState *s1, Sym *t, int debug_type)
+static void tcc_debug_check_anon(TCCState *s1, Sym *t, int debug_type)
 {
-    if ((t->type.t & VT_BTYPE) == VT_STRUCT && t->type.ref->c == -1) {
-        int i, j, g = check_global(t);
-        int n_forw_hash;
-        struct _debug_forw_hash **forw_hash;
-
-	for (i = g; i <= 1; i++) {
-            forw_hash = i ? &debug_forw_hash_global : &debug_forw_hash_local;
-            n_forw_hash = i ? n_debug_forw_hash_global : n_debug_forw_hash_local;
-	    for (j = 0; j < n_forw_hash; j++)
-                if (t->type.ref == (*forw_hash)[j].type) {
-		    (*forw_hash)[j].debug_type =
-		        tcc_realloc((*forw_hash)[j].debug_type,
-				    ((*forw_hash)[j].n_debug_type + 1) * sizeof(int));
-		    (*forw_hash)[j].debug_type[(*forw_hash)[j].n_debug_type++] =
-		        debug_type;
-		    return;
-                }
-	}
-    }
-}
+    int i;
 
-static void stabs_struct_complete(TCCState *s1, CType *t);
+    if (!debug_info && (t->type.t & VT_BTYPE) == VT_STRUCT && t->type.ref->c == -1)
+	for (i = 0; i < n_debug_anon_hash; i++)
+            if (t->type.ref == debug_anon_hash[i].type) {
+		debug_anon_hash[i].debug_type =
+		    tcc_realloc(debug_anon_hash[i].debug_type,
+				(debug_anon_hash[i].n_debug_type + 1) * sizeof(int));
+		debug_anon_hash[i].debug_type[debug_anon_hash[i].n_debug_type++] =
+		    debug_type;
+            }
+}
 
-ST_FUNC void tcc_debug_fix_forw(TCCState *s1, CType *t)
+ST_FUNC void tcc_debug_fix_anon(TCCState *s1, CType *t)
 {
-    if (!(s1->do_debug & 2))
+    int i, j, debug_type;
+
+    if (!(s1->do_debug & 2) || !s1->dwarf || debug_info)
 	return;
-    if (0 == s1->dwarf) {
-        stabs_struct_complete(s1, t);
-        return;
-    }
-    if ((t->t & VT_BTYPE) == VT_STRUCT && t->ref->c != -1) {
-        int i, j, debug_type, g = check_global(t->ref);
-        int *n_forw_hash;
-        struct _debug_forw_hash **forw_hash;
-        forw_hash = g ? &debug_forw_hash_global : &debug_forw_hash_local;
-        n_forw_hash = g ? &n_debug_forw_hash_global : &n_debug_forw_hash_local;
-	for (i = 0; i < *n_forw_hash; i++)
-	    if (t->ref == (*forw_hash)[i].type) {
-		if (s1->dwarf) {
-		    Sym sym = {0}; sym .type = *t ;
-
-		    debug_type = tcc_get_dwarf_info(s1, &sym);
-		    for (j = 0; j < (*forw_hash)[i].n_debug_type; j++)
-		        write32le(dwarf_info_section->data +
-			          (*forw_hash)[i].debug_type[j],
-			          debug_type - dwarf_info.start);
-		    tcc_free((*forw_hash)[i].debug_type);
-		}
-		(*n_forw_hash)--;
-		for (; i < *n_forw_hash; i++)
-		    (*forw_hash)[i] = (*forw_hash)[i + 1];
+
+    if ((t->t & VT_BTYPE) == VT_STRUCT && t->ref->c != -1)
+	for (i = 0; i < n_debug_anon_hash; i++)
+	    if (t->ref == debug_anon_hash[i].type) {
+		Sym sym = {0}; sym .type = *t ;
+
+		/* Trick to not hash this struct */
+		debug_info = (struct _debug_info *) t;
+		debug_type = tcc_get_dwarf_info(s1, &sym);
+		debug_info = NULL;
+		for (j = 0; j < debug_anon_hash[i].n_debug_type; j++)
+		    write32le(dwarf_info_section->data +
+			      debug_anon_hash[i].debug_type[j],
+			      debug_type - dwarf_info.start);
+		tcc_free(debug_anon_hash[i].debug_type);
+		n_debug_anon_hash--;
+		for (; i < n_debug_anon_hash; i++)
+		    debug_anon_hash[i] = debug_anon_hash[i + 1];
 	    }
-    }
 }
 
 static int tcc_debug_add(TCCState *s1, Sym *t, int dwarf)
 {
     int offset = dwarf ? dwarf_info_section->data_offset : ++debug_next_type;
-    int *n_hash, g = check_global(t);
-    struct _debug_hash **hash;
-
-    hash = g ? &debug_hash_global : &debug_hash_local;
-    n_hash = g ? &n_debug_hash_global : &n_debug_hash_local;
-    *hash = (struct _debug_hash *)
-	tcc_realloc (*hash,
-		     (*n_hash + 1) * sizeof(**hash));
-    (*hash)[*n_hash].debug_type = offset;
-    (*hash)[(*n_hash)++].type = t;
+    debug_hash = (struct _debug_hash *)
+	tcc_realloc (debug_hash,
+		     (n_debug_hash + 1) * sizeof(*debug_hash));
+    debug_hash[n_debug_hash].debug_type = offset;
+    debug_hash[n_debug_hash++].type = t;
     return offset;
 }
 
-static int STRUCT_NODEBUG(Sym *s)
+static void tcc_debug_remove(TCCState *s1, Sym *t)
 {
-    return
-    (s->a.nodebug ||
-     ((s->v & ~SYM_FIELD) >= SYM_FIRST_ANOM &&
-      ((s->type.t & VT_BTYPE) == VT_BYTE ||
-       (s->type.t & VT_BTYPE) == VT_BOOL ||
-       (s->type.t & VT_BTYPE) == VT_SHORT ||
-       (s->type.t & VT_BTYPE) == VT_INT ||
-       (s->type.t & VT_BTYPE) == VT_LLONG)));
-}
-
-static int stabs_struct_find(TCCState *s1, Sym *t, int *p_id)
-{
-    /* A struct/enum has a ref to its type but that type has no ref.
-       So we can (ab)use it for some info.  Here:
-         s->c : stabs type id
-         s->r : already defined in stabs */
-    Sym *s = t->type.ref;
-/*
-    if (s && s->v != (SYM_FIELD|0x00DEBBED)) {
-        tcc_error_noabort("tccdbg: internal error: %s", get_tok_str(t->v, 0));
-        if (p_id)
-            *p_id = 0;
-        return 0;
-    }
-*/
-    if (NULL == p_id)
-        return s && !s->r && t->c >= 0;
-    if (NULL == s) {
-        /* just use global_stack always */
-        s = sym_push2(&global_stack, SYM_FIELD|0x00DEBBED, 0, ++debug_next_type);
-        t->type.ref = s;
-    }
-    *p_id = s->c;
-    if (s->r || t->c < 0) /* already defined or still incomplete */
-        return 0;
-    s->r = 1;
-    return 1;
+    int i;
+
+    for (i = 0; i < n_debug_hash; i++)
+        if (t == debug_hash[i].type) {
+	    n_debug_hash--;
+	    for (; i < n_debug_hash; i++)
+		debug_hash[i] = debug_hash[i+1];
+	}
 }
 
+#define	STRUCT_NODEBUG(s) 			       \
+    (s->a.nodebug ||                           \
+     ((s->v & ~SYM_FIELD) >= SYM_FIRST_ANOM && \
+      ((s->type.t & VT_BTYPE) == VT_BYTE ||    \
+       (s->type.t & VT_BTYPE) == VT_BOOL ||    \
+       (s->type.t & VT_BTYPE) == VT_SHORT ||   \
+       (s->type.t & VT_BTYPE) == VT_INT ||     \
+       (s->type.t & VT_BTYPE) == VT_LLONG)))
+
 static void tcc_get_debug_info(TCCState *s1, Sym *s, CString *result)
 {
     int type;
@@ -1787,8 +1621,12 @@
             break;
     }
     if ((type & VT_BTYPE) == VT_STRUCT) {
+	Sym *e = t;
+
         t = t->type.ref;
-        if (stabs_struct_find(s1, t, &debug_type)) {
+	debug_type = tcc_debug_find(s1, t, 0);
+        if (debug_type == -1) {
+            debug_type = tcc_debug_add(s1, t, 0);
             cstr_new (&str);
             cstr_printf (&str, "%s:T%d=%c%d",
                          (t->v & ~SYM_STRUCT) >= SYM_FIRST_ANOM
@@ -1796,16 +1634,14 @@
                          debug_type,
                          IS_UNION (t->type.t) ? 'u' : 's',
                          t->c);
-
             while (t->next) {
                 int pos, size, align;
+
                 t = t->next;
 		if (STRUCT_NODEBUG(t))
 		    continue;
                 cstr_printf (&str, "%s:",
-                             (t->v & ~SYM_FIELD) >= SYM_FIRST_ANOM
-                             ? "" : get_tok_str(t->v, NULL)
-                             );
+                             get_tok_str(t->v, NULL));
                 tcc_get_debug_info (s1, t, &str);
                 if (t->type.t & VT_BITFIELD) {
                     pos = t->c * 8 + BIT_POS(t->type.t);
@@ -1820,11 +1656,16 @@
             cstr_printf (&str, ";");
             tcc_debug_stabs(s1, str.data, N_LSYM, 0, NULL, 0, 0);
             cstr_free (&str);
+            if (debug_info)
+                tcc_debug_remove(s1, e);
         }
     }
     else if (IS_ENUM(type)) {
         Sym *e = t = t->type.ref;
-        if (stabs_struct_find(s1, t, &debug_type)) {
+
+	debug_type = tcc_debug_find(s1, t, 0);
+	if (debug_type == -1) {
+	    debug_type = tcc_debug_add(s1, t, 0);
             cstr_new (&str);
             cstr_printf (&str, "%s:T%d=e",
                          (t->v & ~SYM_STRUCT) >= SYM_FIRST_ANOM
@@ -1841,6 +1682,8 @@
             cstr_printf (&str, ";");
             tcc_debug_stabs(s1, str.data, N_LSYM, 0, NULL, 0, 0);
             cstr_free (&str);
+            if (debug_info)
+                tcc_debug_remove(s1, e);
 	}
     }
     else if ((type & VT_BTYPE) != VT_FUNC) {
@@ -1851,10 +1694,6 @@
         if (debug_type > N_DEFAULT_DEBUG)
             return;
     }
-
-    if (NULL == result) /* from stabs_struct_complete() */
-        return;
-
     if (n > 0)
         cstr_printf (result, "%d=", ++debug_next_type);
     t = s;
@@ -1879,14 +1718,6 @@
     cstr_printf (result, "%d", debug_type);
 }
 
-static void stabs_struct_complete(TCCState *s1, CType *t)
-{
-    if (stabs_struct_find(s1, t->ref, NULL)) {
-        Sym s = {0}; s.type = *t;
-        tcc_get_debug_info(s1, &s, NULL);
-    }
-}
-
 static int tcc_get_dwarf_info(TCCState *s1, Sym *s)
 {
     int type;
@@ -1976,11 +1807,13 @@
 		if (STRUCT_NODEBUG(e))
 		    continue;
 		type = tcc_get_dwarf_info(s1, e);
-		tcc_debug_check_forw(s1, e, pos_type[i]);
+		tcc_debug_check_anon(s1, e, pos_type[i]);
 		write32le(dwarf_info_section->data + pos_type[i++],
 			  type - dwarf_info.start);
 	    }
 	    tcc_free(pos_type);
+	    if (debug_info)
+		tcc_debug_remove(s1, t);
         }
     }
     else if (IS_ENUM(type)) {
@@ -2021,6 +1854,8 @@
 	    dwarf_data1(dwarf_info_section, 0);
 	    write32le(dwarf_info_section->data + pos_sib,
 		      dwarf_info_section->data_offset - dwarf_info.start);
+	    if (debug_info)
+		tcc_debug_remove(s1, t);
 	}
     }
     else if ((type & VT_BTYPE) != VT_FUNC) {
@@ -2038,7 +1873,7 @@
 	    dwarf_data1(dwarf_info_section, DWARF_ABBREV_BASE_TYPE);
 	    dwarf_uleb128(dwarf_info_section, default_debug[i - 1].size);
 	    dwarf_data1(dwarf_info_section, default_debug[i - 1].encoding);
-	    pstrcpy(name, sizeof name, default_debug[i - 1].name);
+	    strncpy(name, default_debug[i - 1].name, sizeof(name) -1);
 	    *strchr(name, ':') = 0;
 	    dwarf_strp(dwarf_info_section, name);
 	    dwarf_info.base_type_used[i - 1] = debug_type;
@@ -2058,7 +1893,7 @@
 	    dwarf_data1(dwarf_info_section, DWARF_ABBREV_POINTER);
 	    dwarf_data1(dwarf_info_section, PTR_SIZE);
 	    if (last_pos != -1) {
-		tcc_debug_check_forw(s1, e, last_pos);
+		tcc_debug_check_anon(s1, e, last_pos);
 		write32le(dwarf_info_section->data + last_pos,
 			  i - dwarf_info.start);
 	    }
@@ -2080,7 +1915,7 @@
 		retval = i;
 	    dwarf_data1(dwarf_info_section, DWARF_ABBREV_ARRAY_TYPE);
 	    if (last_pos != -1) {
-		tcc_debug_check_forw(s1, e, last_pos);
+		tcc_debug_check_anon(s1, e, last_pos);
 		write32le(dwarf_info_section->data + last_pos,
 			  i - dwarf_info.start);
 	    }
@@ -2115,7 +1950,7 @@
 			t->type.ref->next ? DWARF_ABBREV_SUBROUTINE_TYPE
 					  : DWARF_ABBREV_SUBROUTINE_EMPTY_TYPE);
 	    if (last_pos != -1) {
-		tcc_debug_check_forw(s1, e, last_pos);
+		tcc_debug_check_anon(s1, e, last_pos);
 		write32le(dwarf_info_section->data + last_pos,
 			  i - dwarf_info.start);
 	    }
@@ -2151,7 +1986,7 @@
 	    while (f->next) {
 		f = f->next;
 		type = tcc_get_dwarf_info(s1, f);
-		tcc_debug_check_forw(s1, f, pos_type[i]);
+		tcc_debug_check_anon(s1, f, pos_type[i]);
 	        write32le(dwarf_info_section->data + pos_type[i++],
                           type - dwarf_info.start);
 	    }
@@ -2159,7 +1994,7 @@
         }
         else {
 	    if (last_pos != -1) {
-		tcc_debug_check_forw(s1, e, last_pos);
+		tcc_debug_check_anon(s1, e, last_pos);
 		write32le(dwarf_info_section->data + last_pos,
 			  debug_type - dwarf_info.start);
 	    }
@@ -2211,9 +2046,9 @@
 		}
 		else {
 		    /* param/local */
-                    dwarf_data1(dwarf_info_section, dwarf_sleb128_size((long)s->value) + 1);
+                    dwarf_data1(dwarf_info_section, dwarf_sleb128_size(s->value) + 1);
                     dwarf_data1(dwarf_info_section, DW_OP_fbreg);
-                    dwarf_sleb128(dwarf_info_section, (long)s->value);
+                    dwarf_sleb128(dwarf_info_section, s->value);
 		}
 		tcc_free (s->str);
             }
@@ -2255,16 +2090,14 @@
     }
 }
 
-ST_FUNC void tcc_add_debug_info(TCCState *s1, Sym *s, Sym *e)
+ST_FUNC void tcc_add_debug_info(TCCState *s1, int param, Sym *s, Sym *e)
 {
     CString debug_str;
-    int param;
 
     if (!(s1->do_debug & 2))
         return;
 
     cstr_new (&debug_str);
-    param = !e;
     for (; s != e; s = s->prev) {
         if (!s->v || (s->r & VT_VALMASK) != VT_LOCAL)
             continue;
@@ -2366,7 +2199,7 @@
         dwarf_strp(dwarf_info_section, funcname);
         dwarf_uleb128(dwarf_info_section, dwarf_line.cur_file);
         dwarf_uleb128(dwarf_info_section, dwarf_info.line);
-	tcc_debug_check_forw(s1, sym->type.ref, dwarf_info_section->data_offset);
+	tcc_debug_check_anon(s1, sym->type.ref, dwarf_info_section->data_offset);
         dwarf_data4(dwarf_info_section, n_debug_info - dwarf_info.start);
         dwarf_reloc(dwarf_info_section, section_sym, R_DATA_PTR);
 #if PTR_SIZE == 4
@@ -2423,7 +2256,7 @@
 	dwarf_strp(dwarf_info_section, get_tok_str(sym->v, NULL));
 	dwarf_uleb128(dwarf_info_section, dwarf_line.cur_file);
 	dwarf_uleb128(dwarf_info_section, file->line_num);
-	tcc_debug_check_forw(s1, sym, dwarf_info_section->data_offset);
+	tcc_debug_check_anon(s1, sym, dwarf_info_section->data_offset);
 	dwarf_data4(dwarf_info_section, debug_type - dwarf_info.start);
 	if (sym_bind == STB_GLOBAL)
 	    dwarf_data1(dwarf_info_section, 1);
@@ -2473,7 +2306,7 @@
 	    dwarf_strp(dwarf_info_section, get_tok_str(sym->v, NULL));
 	    dwarf_uleb128(dwarf_info_section, dwarf_line.cur_file);
 	    dwarf_uleb128(dwarf_info_section, file->line_num);
-	    tcc_debug_check_forw(s1, sym, dwarf_info_section->data_offset);
+	    tcc_debug_check_anon(s1, sym, dwarf_info_section->data_offset);
 	    dwarf_data4(dwarf_info_section, debug_type - dwarf_info.start);
 	}
     }
@@ -2481,7 +2314,9 @@
     {
         CString str;
         cstr_new (&str);
-        cstr_printf (&str, "%s:t", get_tok_str(sym->v, NULL));
+        cstr_printf (&str, "%s:t",
+                     (sym->v & ~SYM_FIELD) >= SYM_FIRST_ANOM
+                     ? "" : get_tok_str(sym->v, NULL));
         tcc_get_debug_info(s1, sym, &str);
         tcc_debug_stabs(s1, str.data, N_LSYM, 0, NULL, 0, 0);
         cstr_free (&str);
@@ -2640,19 +2475,13 @@
 #undef new_file
 #undef section_sym
 #undef debug_next_type
-#undef debug_hash_global
-#undef debug_hash_local
-#undef n_debug_hash_global
-#undef n_debug_hash_local
-#undef debug_forw_hash_global
-#undef debug_forw_hash_local
-#undef n_debug_forw_hash_global
-#undef n_debug_forw_hash_local
+#undef debug_hash
+#undef n_debug_hash
+#undef debug_anon_hash
+#undef n_debug_anon_hash
 #undef debug_info
 #undef debug_info_root
 #undef dwarf_sym
 #undef dwarf_line
 #undef dwarf_info
-#undef dwarf_str
-#undef dwarf_line_str
 #undef tcov_data

--- 文件: ./tccelf.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tccelf.c	2025-09-27 10:22:27.984982503 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tccelf.c	2025-07-24 10:06:35.138441557 +0800
@@ -1129,8 +1129,6 @@
 
     qrel = (ElfW_Rel *)sr->data;
     for_each_elem(sr, 0, rel, ElfW_Rel) {
-	if (s->data == NULL) /* bss */
-	    continue;
         ptr = s->data + rel->r_offset;
         sym_index = ELFW(R_SYM)(rel->r_info);
         sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];
@@ -1597,7 +1595,7 @@
 
     s = data_section;
     /* Align to PTR_SIZE */
-    section_add(s, 0, PTR_SIZE);
+    section_ptr_add(s, -s->data_offset & (PTR_SIZE - 1));
     o = s->data_offset;
     /* create a struct rt_context (see tccrun.c) */
     if (s1->dwarf) {
@@ -2803,61 +2801,23 @@
 }
 #endif
 
-#if TARGETOS_OpenBSD || TARGETOS_NetBSD || TARGETOS_FreeBSD
-
-static void fill_bsd_note(Section *s, int type,
-			  const char *value, uint32_t data)
-{
-    unsigned long offset = 0;
-    char *ptr;
-    ElfW(Nhdr) *note;
-    int align = s->sh_addralign;
-
-    /* check if type present */
-    while (offset + sizeof(ElfW(Nhdr)) < s->data_offset) {
-        note = (ElfW(Nhdr) *) (s->data + offset);
-	if (note->n_type == type)
-	    return;
-	offset += (sizeof(ElfW(Nhdr)) + note->n_namesz + note->n_descsz +
-		  align - 1) & -align;
-    }
-    ptr = section_ptr_add(s, sizeof(ElfW(Nhdr)) + 8 + 4);
-    note = (ElfW(Nhdr) *) ptr;
-    note->n_namesz = 8;
-    note->n_descsz = 4;
-    note->n_type = type;
-    strcpy (ptr + sizeof(ElfW(Nhdr)), value);
-    memcpy (ptr + sizeof(ElfW(Nhdr)) + 8, &data, 4);
-}
-
+#if TARGETOS_OpenBSD || TARGETOS_NetBSD
 static Section *create_bsd_note_section(TCCState *s1,
 					const char *name,
 					const char *value)
 {
-    Section *s;
-    unsigned int major = 0, minor = 0, patch = 0;
+    Section *s = find_section (s1, name);
 
-#ifdef CONFIG_OS_RELEASE
-    sscanf(CONFIG_OS_RELEASE, "%u.%u.%u", &major, &minor, &patch);
-#endif
-#if TARGETOS_FreeBSD
-    if (major < 14)
-	return NULL;
-#endif
-    s = find_section (s1, name);
-    s->sh_type = SHT_NOTE;
-#if TARGETOS_OpenBSD
-    fill_bsd_note(s, ELF_NOTE_OS_GNU, value, 0);
-#elif TARGETOS_NetBSD
-    fill_bsd_note(s, 1 /* NT_NETBSD_IDENT_TAG */, value,
-		  major * 100000000u + (minor % 100u) * 1000000u +
-		  (patch % 10000u) * 100u);
-#elif TARGETOS_FreeBSD
-    fill_bsd_note(s, 1 /* NT_FREEBSD_ABI_TAG */, value,
-		  major * 100000u + (minor % 100u) * 1000u);
-    fill_bsd_note(s, 4 /* NT_FREEBSD_FEATURE_CTL */, value, 0);
-    fill_bsd_note(s, 2 /* NT_FREEBSD_NOINIT_TAG */, value, 0);
-#endif
+    if (s->data_offset == 0) {
+        char *ptr = section_ptr_add(s, sizeof(ElfW(Nhdr)) + 8 + 4);
+        ElfW(Nhdr) *note = (ElfW(Nhdr) *) ptr;
+
+        s->sh_type = SHT_NOTE;
+        note->n_namesz = 8;
+        note->n_descsz = 4;
+        note->n_type = ELF_NOTE_OS_GNU;
+	strcpy (ptr + sizeof(ElfW(Nhdr)), value);
+    }
     return s;
 }
 #endif
@@ -2874,6 +2834,7 @@
     int textrel, got_sym, dt_flags_1;
 
     file_type = s1->output_type;
+    s1->nb_errors = 0;
     ret = -1;
     interp = dynstr = dynamic = NULL;
     sec_order = NULL;
@@ -2891,14 +2852,9 @@
     dyninf.note = create_bsd_note_section (s1, ".note.netbsd.ident", "NetBSD");
 #endif
 
-#if TARGETOS_FreeBSD
-    dyninf.note = create_bsd_note_section (s1, ".note.tag", "FreeBSD");
-#endif
-
 #if TARGETOS_FreeBSD || TARGETOS_NetBSD
     dyninf.roinf = NULL;
 #endif
-
         /* if linking, also link in runtime libraries (libc, libgcc, etc.) */
         tcc_add_runtime(s1);
 	resolve_common_syms(s1);
@@ -2980,8 +2936,6 @@
                 put_dt(dynamic, DT_TEXTREL, 0);
             if (file_type & TCC_OUTPUT_EXE)
                 dt_flags_1 = DF_1_NOW | DF_1_PIE;
-	    if (s1->znodelete)
-		dt_flags_1 |= DF_1_NODELETE;
         }
         put_dt(dynamic, DT_FLAGS, DF_BIND_NOW);
         put_dt(dynamic, DT_FLAGS_1, dt_flags_1);
@@ -3071,6 +3025,7 @@
 {
     Section *s;
     int i, ret, file_offset;
+    s1->nb_errors = 0;
     /* Allocate strings for section names */
     alloc_sec_names(s1, 1);
     file_offset = (sizeof (ElfW(Ehdr)) + 3) & -4;
@@ -3089,7 +3044,6 @@
 
 LIBTCCAPI int tcc_output_file(TCCState *s, const char *filename)
 {
-    s->nb_errors = 0;
     if (s->test_coverage)
         tcc_tcov_add_file(s, filename);
     if (s->output_type == TCC_OUTPUT_OBJ)
@@ -3295,19 +3249,21 @@
         s->sh_entsize = sh->sh_entsize;
         sm_table[i].new_section = 1;
     found:
-        size = sh->sh_size;
         /* align start of section */
-        offset = section_add(s, size, sh->sh_addralign);
+        s->data_offset += -s->data_offset & (sh->sh_addralign - 1);
         if (sh->sh_addralign > s->sh_addralign)
             s->sh_addralign = sh->sh_addralign;
-        sm_table[i].offset = offset;
+        sm_table[i].offset = s->data_offset;
         sm_table[i].s = s;
         /* concatenate sections */
-        if (sh->sh_type != SHT_NOBITS && size) {
+        size = sh->sh_size;
+        if (sh->sh_type != SHT_NOBITS) {
             unsigned char *ptr;
             lseek(fd, file_offset + sh->sh_offset, SEEK_SET);
-            ptr = s->data + offset;
+            ptr = section_ptr_add(s, size);
             full_read(fd, ptr, size);
+        } else {
+            s->data_offset += size;
         }
 #if defined TCC_TARGET_ARM || defined TCC_TARGET_ARM64 || defined TCC_TARGET_RISCV64
         /* align code sections to instruction lenght */
@@ -3349,9 +3305,6 @@
         }
     }
 
-    if (!symtab)
-        goto done;
-
     /* resolve symbols */
     old_to_new_syms = tcc_mallocz(nb_syms * sizeof(int));
 
@@ -3447,7 +3400,7 @@
             break;
         }
     }
- done:
+
     ret = 0;
  the_end:
     tcc_free(symtab);
@@ -3984,7 +3937,7 @@
 {
     if (filename[0] == '-' && filename[1] == 'l')
         return tcc_add_library(s1, filename + 2);
-    if (CONFIG_SYSROOT[0] != '\0' || !IS_ABSPATH(filename)) {
+    if (CONFIG_SYSROOT[0] != '\0') {
         /* lookup via library paths */
         int ret = tcc_add_dll(s1, tcc_basename(filename), 0);
         if (ret != FILE_NOT_FOUND)
@@ -4028,19 +3981,19 @@
         } else if (t != LD_TOK_NAME) {
             return tcc_error_noabort("unexpected token '%c'", t);
         } else if (!strcmp(filename, "AS_NEEDED")) {
-            ret |= ld_add_file_list(s1, filename);
+            ret = ld_add_file_list(s1, filename);
         } else if (c == 'I' || c == 'G' || c == 'A') {
-            ret |= !!ld_add_file(s1, filename);
+            ret = ld_add_file(s1, filename);
         }
-        if (ret < 0)
-            return ret;
+        if (ret)
+            return -1;
         t = ld_next(s1, filename, sizeof(filename));
         if (t == ',')
             t = ld_next(s1, filename, sizeof(filename));
     }
-    if (c == 'G' && ret == 0 && new_undef_sym(s1, sym_offset))
+    if (c == 'G' && new_undef_sym(s1, sym_offset))
         goto repeat;
-    return ret;
+    return 0;
 }
 
 /* interpret a subset of GNU ldscripts to handle the dummy libc.so
@@ -4048,7 +4001,7 @@
 ST_FUNC int tcc_load_ldscript(TCCState *s1, int fd)
 {
     char cmd[64];
-    int t, ret = 0, noscript = 1;
+    int t, ret = FILE_NOT_RECOGNIZED;
     unsigned char *text_ptr, *saved_ptr;
 
     saved_ptr = s1->ld_p;
@@ -4059,22 +4012,19 @@
             break;
         if (!strcmp(cmd, "INPUT") ||
             !strcmp(cmd, "GROUP")) {
-            ret |= ld_add_file_list(s1, cmd);
+            ret = ld_add_file_list(s1, cmd);
         } else if (!strcmp(cmd, "OUTPUT_FORMAT") ||
                    !strcmp(cmd, "TARGET")) {
             /* ignore some commands */
-            ret |= ld_add_file_list(s1, cmd);
-        } else if (noscript) {
-            ret = FILE_NOT_RECOGNIZED;
-        } else {
+            ret = ld_add_file_list(s1, cmd);
+        } else if (0 == ret) {
             ret = tcc_error_noabort("unexpected '%s'", cmd);
         }
-        if (ret < 0)
+        if (ret)
             break;
-        noscript = 0;
     }
     tcc_free(text_ptr);
     s1->ld_p = saved_ptr;
-    return ret < 0 ? ret : -ret;
+    return ret;
 }
 #endif /* !ELF_OBJ_ONLY */

--- 文件: ./tccgen.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tccgen.c	2025-09-27 10:22:27.988982522 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tccgen.c	2025-07-24 10:06:35.142441577 +0800
@@ -341,8 +341,8 @@
                   (int)(vtop - vstack + 1));
 }
 
+/* vstack debugging aid */
 #if 0
-/* dump 'b' vstack entries starting with 'a'  */
 void pv (const char *lbl, int a, int b)
 {
     int i;
@@ -352,28 +352,6 @@
             lbl, i, p->type.t, p->r, p->r2, (int)p->c.i);
     }
 }
-
-/* dump symbols on stack from s ... last */
-static inline void psyms(const char *msg, Sym *s, Sym *last)
-{
-    printf("%-8s scope         v        c        r   type.t\n", msg);
-    while (s && s != last) {
-        printf("      %8x  %08x %08x %08x %08x %s\n",
-            s->sym_scope, s->v, s->c, s->r, s->type.t, get_tok_str(s->v, 0));
-        s = s->prev;
-    }
-}
-
-static void type_to_str(char *buf, int buf_size, CType *type, const char *varstr);
-
-/* print type */
-static void ptype(const char *msg, CType *type, int v)
-{
-    char buf[500];
-    type_to_str(buf, sizeof(buf), type,
-        (v & ~SYM_FIELD) ? get_tok_str(v, NULL) : NULL);
-    printf("%s : %s;\n", msg, buf);
-}
 #endif
 
 /* ------------------------------------------------------------------------- */
@@ -528,7 +506,7 @@
             sym_type = STT_FUNC;
         } else if ((t & VT_BTYPE) == VT_VOID) {
             sym_type = STT_NOTYPE;
-            if (IS_ASM_FUNC(t))
+            if ((t & (VT_BTYPE|VT_ASM_FUNC)) == VT_ASM_FUNC)
                 sym_type = STT_FUNC;
         } else {
             sym_type = STT_OBJECT;
@@ -597,18 +575,8 @@
         return;
 
     if (sym) {
-        if (0 == sym->c) {
+        if (0 == sym->c)
             put_extern_sym(sym, NULL, 0, 0);
-            if (sym->sym_scope
-                && (sym->type.t & (VT_STATIC|VT_EXTERN)) == (VT_STATIC|VT_EXTERN)) {
-                /* when a local function declaraion redeclares a global static one
-                   then tccelf would not resolve them to the same symbol. */
-                Sym *s = sym;
-                while (s->prev_tok)
-                    s = s->prev_tok;
-                s->c = sym->c;
-            }
-        }
         c = sym->c;
     }
 
@@ -715,35 +683,20 @@
     return table_ident[v]->sym_identifier;
 }
 
-/* make sym in-/visible to the parser */
-static inline void sym_link(Sym *s, int yes)
+static int sym_scope(Sym *s)
 {
-    TokenSym *ts = table_ident[(s->v & ~SYM_STRUCT) - TOK_IDENT];
-    Sym **ps;
-    if (s->v & SYM_STRUCT)
-        ps = &ts->sym_struct;
-    else
-        ps = &ts->sym_identifier;
-    if (yes) {
-        s->prev_tok = *ps, *ps = s;
-        s->sym_scope = local_scope;
-    } else {
-        *ps = s->prev_tok;
-    }
-}
-
-static inline int sym_scope_ex(Sym *s)
-{
-    /* enums have 'sym_scope' overwritten by 'enum_val' */
-    return IS_ENUM_VAL (s->type.t)
-        ? s->type.ref->sym_scope
-        : s->sym_scope;
+  if (IS_ENUM_VAL (s->type.t))
+    return s->type.ref->sym_scope;
+  else
+    return s->sym_scope;
 }
 
 /* push a given symbol on the symbol stack */
 ST_FUNC Sym *sym_push(int v, CType *type, int r, int c)
 {
     Sym *s, **ps;
+    TokenSym *ts;
+
     if (local_stack)
         ps = &local_stack;
     else
@@ -752,11 +705,20 @@
     s->type.ref = type->ref;
     s->r = r;
     /* don't record fields or anonymous symbols */
-    if ((v & ~SYM_STRUCT) < SYM_FIRST_ANOM) {
+    /* XXX: simplify */
+    if (!(v & SYM_FIELD) && (v & ~SYM_STRUCT) < SYM_FIRST_ANOM) {
         /* record symbol in token array */
-        sym_link(s, 1);
-        if (s->prev_tok && sym_scope_ex(s->prev_tok) == local_scope)
-            tcc_error("redeclaration of '%s'", get_tok_str(s->v, NULL));
+        ts = table_ident[(v & ~SYM_STRUCT) - TOK_IDENT];
+        if (v & SYM_STRUCT)
+            ps = &ts->sym_struct;
+        else
+            ps = &ts->sym_identifier;
+        s->prev_tok = *ps;
+        *ps = s;
+        s->sym_scope = local_scope;
+        if (s->prev_tok && sym_scope(s->prev_tok) == s->sym_scope)
+            tcc_error("redeclaration of '%s'",
+                get_tok_str(v & ~SYM_STRUCT, NULL));
     }
     return s;
 }
@@ -784,7 +746,8 @@
    pop them yet from the list, but do remove them from the token array.  */
 ST_FUNC void sym_pop(Sym **ptop, Sym *b, int keep)
 {
-    Sym *s, *ss;
+    Sym *s, *ss, **ps;
+    TokenSym *ts;
     int v;
 
     s = *ptop;
@@ -792,8 +755,15 @@
         ss = s->prev;
         v = s->v;
         /* remove symbol in token array */
-        if ((v & ~SYM_STRUCT) < SYM_FIRST_ANOM)
-            sym_link(s, 0);
+        /* XXX: simplify */
+        if (!(v & SYM_FIELD) && (v & ~SYM_STRUCT) < SYM_FIRST_ANOM) {
+            ts = table_ident[(v & ~SYM_STRUCT) - TOK_IDENT];
+            if (v & SYM_STRUCT)
+                ps = &ts->sym_struct;
+            else
+                ps = &ts->sym_identifier;
+            *ps = s->prev_tok;
+        }
 	if (!keep)
 	    sym_free(s);
         s = ss;
@@ -1249,9 +1219,6 @@
 
     } else if ((sym->type.t & VT_BTYPE) == VT_FUNC) {
         int static_proto = sym->type.t & VT_STATIC;
-        int ft1 = sym->type.ref->f.func_type;
-        int ft2 = type->ref->f.func_type;
-
         /* warn if static follows non-static function declaration */
         if ((type->t & VT_STATIC) && !static_proto
             /* XXX this test for inline shouldn't be here.  Until we
@@ -1272,14 +1239,15 @@
             struct FuncAttr f = sym->type.ref->f;
             /* put complete type, use static from prototype */
             sym->type.t = (type->t & ~(VT_STATIC|VT_INLINE)) | static_proto;
-            if (ft1 != FUNC_OLD)
-                type->ref->f.func_type = ft1;
             sym->type.ref = type->ref;
             merge_funcattr(&sym->type.ref->f, &f);
         } else {
             sym->type.t &= ~VT_INLINE | static_proto;
-            if (ft1 == FUNC_OLD && ft2 != FUNC_OLD)
-                sym->type.ref = type->ref;
+        }
+
+        if (sym->type.ref->f.func_type == FUNC_OLD
+             && type->ref->f.func_type != FUNC_OLD) {
+            sym->type.ref = type->ref;
         }
 
     } else {
@@ -1316,47 +1284,24 @@
     Sym *s;
     s = sym_malloc(), *s = *s0;
     s->prev = *ps, *ps = s;
-    if ((s->v & ~SYM_STRUCT) < SYM_FIRST_ANOM)
-        sym_link(s, 1);
+    if (s->v < SYM_FIRST_ANOM) {
+        ps = &table_ident[s->v - TOK_IDENT]->sym_identifier;
+        s->prev_tok = *ps, *ps = s;
+    }
     return s;
 }
 
-/* Symbol 's' was locally declared 'extern' (or as function), and is
-   on global_stack.  Now must copy its 'ref' to global_stack too */
-static void move_ref_to_global(Sym *s)
-{
-    Sym *l, **lp;
-    int n, bt;
-
-    bt = s->type.t & VT_BTYPE;
-    if (!(bt == VT_PTR
-       || bt == VT_FUNC
-       || bt == VT_STRUCT
-       || IS_ENUM(s->type.t)))
-        return;
-
-    for (s = s->type.ref, n = 0; s; s = s->next) {
-        for (lp = &local_stack; !!(l = *lp); lp = &l->prev) {
-            if (l == s) {
-                *lp = s->prev;
-                s->prev = global_stack, global_stack = s;
-                if (n || bt == VT_PTR || bt == VT_FUNC) {
-                    move_ref_to_global(s);
-                } else {
-                    if ((s->v & ~SYM_STRUCT) < SYM_FIRST_ANOM) {
-                        /* copy struct/enum tag to local scope */
-                        s->v |= SYM_FIELD;
-                        l = sym_copy(s, lp);
-                        l->v &= ~SYM_FIELD;
-                    }
-                }
-                if (bt != VT_PTR)
-                    n = 1;
-                break;
-            }
+/* copy s->type.ref to stack 'ps' for VT_FUNC and VT_PTR */
+static void sym_copy_ref(Sym *s, Sym **ps)
+{
+    int bt = s->type.t & VT_BTYPE;
+    if (bt == VT_FUNC || bt == VT_PTR || (bt == VT_STRUCT && s->sym_scope)) {
+        Sym **sp = &s->type.ref;
+        for (s = *sp, *sp = NULL; s; s = s->next) {
+            Sym *s2 = sym_copy(s, ps);
+            sp = &(*sp = s2)->next;
+            sym_copy_ref(s2, ps);
         }
-        if (n == 0) /* no next (VT_PTR) or ref not on local_stack */
-            break;
     }
 }
 
@@ -1377,15 +1322,15 @@
         s->a = ad->a;
         s->asm_label = ad->asm_label;
         s->type.ref = type->ref;
+        /* copy type to the global stack */
+        if (local_stack)
+            sym_copy_ref(s, &global_stack);
     } else {
         patch_storage(s, ad, type);
     }
-    if (local_stack) {
-        /* make sure that type->ref is on global stack */
-        move_ref_to_global(s);
-        /* put into local scope */
+    /* push variables on local_stack if any */
+    if (local_stack && (s->type.t & VT_BTYPE) != VT_FUNC)
         s = sym_copy(s, &local_stack);
-    }
     return s;
 }
 
@@ -1429,7 +1374,6 @@
                 l = get_temp_local_var(size, align, &r2);
                 sv.r = VT_LOCAL | VT_LVAL;
                 sv.c.i = l;
-		sv.sym = NULL;
                 store(p->r & VT_VALMASK, &sv);
 #if defined(TCC_TARGET_I386) || defined(TCC_TARGET_X86_64)
                 /* x86 specific: need to pop fp register ST0 if saved */
@@ -1732,15 +1676,16 @@
 }
 #endif
 
-/* add debug info for locals or function parameters, optionally
-   register bounds */
-static void tcc_debug_end_scope(Sym *b, int bounds)
+/* Wrapper around sym_pop, that potentially also registers local bounds.  */
+static void pop_local_syms(Sym *b, int keep)
 {
 #ifdef CONFIG_TCC_BCHECK
-    if (tcc_state->do_bounds_check && bounds)
+    if (tcc_state->do_bounds_check && !keep && (local_scope || !func_var))
         add_local_bounds(local_stack, b);
 #endif
-    tcc_add_debug_info (tcc_state, local_stack, b);
+    if (debug_modes)
+        tcc_add_debug_info (tcc_state, !local_scope, local_stack, b);
+    sym_pop(&local_stack, b, keep);
 }
 
 /* increment an lvalue pointer */
@@ -3013,17 +2958,15 @@
         if (bt2 == VT_LLONG)
           type.t &= t2;
         /* convert to unsigned if it does not fit in a long long */
-        if ((t1 & (VT_BTYPE | VT_UNSIGNED)) == (VT_LLONG | VT_UNSIGNED) ||
-            (t2 & (VT_BTYPE | VT_UNSIGNED)) == (VT_LLONG | VT_UNSIGNED))
+        if ((t1 & (VT_BTYPE | VT_UNSIGNED | VT_BITFIELD)) == (VT_LLONG | VT_UNSIGNED) ||
+            (t2 & (VT_BTYPE | VT_UNSIGNED | VT_BITFIELD)) == (VT_LLONG | VT_UNSIGNED))
           type.t |= VT_UNSIGNED;
     } else {
         /* integer operations */
         type.t = VT_INT | (VT_LONG & (t1 | t2));
         /* convert to unsigned if it does not fit in an integer */
-        if (((t1 & (VT_BTYPE | VT_UNSIGNED)) == (VT_INT | VT_UNSIGNED)
-                && (!(t1 & VT_BITFIELD) || BIT_SIZE(t1) == 32))
-         || ((t2 & (VT_BTYPE | VT_UNSIGNED)) == (VT_INT | VT_UNSIGNED)
-                && (!(t2 & VT_BITFIELD) || BIT_SIZE(t2) == 32)))
+        if ((t1 & (VT_BTYPE | VT_UNSIGNED | VT_BITFIELD)) == (VT_INT | VT_UNSIGNED) ||
+            (t2 & (VT_BTYPE | VT_UNSIGNED | VT_BITFIELD)) == (VT_INT | VT_UNSIGNED))
           type.t |= VT_UNSIGNED;
     }
     if (dest)
@@ -3499,8 +3442,8 @@
             int ts;
             s = type->ref;
             ts = type_size(&s->type, a);
-            if (s->c < 0)
-                return s->c;
+            if (ts < 0 && s->c < 0)
+                ts = -ts;
             return ts * s->c;
         } else {
             *a = PTR_SIZE;
@@ -3825,7 +3768,6 @@
                 sv.type.t = VT_PTRDIFF_T;
                 sv.r = VT_LOCAL | VT_LVAL;
                 sv.c.i = vtop[-1].c.i;
-		sv.sym = NULL;
                 load(r, &sv);
                 vtop[-1].r = r | VT_LVAL;
             }
@@ -3907,14 +3849,10 @@
 {
     int t, n;
     char *astr;
-    AttributeDef ad_tmp;
     
 redo:
     if (tok != TOK_ATTRIBUTE1 && tok != TOK_ATTRIBUTE2)
         return;
-    if (NULL == ad) /* skip over / ignore attributes */
-        ad = &ad_tmp;
-
     next();
     skip('(');
     skip('(');
@@ -4409,15 +4347,6 @@
     }
 }
 
-/* Does 'n' fit into integer type 't' ? */
-static int in_range(long long n, int t)
-{
-    unsigned long long m = (1ULL << (btype_size(t & VT_BTYPE) * 8 - 1)) - 1;
-    if (t & VT_UNSIGNED)
-        return n <= (m << 1) + 1;
-    return n >= -(long long)m - 1 && n <= (long long)m;
-}
-
 /* enum/struct/union declaration. u is VT_ENUM/VT_STRUCT/VT_UNION */
 static void struct_decl(CType *type, int u)
 {
@@ -4485,7 +4414,6 @@
             long long ll = 0, pl = 0, nl = 0;
 	    CType t;
             t.ref = s;
-            s->sym_scope = local_scope; /* anonymous symbol won't have set */
             /* enum symbols have static storage */
             t.t = VT_INT|VT_STATIC|VT_ENUM_VAL;
             if (bt)
@@ -4494,14 +4422,15 @@
                 v = tok;
                 if (v < TOK_UIDENT)
                     expect("identifier");
+                ss = sym_find(v);
+                if (ss && !local_stack)
+                    tcc_error("redefinition of enumerator '%s'",
+                              get_tok_str(v, NULL));
                 next();
                 if (tok == '=') {
                     next();
 		    ll = expr_const64();
                 }
-                if (bt && !in_range(ll, t.t))
-		    tcc_error("enumerator '%s' out of range of its type",
-			get_tok_str(v, NULL));
                 ss = sym_push(v, &t, VT_CONST, 0);
                 ss->enum_val = ll;
                 *ps = ss, ps = &ss->next;
@@ -4578,7 +4507,7 @@
                         	expect("identifier");
                     	    else {
 				int v = btype.ref->v;
-				if ((v & ~SYM_STRUCT) < SYM_FIRST_ANOM) {
+				if (!(v & SYM_FIELD) && (v & ~SYM_STRUCT) < SYM_FIRST_ANOM) {
 				    if (tcc_state->ms_extensions == 0)
                         		expect("identifier");
 				}
@@ -4623,7 +4552,6 @@
                             tcc_error("width of '%s' exceeds its type",
                                   get_tok_str(v, NULL));
                         } else if (bit_size == bsize
-				    && !*tcc_state->pack_stack_ptr
                                     && !ad.a.packed && !ad1.a.packed) {
                             /* no need for bit fields */
                             ;
@@ -4632,7 +4560,7 @@
                         } else {
                             type1.t = (type1.t & ~VT_STRUCT_MASK)
                                 | VT_BITFIELD
-                                | ((unsigned)bit_size << (VT_STRUCT_SHIFT + 6));
+                                | (bit_size << (VT_STRUCT_SHIFT + 6));
                         }
                     }
                     if (v != 0 || (type1.t & VT_BTYPE) == VT_STRUCT) {
@@ -4667,9 +4595,9 @@
 	    check_fields(type, 1);
 	    check_fields(type, 0);
             struct_layout(type, &ad);
+	    if (debug_modes)
+		tcc_debug_fix_anon(tcc_state, type);
         }
-        if (debug_modes)
-            tcc_debug_fix_forw(tcc_state, type);
     }
 }
 
@@ -4901,11 +4829,8 @@
             parse_expr_type(&type1);
             /* remove all storage modifiers except typedef */
             type1.t &= ~(VT_STORAGE&~VT_TYPEDEF);
-            if (type1.ref) {
+	    if (type1.ref)
                 sym_to_attr(ad, type1.ref);
-                if (type1.t & VT_ARRAY)
-                    type1.t |= VT_BT_ARRAY;
-            }
             goto basic_type2;
         case TOK_THREAD_LOCAL:
             tcc_error("_Thread_local is not implemented");
@@ -4930,8 +4855,6 @@
             if (t)
                 parse_btype_qualify(type, t);
             t = type->t;
-            if (t & VT_ARRAY)
-                t |= VT_BT_ARRAY;
             /* get attributes from typedef */
             sym_to_attr(ad, s);
             typespec_found = 1;
@@ -4996,7 +4919,7 @@
 static int post_type(CType *type, AttributeDef *ad, int storage, int td)
 {
     int n, l, t1, arg_size, align;
-    Sym **plast, *s, *first, **ps, *sr;
+    Sym **plast, *s, *first;
     AttributeDef ad1;
     CType pt;
     TokenString *vla_array_tok = NULL;
@@ -5007,20 +4930,11 @@
         next();
 	if (TYPE_DIRECT == (td & (TYPE_DIRECT|TYPE_ABSTRACT)))
 	  return 0;
-
-        /* we push a anonymous symbol which will contain the function prototype */
-        /* it also serves as a boundary for the function parameter scope */
-        ps = local_stack ? &local_stack : &global_stack;
-        ++local_scope;
-        sr = sym_push2(ps, SYM_FIELD, 0, 0);
-
 	if (tok == ')')
 	  l = 0;
 	else if (parse_btype(&pt, &ad1, 0))
 	  l = FUNC_NEW;
 	else if (td & (TYPE_DIRECT|TYPE_ABSTRACT)) {
-            sym_pop(ps, sr->prev, 0);
-            --local_scope;
 	    merge_attr (ad, &ad1);
 	    return 0;
 	} else
@@ -5029,6 +4943,7 @@
         first = NULL;
         plast = &first;
         arg_size = 0;
+        ++local_scope;
         if (l) {
             for(;;) {
                 /* read param name and compute offset */
@@ -5038,11 +4953,11 @@
                     type_decl(&pt, &ad1, &n, TYPE_DIRECT | TYPE_ABSTRACT | TYPE_PARAM);
                     if ((pt.t & VT_BTYPE) == VT_VOID)
                         tcc_error("parameter declared as void");
-                    if (n == 0 || (td & TYPE_PARAM))
-                        n |= SYM_FIELD;
+                    if (n == 0)
+                        n = SYM_FIELD;
                 } else {
                     n = tok;
-                    pt.t = VT_INT | VT_EXTERN; /* default type */
+                    pt.t = VT_VOID; /* invalid type */
                     pt.ref = NULL;
                     next();
                 }
@@ -5051,7 +4966,8 @@
                 convert_parameter_type(&pt);
                 arg_size += (type_size(&pt, &align) + PTR_SIZE - 1) / PTR_SIZE;
                 /* these symbols may be evaluated for VLArrays (see below, under
-                   nocode_wanted) Example: int func(int a, int b[++a]); */
+                   nocode_wanted) which is why we push them here as normal symbols
+                   temporarily.  Example: int func(int a, int b[++a]); */
                 s = sym_push(n, &pt, VT_LOCAL|VT_LVAL, 0);
                 *plast = s;
                 plast = &s->next;
@@ -5070,6 +4986,13 @@
             /* if no parameters, then old type prototype */
             l = FUNC_OLD;
         skip(')');
+        /* remove parameter symbols from token table, keep on stack */
+        if (first) {
+            sym_pop(local_stack ? &local_stack : &global_stack, first->prev, 1);
+            for (s = first; s; s = s->next)
+                s->v |= SYM_FIELD;
+        }
+        --local_scope;
         /* NOTE: const is ignored in returned type as it has a special
            meaning in gcc / C++ */
         type->t &= ~VT_CONSTANT; 
@@ -5081,18 +5004,15 @@
             skip(']'); /* only handle simple "[]" */
             mk_pointer(type);
         }
+        /* we push a anonymous symbol which will contain the function prototype */
         ad->f.func_args = arg_size;
         ad->f.func_type = l;
-        sr->type = *type, s = sr;
+        s = sym_push(SYM_FIELD, type, 0, 0);
         s->a = ad->a;
         s->f = ad->f;
         s->next = first;
         type->t = VT_FUNC;
         type->ref = s;
-        /* unlink parameter symbols from the token table, keep on stack */
-        sym_pop(ps, sr, 1);
-        --local_scope;
-
     } else if (tok == '[') {
 	int saved_nocode_wanted = nocode_wanted;
         /* array definition */
@@ -5690,8 +5610,6 @@
 	       as statement expressions can't ever be entered from the
 	       outside, so any reactivation of code emission (from labels
 	       or loop heads) can be disabled again after the end of it. */
-            /* default return value is (void) */
-            vpushi(0), vtop->type.t = VT_VOID;
             block(STMT_EXPR);
             /* If the statement expr can be entered, then we retain the current
                nocode_wanted state (from e.g. a 'return 0;' in the stmt-expr).
@@ -6021,10 +5939,13 @@
 		    learn = 1;
 		next();
 	    } else {
-		int v;
-		parse_btype(&type, &ad, 0);
-		type_decl(&type, &ad, &v, TYPE_ABSTRACT);
-		if (compare_types(&controlling_type, &type, 0)) {
+	        AttributeDef ad_tmp;
+		int itmp;
+	        CType cur_type;
+
+		parse_btype(&cur_type, &ad_tmp, 0);
+		type_decl(&cur_type, &ad_tmp, &itmp, TYPE_ABSTRACT);
+		if (compare_types(&controlling_type, &cur_type, 0)) {
 		    if (has_match) {
 		      tcc_error("type match twice");
 		    }
@@ -6783,16 +6704,11 @@
             /* returning structure packed into registers */
             int size, addr, align, rc, n;
             size = type_size(func_type,&align);
-            if (ret_nregs * regsize > size ||
-		((align & (ret_align - 1))
-                 && ((vtop->r & VT_VALMASK) < VT_CONST /* pointer to struct */
-                     || (vtop->c.i & (ret_align - 1))
-                     ))) {
-		if (ret_nregs * regsize > size)
-		    size = ret_nregs * regsize;
-		if (ret_align > align)
-		    align = ret_align;
-                loc = (loc - size) & -align;
+            if ((align & (ret_align - 1))
+                && ((vtop->r & VT_VALMASK) < VT_CONST /* pointer to struct */
+                    || (vtop->c.i & (ret_align - 1))
+                    )) {
+                loc = (loc - size) & -ret_align;
                 addr = loc;
                 type = *func_type;
                 vset(&type, VT_LOCAL | VT_LVAL, addr);
@@ -6923,15 +6839,15 @@
 /* ------------------------------------------------------------------------- */
 /* __attribute__((cleanup(fn))) */
 
-/* protect symbol lvalues from further modification  */
-static void save_lvalues(void)
+/* save SValue of symbol to local stack */
+static void save_cleanup_sym(Sym *s)
 {
     SValue *sv = vtop;
     while (sv >= vstack) {
-        if (sv->sym && (sv->r & VT_LVAL)) {
+        if (sv->sym == s) {
             int align, size = type_size(&sv->type, &align);
-            int r2, l = get_temp_local_var(size, align, &r2);
-            vset(&sv->type, VT_LOCAL | VT_LVAL, l), vtop->r2 = r2;
+            loc = (loc - size) & -align;
+            vset(&sv->type, VT_LOCAL | VT_LVAL, loc);
             vpushv(sv), *sv = vtop[-1], vstore(), --vtop;
         }
         --sv;
@@ -6943,8 +6859,8 @@
     Sym *cls = cur_scope->cl.s;
     for (; cls != stop; cls = cls->next) {
 	Sym *fs = cls->cleanup_func;
-	Sym *vs = cls->cleanup_sym;
-	save_lvalues();
+	Sym *vs = cls->prev_tok;
+        save_cleanup_sym(vs);
 	vpushsym(&fs->type, fs);
 	vset(&vs->type, vs->r, vs->c);
 	vtop->sym = vs;
@@ -6954,7 +6870,6 @@
     }
 }
 
-
 static void try_call_cleanup_goto(Sym *cleanupstate)
 {
     Sym *oc, *cc;
@@ -6981,7 +6896,7 @@
     int jmp = 0;
     Sym *g, **pg;
     for (pg = &pending_gotos; (g = *pg) && g->c > o->cl.n;) {
-        if (g->cleanup_label->r & LABEL_FORWARD) {
+        if (g->prev_tok->r & LABEL_FORWARD) {
             Sym *pcl = g->next;
             if (!jmp)
                 jmp = gjmp(0);
@@ -7045,9 +6960,6 @@
     if (o->cl.s != o->prev->cl.s)
         block_cleanup(o->prev);
 
-    if (debug_modes)
-        tcc_debug_end_scope(o->lstk, !is_expr);
-
     /* pop locally defined labels */
     label_pop(&local_label_stack, o->llstk, is_expr);
 
@@ -7060,7 +6972,7 @@
        tables, though.  sym_pop will do that.  */
 
     /* pop locally defined symbols */
-    sym_pop(&local_stack, o->lstk, is_expr);
+    pop_local_syms(o->lstk, is_expr);
     cur_scope = o->prev;
     --local_scope;
 }
@@ -7108,37 +7020,18 @@
     }
 }
 
-static void condition_expresion(void)
-{
-    Sym *s;
-    int decl_ret;
-
-    /* c2y if init decl? */
-    if (!(decl_ret = decl(VT_JMPI))) {
-        /* no, regular if init expr */
-        gexpr();
-    } else {
-	if (decl_ret == 1)
-	    tcc_error("declaration in the controlling expression must have an initializer");
-
-        if (tok == ';') {
-            /* finish the push */
-            next();
-            gexpr();
-        } else {
-            s = sym_find(decl_ret);
-            vset(&s->type, s->r, s->c);
-            vtop->sym = s;
-        }
-    }
-}
-
 static void block(int flags)
 {
     int a, b, c, d, e, t;
     struct scope o;
     Sym *s;
 
+    if (flags & STMT_EXPR) {
+        /* default return value is (void) */
+        vpushi(0);
+        vtop->type.t = VT_VOID;
+    }
+
 again:
     t = tok;
     /* If the token carries a value, next() might destroy it. Only with
@@ -7153,9 +7046,9 @@
     if (t == TOK_IF) {
         new_scope_s(&o);
         skip('(');
-        condition_expresion();
-        a = gvtst(1, 0);
+        gexpr();
         skip(')');
+        a = gvtst(1, 0);
         block(0);
         if (tok == TOK_ELSE) {
             d = gjmp(0);
@@ -7173,8 +7066,8 @@
         d = gind();
         skip('(');
         gexpr();
-        a = gvtst(1, 0);
         skip(')');
+        a = gvtst(1, 0);
         b = 0;
         lblock(&a, &b);
         gjmp_addr(d);
@@ -7202,6 +7095,8 @@
         while (tok != '}') {
 	    decl(VT_LOCAL);
             if (tok != '}') {
+                if (flags & STMT_EXPR)
+                    vpop();
                 block(flags | STMT_COMPOUND);
             }
         }
@@ -7303,9 +7198,9 @@
         skip(TOK_WHILE);
         skip('(');
 	gexpr();
-        c = gvtst(0, 0);
         skip(')');
         skip(';');
+	c = gvtst(0, 0);
 	gsym_addr(c, d);
         gsym(a);
         prev_scope_s(&o);
@@ -7322,10 +7217,10 @@
 
         new_scope_s(&o);
         skip('(');
-        condition_expresion();
+        gexpr();
+        skip(')');
         if (!is_integer_btype(vtop->type.t & VT_BTYPE))
             tcc_error("switch value not an integer");
-        skip(')');
         sw->sv = *vtop--; /* save switch value */
         a = 0;
         b = gjmp(0); /* jump to first case */
@@ -7403,7 +7298,7 @@
 		/* start new goto chain for cleanups, linked via label->next */
 		if (cur_scope->cl.s && !nocode_wanted) {
                     sym_push2(&pending_gotos, SYM_FIELD, 0, cur_scope->cl.n);
-                    pending_gotos->cleanup_label = s;
+                    pending_gotos->prev_tok = s;
                     s = sym_push2(&s->next, SYM_FIELD, 0, 0);
                     pending_gotos->next = s;
                 }
@@ -7445,9 +7340,11 @@
             s->cleanupstate = cur_scope->cl.s;
 
     block_after_label:
-            /* Accept attributes after labels (e.g. 'unused') */
-            parse_attribute(NULL);
-
+              {
+                /* Accept attributes after labels (e.g. 'unused') */
+                AttributeDef ad_tmp;
+                parse_attribute(&ad_tmp);
+              }
             if (debug_modes)
                 tcc_tcov_reset_ind(tcc_state);
             vla_restore(cur_scope->vla.loc);
@@ -7613,7 +7510,7 @@
     if (ref == p->flex_array_ref) {
         if (index >= ref->c)
             ref->c = index + 1;
-    } else if (ref->c < 0 && index >= 0)
+    } else if (ref->c < 0)
         tcc_error("flexible array has zero size in this context");
 }
 
@@ -8072,7 +7969,7 @@
             /* GNU extension: if the initializer is empty for a flex array,
                it's size is zero.  We won't enter the loop, so set the size
                now.  */
-            decl_design_flex(p, s, len - 1);
+            decl_design_flex(p, s, len);
 	    while (tok != '}' || (flags & DIF_HAVE_ELEM)) {
 		len = decl_designator(p, type, c, &f, flags, len);
 		flags &= ~DIF_HAVE_ELEM;
@@ -8167,32 +8064,20 @@
    is put in the value stack. If 'has_init' is 2, a special parsing
    is done to handle string constants. */
 static void decl_initializer_alloc(CType *type, AttributeDef *ad, int r, 
-                                   int has_init, int v, int scope)
+                                   int has_init, int v, int global)
 {
     int size, align, addr;
     TokenString *init_str = NULL;
 
     Section *sec;
     Sym *flexible_array;
-    Sym *sym = NULL;
+    Sym *sym;
     int saved_nocode_wanted = nocode_wanted;
 #ifdef CONFIG_TCC_BCHECK
     int bcheck = tcc_state->do_bounds_check && !NODATA_WANTED;
 #endif
     init_params p = {0};
 
-    if (scope == VT_CONST) {
-        /* see if a global symbol was already defined */
-        sym = sym_find(v);
-        if (sym) {
-            patch_storage(sym, ad, type);
-            /* we accept several definitions of the same global variable. */
-            if (!has_init && sym->c && elfsym(sym)->st_shndx != SHN_UNDEF)
-                return;
-            type = &sym->type;
-        }
-    }
-
     /* Always allocate static or global variables */
     if (v && (r & VT_VALMASK) == VT_CONST)
         nocode_wanted |= DATA_ONLY_WANTED;
@@ -8208,13 +8093,12 @@
         // (arrays of incomplete types are handled in array parsing)
         if (!(type->t & VT_ARRAY))
             tcc_error("initialization of incomplete type");
-        /* If the base type itself was an array type of unspecified
-           size (like in 'typedef int arr[]; arr x = {1};') then
-           we will overwrite the unknown size by the real one for
-           this decl.  We need to unshare the ref symbol holding
-           that size.  */
-        if (type->t & VT_BT_ARRAY)
-            type->ref = sym_push(SYM_FIELD, &type->ref->type, 0, type->ref->c);
+
+        /* If the base type itself was an array type of unspecified size
+           (like in 'typedef int arr[]; arr x = {1};') then we will
+           overwrite the unknown size by the real one for this decl.
+           We need to unshare the ref symbol holding that size. */
+        type->ref = sym_push(SYM_FIELD, &type->ref->type, 0, type->ref->c);
         p.flex_array_ref = type->ref;
 
     } else if (has_init && (type->t & VT_BTYPE) == VT_STRUCT) {
@@ -8232,8 +8116,8 @@
 
     if (size < 0) {
         /* If unknown size, do a dry-run 1st pass */
-        if (!has_init)
-            goto err_size;
+        if (!has_init) 
+            tcc_error("unknown type size");
         if (has_init == 2) {
             /* only get strings */
             init_str = tok_str_alloc();
@@ -8256,8 +8140,7 @@
 
         /* if still unknown size, error */
         size = type_size(type, &align);
-        if (size < 0)
-    err_size:
+        if (size < 0) 
             tcc_error("unknown type size");
 
         /* If there's a flex member and it was used in the initializer
@@ -8309,7 +8192,7 @@
 	    if (ad->cleanup_func) {
 		Sym *cls = sym_push2(&all_cleanups,
                     SYM_FIELD | ++cur_scope->cl.n, 0, 0);
-		cls->cleanup_sym = sym;
+		cls->prev_tok = sym;
 		cls->cleanup_func = ad->cleanup_func;
 		cls->next = cur_scope->cl.s;
 		cur_scope->cl.s = cls;
@@ -8321,6 +8204,26 @@
             vset(type, r, addr);
         }
     } else {
+	sym = NULL;
+        if (v && global) {
+            /* see if the symbol was already defined */
+            sym = sym_find(v);
+            if (sym) {
+                if (p.flex_array_ref && (sym->type.t & type->t & VT_ARRAY)
+                    && sym->type.ref->c > type->ref->c) {
+                    /* flex array was already declared with explicit size
+                            extern int arr[10];
+                            int arr[] = { 1,2,3 }; */
+                    type->ref->c = sym->type.ref->c;
+                    size = type_size(type, &align);
+                }
+                patch_storage(sym, ad, type);
+                /* we accept several definitions of the same global variable. */
+                if (!has_init && sym->c && elfsym(sym)->st_shndx != SHN_UNDEF)
+                    goto no_alloc;
+            }
+        }
+
         /* allocate symbol in corresponding section */
         sec = ad->section;
         if (!sec) {
@@ -8381,9 +8284,6 @@
     if (type->t & VT_VLA) {
         int a;
 
-        if (has_init)
-            tcc_error("variable length array cannot be initialized");
-
         if (NODATA_WANTED)
             goto no_alloc;
 
@@ -8466,37 +8366,11 @@
             func_vla_arg_code(arg->type.ref);
 }
 
-/* set the local stack address for function parameter from gfunc_prolog() */
-ST_FUNC Sym *gfunc_set_param(Sym *s, int c, int byref)
-{
-    s = sym_find(s->v);
-    if (!s) /* unnamed parameters, not enabled */
-        return NULL;
-    s->c = c;
-    if (byref)
-        s->r = VT_LLOCAL | VT_LVAL; /* otherwise VT_LOCAL */
-    return s;
-}
-
-/* push parameters (and their types), last first */
-static void sym_push_params(Sym *ref)
-{
-    Sym *s = ref;
-    while (s->next)
-        s = s->next;
-    while (s != ref) {
-        if ((s->v & ~SYM_STRUCT) < SYM_FIRST_ANOM)
-            sym_copy(s, &local_stack);
-        s = s->prev;
-    }
-}
-
 /* parse a function defined by symbol 'sym' and generate its code in
    'cur_text_section' */
 static void gen_function(Sym *sym)
 {
     struct scope f = { 0 };
-
     cur_scope = root_scope = &f;
     nocode_wanted = 0;
 
@@ -8525,21 +8399,20 @@
 
     /* push a dummy symbol to enable local sym storage */
     sym_push2(&local_stack, SYM_FIELD, 0, 0);
-    /* push parameters */
-    local_scope = 1;
-    sym_push_params(sym->type.ref);
-
-    local_scope = 0;
-    rsym = 0;
+    local_scope = 1; /* for function parameters */
     nb_temp_local_vars = 0;
-
     gfunc_prolog(sym);
     tcc_debug_prolog_epilog(tcc_state, 0);
+
+    local_scope = 0;
+    rsym = 0;
     func_vla_arg(sym);
     block(0);
     gsym(rsym);
+
     nocode_wanted = 0;
-    tcc_debug_end_scope(NULL, !func_var);
+    /* reset local stack */
+    pop_local_syms(NULL, 0);
     tcc_debug_prolog_epilog(tcc_state, 1);
     gfunc_epilog();
 
@@ -8548,12 +8421,11 @@
 
     /* patch symbol size */
     elfsym(sym)->st_size = ind - func_ind;
-    cur_text_section->data_offset = ind;
 
-    sym_pop(&local_stack, NULL, 0);
+    cur_text_section->data_offset = ind;
+    local_scope = 0;
     label_pop(&global_label_stack, NULL, 0);
     sym_pop(&all_cleanups, NULL, 0);
-    local_scope = 0;
 
     /* It's better to crash than to generate wrong code */
     cur_text_section = NULL;
@@ -8631,37 +8503,14 @@
     skip(';');
 }
 
-#ifdef TCC_TARGET_PE
-static void pe_check_linkage(CType *type, AttributeDef *ad)
-{
-    if (!ad->a.dllimport && !ad->a.dllexport)
-        return;
-    if (type->t & VT_STATIC)
-        tcc_error("cannot have dll linkage with static");
-    if (type->t & VT_TYPEDEF) {
-        const char *m = ad->a.dllimport ? "im" : "ex";
-        tcc_warning("'dll%sport' attribute ignored for typedef", m);
-        ad->a.dllimport = 0;
-        ad->a.dllexport = 0;
-    } else if (ad->a.dllimport) {
-        if ((type->t & VT_BTYPE) == VT_FUNC)
-            ad->a.dllimport = 0;
-        else
-            type->t |= VT_EXTERN;
-    }
-}
-#endif
-
 /* 'l' is VT_LOCAL or VT_CONST to define default storage type
    or VT_CMP if parsing old style parameter list
-   or VT_JMP if parsing c99 for decl: for (int i = 0, ...)
-   or VT_JMPI if parsing c2y if decl; if (int = 0; ...)
-*/
+   or VT_JMP if parsing c99 for decl: for (int i = 0, ...) */
 static int decl(int l)
 {
     int v, has_init, r, oldint;
     CType type, btype;
-    Sym *sym, *sa;
+    Sym *sym;
     AttributeDef ad, adbase;
     ElfSym *esym;
 
@@ -8669,7 +8518,7 @@
 
         oldint = 0;
         if (!parse_btype(&btype, &adbase, l == VT_LOCAL)) {
-            if (l == VT_JMP || l == VT_JMPI)
+            if (l == VT_JMP)
                 return 0;
             /* skip redundant ';' if not in old parameter decl scope */
             if (tok == ';' && l != VT_CMP) {
@@ -8700,25 +8549,30 @@
         }
 
         if (tok == ';') {
-            if ((btype.t & VT_BTYPE) == VT_STRUCT
-                && (btype.ref->v & ~SYM_STRUCT) < SYM_FIRST_ANOM)
-                ; /* struct decl with named tag */
-            else if (IS_ENUM(btype.t))
-                ; /* enum decl */
-            else
-                tcc_warning("useless type defines no instances");
-            if (l == VT_JMP)
-                return 1;
-            next();
-            continue;
+	    if ((btype.t & VT_BTYPE) == VT_STRUCT) {
+		v = btype.ref->v;
+		if (!(v & SYM_FIELD) && (v & ~SYM_STRUCT) >= SYM_FIRST_ANOM)
+        	    tcc_warning("unnamed struct/union that defines no instances");
+                next();
+                continue;
+	    }
+            if (IS_ENUM(btype.t)) {
+                next();
+                continue;
+            }
         }
 
         while (1) { /* iterate thru each declaration */
             type = btype;
 	    ad = adbase;
             type_decl(&type, &ad, &v, TYPE_DIRECT);
-            /*ptype("decl", &type, v);*/
-
+#if 0
+            {
+                char buf[500];
+                type_to_str(buf, sizeof(buf), &type, get_tok_str(v, NULL));
+                printf("type = '%s'\n", buf);
+            }
+#endif
             if ((type.t & VT_BTYPE) == VT_FUNC) {
                 if ((type.t & VT_STATIC) && (l != VT_CONST))
                     tcc_error("function without file scope cannot be static");
@@ -8727,10 +8581,9 @@
                 sym = type.ref;
                 if (sym->f.func_type == FUNC_OLD && l == VT_CONST) {
                     func_vt = type;
-		    ++local_scope;
                     decl(VT_CMP);
-		    --local_scope;
                 }
+
                 if ((type.t & (VT_EXTERN|VT_INLINE)) == (VT_EXTERN|VT_INLINE)) {
                     /* always_inline functions must be handled as if they
                        don't generate multiple global defs, even if extern
@@ -8759,7 +8612,20 @@
             }
 
 #ifdef TCC_TARGET_PE
-            pe_check_linkage(&type, &ad);
+            if (ad.a.dllimport || ad.a.dllexport) {
+                if (type.t & VT_STATIC)
+                    tcc_error("cannot have dll linkage with static");
+                if (type.t & VT_TYPEDEF) {
+                    tcc_warning("'%s' attribute ignored for typedef",
+                        ad.a.dllimport ? (ad.a.dllimport = 0, "dllimport") :
+                        (ad.a.dllexport = 0, "dllexport"));
+                } else if (ad.a.dllimport) {
+                    if ((type.t & VT_BTYPE) == VT_FUNC)
+                        ad.a.dllimport = 0;
+                    else
+                        type.t |= VT_EXTERN;
+                }
+            }
 #endif
             if (tok == '{') {
                 if (l != VT_CONST)
@@ -8767,23 +8633,23 @@
                 if ((type.t & VT_BTYPE) != VT_FUNC)
                     expect("function definition");
 
+                /* reject abstract declarators in function definition
+                   make old style params without decl have int type */
+                sym = type.ref;
+                while ((sym = sym->next) != NULL) {
+                    if (!(sym->v & ~SYM_FIELD))
+                        expect("identifier");
+                    if (sym->type.t == VT_VOID)
+                        sym->type = int_type;
+                }
+
                 /* apply post-declaraton attributes */
                 merge_funcattr(&type.ref->f, &ad.f);
+
                 /* put function symbol */
                 type.t &= ~VT_EXTERN;
                 sym = external_sym(v, &type, 0, &ad);
 
-                /* reject abstract declarators in function definition
-                   make old-style float params double */
-                for (sa = sym->type.ref; (sa = sa->next) != NULL;) {
-                    if (!(sa->v & ~SYM_FIELD))
-                        expect("identifier");
-                    if (sa->type.t == VT_FLOAT
-                        && sym->type.ref->f.func_type == FUNC_OLD) {
-                        sa->type.t = VT_DOUBLE;
-                    }
-                }
-
                 /* static inline functions are just recorded as a kind
                    of macro. Their code will be emitted at the end of
                    the compilation unit only if they are used */
@@ -8806,7 +8672,6 @@
                 }
                 break;
             } else {
-                has_init = 0;
 		if (l == VT_CMP) {
 		    /* find parameter in function parameter list */
 		    for (sym = func_vt.ref->next; sym; sym = sym->next)
@@ -8818,7 +8683,7 @@
 		    if (type.t & VT_STORAGE) /* 'register' is okay */
 		        tcc_error("storage class specified for '%s'",
 				  get_tok_str(v, NULL));
-		    if (!(sym->type.t & VT_EXTERN))
+		    if (sym->type.t != VT_VOID)
 		        tcc_error("redefinition of parameter '%s'",
 				  get_tok_str(v, NULL));
 		    convert_parameter_type(&type);
@@ -8854,9 +8719,9 @@
                         /* not lvalue if array */
                         r |= VT_LVAL;
                     }
-
-                    if (tok == '=')
-                        has_init = 1;
+                    has_init = (tok == '=');
+                    if (has_init && (type.t & VT_VLA))
+                        tcc_error("variable length array cannot be initialized");
 
                     if (((type.t & VT_EXTERN) && (!has_init || l != VT_CONST))
 		        || (type.t & VT_BTYPE) == VT_FUNC
@@ -8873,13 +8738,12 @@
                             r |= VT_CONST;
                         else
                             r |= VT_LOCAL;
-                        type.t &= ~VT_EXTERN;
                         if (has_init)
                             next();
                         else if (l == VT_CONST)
                             /* uninitialized global variables may be overridden */
                             type.t |= VT_EXTERN;
-                        decl_initializer_alloc(&type, &ad, r, has_init, v, l);
+                        decl_initializer_alloc(&type, &ad, r, has_init, v, l == VT_CONST);
                     }
 
                     if (ad.alias_target && l == VT_CONST) {
@@ -8896,12 +8760,10 @@
                     }
                 }
                 if (tok != ',') {
-                    if (l == VT_JMP || l == VT_JMPI)
-                        return has_init ? v : 1;
+                    if (l == VT_JMP)
+                        return 1;
                     skip(';');
                     break;
-                } else if (l == VT_JMPI) {
-                    tcc_error("declaration in condition can only declare a single object");
                 }
                 next();
             }

--- 文件: ./tcc.h ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tcc.h	2025-09-27 10:22:27.980982485 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tcc.h	2025-07-24 10:06:35.138441557 +0800
@@ -96,12 +96,8 @@
 #endif
 
 #ifndef offsetof
-#ifdef __clang__ // clang -fsanitize compains about: NULL+value
-#define offsetof(type, field) __builtin_offsetof(type, field)
-#else
 #define offsetof(type, field) ((size_t) &((type *)0)->field)
 #endif
-#endif
 
 #ifndef countof
 #define countof(tab) (sizeof(tab) / sizeof((tab)[0]))
@@ -552,17 +548,13 @@
     CType type; /* associated type */
     union {
         struct Sym *next; /* next related symbol (for fields and anoms) */
-        int *e; /* expanded token stream with preprocessor macros */
+        int *e; /* expanded token stream */
         int asm_label; /* associated asm label */
         struct Sym *cleanupstate; /* in defined labels */
         int *vla_array_str; /* vla array code */
     };
     struct Sym *prev; /* prev symbol in stack */
-    union {
-        struct Sym *prev_tok; /* previous symbol for this token */
-        struct Sym *cleanup_sym; /* symbol from __attribute__((cleanup())) */
-        struct Sym *cleanup_label; /* label in 'pending_gotos' chain */
-    };
+    struct Sym *prev_tok; /* previous symbol for this token */
 } Sym;
 
 /* section definition */
@@ -744,7 +736,6 @@
     unsigned char static_link; /* if true, static linking is performed */
     unsigned char rdynamic; /* if true, all symbols are exported */
     unsigned char symbolic; /* if true, resolve symbols in the current module first */
-    unsigned char znodelete; /* Set DF_1_NODELETE in dynamic section */
     unsigned char filetype; /* file type for compilation (NONE,C,ASM) */
     unsigned char optimize; /* only to #define __OPTIMIZE__ */
     unsigned char option_pthread; /* -pthread option */
@@ -1091,13 +1082,9 @@
 #define VT_TYPE (~(VT_STORAGE|VT_STRUCT_MASK))
 
 /* symbol was created by tccasm.c first */
-#define VT_ASM (VT_VOID | 4 << VT_STRUCT_SHIFT)
-#define VT_ASM_FUNC (VT_VOID | 5 << VT_STRUCT_SHIFT)
-#define IS_ASM_SYM(sym) (((sym)->type.t & ((VT_BTYPE|VT_STRUCT_MASK) & ~(1<<VT_STRUCT_SHIFT))) == VT_ASM)
-#define IS_ASM_FUNC(t) ((t & (VT_BTYPE|VT_STRUCT_MASK)) == VT_ASM_FUNC)
-
-/* base type is array (from typedef/typeof) */
-#define VT_BT_ARRAY (6 << VT_STRUCT_SHIFT)
+#define VT_ASM (VT_VOID | 1 << VT_STRUCT_SHIFT)
+#define VT_ASM_FUNC (VT_ASM | 2 << VT_STRUCT_SHIFT)
+#define IS_ASM_SYM(sym) (((sym)->type.t & (VT_BTYPE | VT_ASM)) == VT_ASM)
 
 /* general: set/get the pseudo-bitfield value for bit-mask M */
 #define BFVAL(M,N) ((unsigned)((M) & ~((M) << 1)) * (N))
@@ -1514,7 +1501,6 @@
 ST_FUNC void gbound_args(int nb_args);
 ST_DATA int func_bound_add_epilog;
 #endif
-ST_FUNC Sym *gfunc_set_param(Sym *s, int c, int byref);
 
 /* ------------ tccelf.c ------------ */
 
@@ -1664,6 +1650,54 @@
 static inline void add64le(unsigned char *p, int64_t x) {
     write64le(p, read64le(p) + x);
 }
+#define DWARF_MAX_128	((8 * sizeof (int64_t) + 6) / 7)
+#define	dwarf_read_1(ln,end) \
+	((ln) < (end) ? *(ln)++ : 0)
+#define	dwarf_read_2(ln,end) \
+	((ln) + 1 < (end) ? (ln) += 2, read16le((ln) - 2) : 0)
+#define	dwarf_read_4(ln,end) \
+	((ln) + 3 < (end) ? (ln) += 4, read32le((ln) - 4) : 0)
+#define	dwarf_read_8(ln,end) \
+	((ln) + 7 < (end) ? (ln) += 8, read64le((ln) - 8) : 0)
+static inline uint64_t
+dwarf_read_uleb128(unsigned char **ln, unsigned char *end)
+{
+    unsigned char *cp = *ln;
+    uint64_t retval = 0;
+    int i;
+
+    for (i = 0; i < DWARF_MAX_128; i++) {
+	uint64_t byte = dwarf_read_1(cp, end);
+
+        retval |= (byte & 0x7f) << (i * 7);
+	if ((byte & 0x80) == 0)
+	    break;
+    }
+    *ln = cp;
+    return retval;
+}
+static inline int64_t
+dwarf_read_sleb128(unsigned char **ln, unsigned char *end)
+{
+    unsigned char *cp = *ln;
+    int64_t retval = 0;
+    int i;
+
+    for (i = 0; i < DWARF_MAX_128; i++) {
+	uint64_t byte = dwarf_read_1(cp, end);
+
+        retval |= (byte & 0x7f) << (i * 7);
+	if ((byte & 0x80) == 0) {
+	    if ((byte & 0x40) && (i + 1) * 7 < 64)
+		retval |= -1LL << ((i + 1) * 7);
+	    break;
+	}
+    }
+    *ln = cp;
+    return retval;
+}
+
+
 /* ------------ i386-gen.c ------------ */
 #if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64 || defined TCC_TARGET_ARM
 ST_FUNC void g(int c);
@@ -1756,7 +1790,6 @@
 ST_FUNC int pe_load_file(struct TCCState *s1, int fd, const char *filename);
 ST_FUNC int pe_output_file(TCCState * s1, const char *filename);
 ST_FUNC int pe_putimport(TCCState *s1, int dllindex, const char *name, addr_t value);
-ST_FUNC int pe_setsubsy(TCCState *s1, const char *arg);
 #if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64
 #endif
 #ifdef TCC_TARGET_X86_64
@@ -1817,14 +1850,14 @@
 ST_FUNC void tcc_debug_newfile(TCCState *s1);
 
 ST_FUNC void tcc_debug_line(TCCState *s1);
-ST_FUNC void tcc_add_debug_info(TCCState *s1, Sym *s, Sym *e);
+ST_FUNC void tcc_add_debug_info(TCCState *s1, int param, Sym *s, Sym *e);
 ST_FUNC void tcc_debug_funcstart(TCCState *s1, Sym *sym);
 ST_FUNC void tcc_debug_prolog_epilog(TCCState *s1, int value);
 ST_FUNC void tcc_debug_funcend(TCCState *s1, int size);
 ST_FUNC void tcc_debug_extern_sym(TCCState *s1, Sym *sym, int sh_num, int sym_bind, int sym_type);
 ST_FUNC void tcc_debug_typedef(TCCState *s1, Sym *sym);
 ST_FUNC void tcc_debug_stabn(TCCState *s1, int type, int value);
-ST_FUNC void tcc_debug_fix_forw(TCCState *s1, CType *t);
+ST_FUNC void tcc_debug_fix_anon(TCCState *s1, CType *t);
 
 #if !(defined ELF_OBJ_ONLY || defined TCC_TARGET_ARM || defined TARGETOS_BSD)
 ST_FUNC void tcc_eh_frame_start(TCCState *s1);
@@ -1852,49 +1885,6 @@
 #define dwarf_str_section       s1->dwarf_str_section
 #define dwarf_line_str_section  s1->dwarf_line_str_section
 
-#define DWARF_MAX_128	((8 * sizeof (int64_t) + 6) / 7)
-#define	dwarf_read_1(ln,end) \
-	((ln) < (end) ? *(ln)++ : 0)
-#define	dwarf_read_2(ln,end) \
-	((ln) + 1 < (end) ? read16le(((ln)+=2) - 2) : 0)
-#define	dwarf_read_4(ln,end) \
-	((ln) + 3 < (end) ? read32le(((ln)+=4) - 4) : 0)
-#define	dwarf_read_8(ln,end) \
-	((ln) + 7 < (end) ? read64le(((ln)+=8) - 8) : 0)
-static inline uint64_t
-dwarf_read_uleb128(unsigned char **ln, unsigned char *end)
-{
-    unsigned char *cp = *ln;
-    uint64_t retval = 0;
-    int i;
-    for (i = 0; i < DWARF_MAX_128; i++) {
-	uint64_t byte = dwarf_read_1(cp, end);
-        retval |= (byte & 0x7f) << (i * 7);
-	if ((byte & 0x80) == 0)
-	    break;
-    }
-    *ln = cp;
-    return retval;
-}
-static inline int64_t
-dwarf_read_sleb128(unsigned char **ln, unsigned char *end)
-{
-    unsigned char *cp = *ln;
-    int64_t retval = 0;
-    int i;
-    for (i = 0; i < DWARF_MAX_128; i++) {
-	uint64_t byte = dwarf_read_1(cp, end);
-        retval |= (byte & 0x7f) << (i * 7);
-	if ((byte & 0x80) == 0) {
-	    if ((byte & 0x40) && (i + 1) * 7 < 64)
-		retval |= (uint64_t)-1LL << ((i + 1) * 7);
-	    break;
-	}
-    }
-    *ln = cp;
-    return retval;
-}
-
 /* default dwarf version for "-gdwarf" */
 #ifdef TCC_TARGET_MACHO
 # define DEFAULT_DWARF_VERSION 2
@@ -1907,7 +1897,9 @@
 # define CONFIG_DWARF_VERSION 0
 #endif
 
-#if defined TCC_TARGET_X86_64
+#if defined TCC_TARGET_PE
+# define R_DATA_32DW 'Z' /* fake code to avoid DLL relocs */
+#elif defined TCC_TARGET_X86_64
 # define R_DATA_32DW R_X86_64_32
 #else
 # define R_DATA_32DW R_DATA_32

--- 文件: ./tccpe.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tccpe.c	2025-09-27 10:22:27.988982522 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tccpe.c	2025-07-24 10:06:35.142441577 +0800
@@ -347,8 +347,6 @@
     TCCState *s1;
     Section *reloc;
     Section *thunk;
-    Section *coffsym;
-    Section *coffstr;
     const char *filename;
     int type;
     DWORD sizeofheaders;
@@ -368,10 +366,6 @@
     int sec_count;
     struct pe_import_info **imp_info;
     int imp_count;
-    /* output */
-    FILE *op;
-    DWORD sum;
-    unsigned pos;
 };
 
 #define PE_NUL 0
@@ -433,110 +427,71 @@
     hdr->opthdr.DataDirectory[dir].Size = size;
 }
 
-static int pe_fwrite(struct pe_info *pe, const void *data, int len)
+struct pe_file {
+    FILE *op;
+    DWORD sum;
+    unsigned pos;
+};
+
+static int pe_fwrite(const void *data, int len, struct pe_file *pf)
 {
     const WORD *p = data;
     DWORD sum;
     int ret, i;
-    pe->pos += (ret = fwrite(data, 1, len, pe->op));
-    sum = pe->sum;
+    pf->pos += (ret = fwrite(data, 1, len, pf->op));
+    sum = pf->sum;
     for (i = len; i > 0; i -= 2) {
         sum += (i >= 2) ? *p++ : *(BYTE*)p;
         sum = (sum + (sum >> 16)) & 0xFFFF;
     }
-    pe->sum = sum;
+    pf->sum = sum;
     return len == ret ? 0 : -1;
 }
 
-static void pe_fpad(struct pe_info *pe, DWORD new_pos)
+static void pe_fpad(struct pe_file *pf, DWORD new_pos)
 {
     char buf[256];
-    int n, diff = new_pos - pe->pos;
+    int n, diff = new_pos - pf->pos;
     memset(buf, 0, sizeof buf);
     while (diff > 0) {
         diff -= n = umin(diff, sizeof buf);
-        fwrite(buf, n, 1, pe->op);
+        fwrite(buf, n, 1, pf->op);
     }
-    pe->pos = new_pos;
+    pf->pos = new_pos;
 }
 
 /*----------------------------------------------------------------------------*/
-/* some DWARF support with COFF symbol/string table for gdb */
-
-#pragma pack(push, 1)
-struct syment
-{
-    union {
-        char        n_name[8];     /* old COFF version */
-        struct {
-            int32_t n_zeroes;      /* new == 0 */
-            int32_t n_offset;      /* offset into string table */
-        };
-    };
-    int32_t         n_value;        /* value of symbol */
-    short           n_scnum;        /* section number */
-    unsigned short  n_type;         /* type and derived type */
-    char            n_sclass;       /* storage class */
-    char            n_numaux;       /* number of aux. entries */
+/* PE-DWARF/COFF support
+   does not work with a mingw-gdb really but works with cv2pdb
+   (https://github.com/rainers/cv2pdb) */
+
+#define N_COFF_SYMS 0
+
+static const char dwarf_secs[] =
+{
+    ".debug_info\0"
+    ".debug_abbrev\0"
+    ".debug_line\0"
+    ".debug_aranges\0"
+    ".debug_str\0"
+    ".debug_line_str\0"
 };
-#pragma pack(pop)
 
-#define SHF_PRIVATE 0x80000000
+static const unsigned coff_strtab_size = 4 + sizeof dwarf_secs - 1;
 
-static void pe_add_coffsym(struct pe_info *pe)
+static int pe_put_long_secname(char *secname, const char *name)
 {
-    TCCState *s1 = pe->s1;
-    ElfSym *esym;
-    struct syment *se;
-    int n;
-
-    if (NULL == pe->coffsym) {
-        pe->coffsym = new_section(s1, ".coffsym", SHT_PROGBITS, SHF_PRIVATE);
-        pe->coffstr = new_section(s1, ".coffstr", SHT_PROGBITS, SHF_PRIVATE);
-        section_ptr_add(pe->coffstr, 4); /* coff string table size */
-        return;
-    }
-
-#if 0
-    se = section_ptr_add(pe->coffsym, sizeof *se);
-    strcpy(se->n_name, ".file");
-    se->n_scnum = -2;
-    se->n_sclass = 0x67;
-    se->n_numaux = 1;
-    se = section_ptr_add(pe->coffsym, sizeof *se);
-    strcpy((char*)se, "no-file");
-#endif
-
-#if 1
-    esym = (ElfSym*)s1->symtab->data;
-    for (n = s1->symtab->data_offset / sizeof *esym; ++esym, --n;) {
-        int sym_bind = ELFW(ST_BIND)(esym->st_info);
-        if (sym_bind == STB_GLOBAL) {
-            char *name = esym->st_name + (char*)s1->symtab->link->data;
-            int nl = strlen(name);
-            addr_t value = esym->st_value;
-            int shnum = esym->st_shndx;
-            if (shnum != SHN_UNDEF && shnum < s1->nb_sections) {
-                Section *s = s1->sections[shnum];
-                shnum = s->sh_info;
-                value = value - s->sh_addr;
-            }
-            se = section_ptr_add(pe->coffsym, sizeof *se);
-            se->n_value = value;
-            se->n_scnum = shnum;
-            se->n_sclass = 2; // C_EXT
-            if (nl <= 8)
-                memcpy(se->n_name, name, nl);
-            else
-                se->n_offset = put_elf_str(pe->coffstr, name);
+    const char *d = dwarf_secs;
+    do {
+        if (0 == strcmp(d, name)) {
+            snprintf(secname, 8, "/%d", (int)(d - dwarf_secs + 4));
+            return 1;
         }
-    }
-#endif
-    write32le(pe->coffstr->data, pe->coffstr->data_offset); /* coff string table size */
+        d = strchr(d, 0) + 1;
+    } while (*d);
+    return 0;
 }
 
-/* Run cv2pdb, available at https://github.com/rainers/cv2pdb.  It reads
-   and strips the dwarf info and creates a <exename>.pdb file instead */
 static void pe_create_pdb(TCCState *s1, const char *exename)
 {
     char buf[300]; int r;
@@ -659,16 +614,15 @@
     struct pe_header pe_header = pe_template;
 
     int i;
+    struct pe_file pf = {0};
     DWORD file_offset;
     struct section_info *si;
     IMAGE_SECTION_HEADER *psh;
     TCCState *s1 = pe->s1;
+    int need_strtab = 0;
 
-    if (s1->do_debug)
-        pe_add_coffsym(pe);
-
-    pe->op = fopen(pe->filename, "wb");
-    if (NULL == pe->op)
+    pf.op = fopen(pe->filename, "wb");
+    if (NULL == pf.op)
         return tcc_error_noabort("could not write '%s': %s", pe->filename, strerror(errno));
 
     pe->sizeofheaders = pe_file_align(pe,
@@ -678,7 +632,7 @@
 
     file_offset = pe->sizeofheaders;
 
-    if (2 == s1->verbose)
+    if (2 == pe->s1->verbose)
         printf("-------------------------------"
                "\n  virt   file   size  section" "\n");
     for (i = 0; i < pe->sec_count; ++i) {
@@ -691,7 +645,7 @@
         size = si->sh_size;
         psh = &si->ish;
 
-        if (2 == s1->verbose)
+        if (2 == pe->s1->verbose)
             printf("%6x %6x %6x  %s\n",
                 (unsigned)addr, (unsigned)file_offset, (unsigned)size, sh_name);
 
@@ -736,10 +690,8 @@
         }
 
         memcpy(psh->Name, sh_name, umin(strlen(sh_name), sizeof psh->Name));
-        if (pe->coffstr && strlen(sh_name) > 8) {
-            /* long section name, for example ".debug_info" */
-            snprintf((char*)psh->Name, 8, "/%d", put_elf_str(pe->coffstr, sh_name));
-        }
+        if (si->cls == sec_debug)
+            need_strtab += pe_put_long_secname((char*)psh->Name, sh_name);
 
         psh->Characteristics = si->pe_flags;
         psh->VirtualAddress = addr;
@@ -764,22 +716,18 @@
     pe_header.opthdr.SizeOfHeaders = pe->sizeofheaders;
     pe_header.opthdr.ImageBase = pe->imagebase;
     pe_header.opthdr.Subsystem = pe->subsystem;
-    if (s1->pe_stack_size)
-        pe_header.opthdr.SizeOfStackReserve = s1->pe_stack_size;
+    if (pe->s1->pe_stack_size)
+        pe_header.opthdr.SizeOfStackReserve = pe->s1->pe_stack_size;
     if (PE_DLL == pe->type)
         pe_header.filehdr.Characteristics = CHARACTERISTICS_DLL;
-    pe_header.filehdr.Characteristics |= s1->pe_characteristics;
-
-    if (pe->coffsym) {
-        pe_add_coffsym(pe);
+    pe_header.filehdr.Characteristics |= pe->s1->pe_characteristics;
+    if (need_strtab) {
         pe_header.filehdr.PointerToSymbolTable = file_offset;
-        pe_header.filehdr.NumberOfSymbols
-            = pe->coffsym->data_offset / sizeof (struct syment);
+        pe_header.filehdr.NumberOfSymbols = N_COFF_SYMS;
     }
-
-    pe_fwrite(pe, &pe_header, sizeof pe_header);
+    pe_fwrite(&pe_header, sizeof pe_header, &pf);
     for (i = 0; i < pe->sec_count; ++i)
-        pe_fwrite(pe, &pe->sec_info[i]->ish, sizeof(IMAGE_SECTION_HEADER));
+        pe_fwrite(&pe->sec_info[i]->ish, sizeof(IMAGE_SECTION_HEADER), &pf);
 
     file_offset = pe->sizeofheaders;
     for (i = 0; i < pe->sec_count; ++i) {
@@ -788,33 +736,34 @@
         if (!si->data_size)
             continue;
         for (s = si->sec; s; s = s->prev) {
-            pe_fpad(pe, file_offset);
-            pe_fwrite(pe, s->data, s->data_offset);
+            pe_fpad(&pf, file_offset);
+            pe_fwrite(s->data, s->data_offset, &pf);
             if (s->prev)
                 file_offset += s->prev->sh_addr - s->sh_addr;
         }
         file_offset = si->ish.PointerToRawData + si->ish.SizeOfRawData;
-        pe_fpad(pe, file_offset);
+        pe_fpad(&pf, file_offset);
     }
 
-    if (pe->coffsym) {
-        pe_fwrite(pe, pe->coffsym->data, pe->coffsym->data_offset);
-        pe_fwrite(pe, pe->coffstr->data, pe->coffstr->data_offset);
-        file_offset = pe->pos;
+    if (need_strtab) {
+        /* create a tiny COFF string table with the long section names */
+        pe_fwrite(&coff_strtab_size, sizeof coff_strtab_size, &pf);
+        pe_fwrite(dwarf_secs, sizeof dwarf_secs - 1, &pf);
+        file_offset = pf.pos;
     }
 
-    pe->sum += file_offset;
-    fseek(pe->op, offsetof(struct pe_header, opthdr.CheckSum), SEEK_SET);
-    pe_fwrite(pe, &pe->sum, sizeof (DWORD));
+    pf.sum += file_offset;
+    fseek(pf.op, offsetof(struct pe_header, opthdr.CheckSum), SEEK_SET);
+    pe_fwrite(&pf.sum, sizeof (DWORD), &pf);
 
-    fclose (pe->op);
+    fclose (pf.op);
 #ifndef _WIN32
     chmod(pe->filename, 0777);
 #endif
 
-    if (2 == s1->verbose)
+    if (2 == pe->s1->verbose)
         printf("-------------------------------\n");
-    if (s1->verbose)
+    if (pe->s1->verbose)
         printf("<- %s (%u bytes)\n", pe->filename, (unsigned)file_offset);
 
     if (s1->do_debug & 16)
@@ -899,7 +848,7 @@
 
         dllindex = p->dll_index;
         if (dllindex)
-            name = tcc_basename((dllref = s1->loaded_dlls[dllindex-1])->name);
+            name = tcc_basename((dllref = pe->s1->loaded_dlls[dllindex-1])->name);
         else
             name = "", dllref = NULL;
 
@@ -914,8 +863,8 @@
             if (k < n) {
                 int iat_index = p->symbols[k]->iat_index;
                 int sym_index = p->symbols[k]->sym_index;
-                ElfW(Sym) *imp_sym = (ElfW(Sym) *)s1->dynsymtab_section->data + sym_index;
-                const char *name = (char*)s1->dynsymtab_section->link->data + imp_sym->st_name;
+                ElfW(Sym) *imp_sym = (ElfW(Sym) *)pe->s1->dynsymtab_section->data + sym_index;
+                const char *name = (char*)pe->s1->dynsymtab_section->link->data + imp_sym->st_name;
                 int ordinal;
 
                 /* patch symbol (and possibly its underscored alias) */
@@ -999,7 +948,7 @@
     sym_end = symtab_section->data_offset / sizeof(ElfW(Sym));
     for (sym_index = 1; sym_index < sym_end; ++sym_index) {
         sym = (ElfW(Sym)*)symtab_section->data + sym_index;
-        name = pe_export_name(s1, sym);
+        name = pe_export_name(pe->s1, sym);
         if (sym->st_other & ST_PE_EXPORT) {
             p = tcc_malloc(sizeof *p);
             p->index = sym_index;
@@ -1048,7 +997,7 @@
         tcc_error_noabort("could not create '%s': %s", buf, strerror(errno));
     } else {
         fprintf(op, "LIBRARY %s\n\nEXPORTS\n", dllname);
-        if (s1->verbose)
+        if (pe->s1->verbose)
             printf("<- %s (%d symbol%s)\n", buf, sym_count, &"s"[sym_count < 2]);
     }
 #endif
@@ -1086,8 +1035,6 @@
     ElfW_Rel *rel, *rel_end;
     Section *s = NULL, *sr;
     struct pe_reloc_header *hdr;
-    TCCState *s1 = pe->s1;
-    int dwarf = 0, n;
 
     sh_addr = offset = block_ptr = count = i = 0;
     rel = rel_end = NULL;
@@ -1099,11 +1046,6 @@
             ++ rel;
             if (type != REL_TYPE_DIRECT)
                 continue;
-            if (dwarf) { /* don't runtime-relocate dwarf-to-dwarf */
-                n = ((ElfSym *)s1->symtab->data + ELFW(R_SYM)(rel[-1].r_info))->st_shndx;
-                if (n >= s1->dwlo && n < s1->dwhi)
-                    continue;
-            }
             if (count == 0) { /* new block */
                 block_ptr = pe->reloc->data_offset;
                 section_ptr_add(pe->reloc, sizeof(struct pe_reloc_header));
@@ -1123,7 +1065,6 @@
                 rel = (ElfW_Rel *)sr->data;
                 rel_end = (ElfW_Rel *)(sr->data + sr->data_offset);
                 sh_addr = s->sh_addr;
-                dwarf = s->sh_num >= s1->dwlo && s->sh_num < s1->dwhi;
             }
             s = s->prev;
             continue;
@@ -1192,8 +1133,8 @@
     TCCState *s1 = pe->s1;
 
     if (PE_DLL == pe->type)
-        pe->reloc = new_section(s1, ".reloc", SHT_PROGBITS, 0);
-    //pe->thunk = new_section(s1, ".iedat", SHT_PROGBITS, SHF_ALLOC);
+        pe->reloc = new_section(pe->s1, ".reloc", SHT_PROGBITS, 0);
+    //pe->thunk = new_section(pe->s1, ".iedat", SHT_PROGBITS, SHF_ALLOC);
 
     nbs = s1->nb_sections;
     sec_order = tcc_mallocz(2 * sizeof (int) * nbs);
@@ -1259,7 +1200,6 @@
             si->pe_flags |= IMAGE_SCN_MEM_DISCARDABLE;
 
 add_section:
-        s->sh_info = pe->sec_count; /* section number for coff syms */
         addr += s->data_offset;
         si->sh_size = addr - si->sh_addr;
         if (s->sh_type != SHT_NOBITS) {
@@ -1314,7 +1254,7 @@
         if (sym->st_shndx == SHN_UNDEF) {
             const char *name = (char*)symtab_section->link->data + sym->st_name;
             unsigned type = ELFW(ST_TYPE)(sym->st_info);
-            int imp_sym = 0;
+            int imp_sym;
             struct import_symbol *is;
 
             int _imp_, n;
@@ -1405,7 +1345,7 @@
                 is->iat_index = sym_index;
             }
 
-        } else if (s1->rdynamic
+        } else if (pe->s1->rdynamic
                    && ELFW(ST_BIND)(sym->st_info) != STB_LOCAL) {
             /* if -rdynamic option, then export all non local symbols */
             sym->st_other |= ST_PE_EXPORT;
@@ -1988,34 +1928,6 @@
     pe->type = pe_type;
 }
 
-ST_FUNC int pe_setsubsy(TCCState *s1, const char *arg)
-{
-    static const struct subsy { const char* p; int v; } x[] = {
-#if defined(TCC_TARGET_I386) || defined(TCC_TARGET_X86_64)
-        { "native", 1 },
-        { "gui", 2 },
-        { "windows", 2 },
-        { "console", 3 },
-        { "posix", 7 },
-        { "efiapp", 10 },
-        { "efiboot", 11 },
-        { "efiruntime", 12 },
-        { "efirom", 13 },
-#elif defined(TCC_TARGET_ARM)
-        { "wince", 9 },
-#endif
-        { 0, -1 }};
-    const struct subsy *y;
-    for (y = x;; ++y) {
-        if (!y->p)
-            return -1;
-        if (0 == strcmp(y->p, arg)) {
-            s1->pe_subsystem = y->v;
-            return 0;
-        }
-    }
-}
-
 static void pe_set_options(TCCState * s1, struct pe_info *pe)
 {
     if (PE_DLL == pe->type) {

--- 文件: ./tccpp.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tccpp.c	2025-09-27 10:22:27.992982541 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tccpp.c	2025-07-24 10:06:35.142441577 +0800
@@ -102,7 +102,7 @@
     if (tok != c) {
         char tmp[40];
         pstrcpy(tmp, sizeof tmp, get_tok_str(c, &tokc));
-        tcc_error("'%s' expected (got '%s')", tmp, get_tok_str(tok, &tokc));
+        tcc_error("'%s' expected (got \"%s\")", tmp, get_tok_str(tok, &tokc));
 	}
     next();
 }
@@ -133,6 +133,7 @@
 #define tal_free(al, p) tal_free_impl(al, p, __FILE__, __LINE__)
 #define tal_realloc(al, p, size) tal_realloc_impl(&al, p, size, __FILE__, __LINE__)
 #define TAL_DEBUG_PARAMS , const char *file, int line
+#define TAL_DEBUG_FILE_LEN 40
 #endif
 
 #define TOKSYM_TAL_SIZE     (768 * 1024) /* allocator for tiny TokenSym in table_ident */
@@ -156,16 +157,13 @@
 } TinyAlloc;
 
 typedef struct tal_header_t {
-    size_t  size; /* word align */
+    unsigned  size;
 #ifdef TAL_DEBUG
     int     line_num; /* negative line_num used for double free check */
-    char    file_name[40];
+    char    file_name[TAL_DEBUG_FILE_LEN + 1];
 #endif
 } tal_header_t;
 
-#define TAL_ALIGN(size) \
-    (((size) + (sizeof (size_t) - 1)) & ~(sizeof (size_t) - 1))
-
 /* ------------------------------------------------------------------------- */
 
 static TinyAlloc *tal_new(TinyAlloc **pal, unsigned limit, unsigned size)
@@ -200,7 +198,7 @@
             tal_header_t *header = (tal_header_t *)p;
             if (header->line_num > 0) {
                 fprintf(stderr, "%s:%d: chunk of %d bytes leaked\n",
-                        header->file_name, header->line_num, (int)header->size);
+                        header->file_name, header->line_num, header->size);
             }
             p += header->size + sizeof(tal_header_t);
         }
@@ -248,7 +246,7 @@
     tal_header_t *header;
     void *ret;
     int is_own;
-    unsigned adj_size = TAL_ALIGN(size);
+    unsigned adj_size = (size + 3) & -4;
     TinyAlloc *al = *pal;
 
 tail_call:
@@ -258,8 +256,9 @@
             header = (tal_header_t *)al->p;
             header->size = adj_size;
 #ifdef TAL_DEBUG
-            { int ofs = strlen(file) + 1 - sizeof header->file_name;
-            strcpy(header->file_name, file + (ofs > 0 ? ofs : 0));
+            { int ofs = strlen(file) - TAL_DEBUG_FILE_LEN;
+            strncpy(header->file_name, file + (ofs > 0 ? ofs : 0), TAL_DEBUG_FILE_LEN);
+            header->file_name[TAL_DEBUG_FILE_LEN] = 0;
             header->line_num = line; }
 #endif
             ret = al->p + sizeof(tal_header_t);
@@ -2054,7 +2053,7 @@
                         expect("more hex digits in universal-character-name");
                     else
                         goto add_hex_or_ucn;
-                    n = (unsigned) n * 16 + c;
+                    n = n * 16 + c;
                     p++;
                 } while (--i);
 		if (is_long) {
@@ -2977,11 +2976,6 @@
         tok = c;
         p++;
         break;
-    case 0xEF: /* UTF8 BOM ? */
-        if (p[1] == 0xBB && p[2] == 0xBF && p == file->buffer) {
-            p += 3;
-            goto redo_no_start;
-        }
     default:
         if (c >= 0x80 && c <= 0xFF) /* utf8 identifiers */
 	    goto parse_ident_fast;
@@ -3082,11 +3076,6 @@
                 cval.str.size = tokcstr.size;
                 cval.str.data = tokcstr.data;
                 tok_str_add2(&str, TOK_PPSTR, &cval);
-#ifdef TCC_TARGET_ARM
-            } else if ((parse_flags & PARSE_FLAG_ASM_FILE) && t == TOK_PPNUM) {
-                /* for example: mov r1,#0 */
-                --macro_str, tok_str_add(&str, '#');
-#endif
             } else {
                 expect("macro parameter after '#'");
             }
@@ -3633,7 +3622,7 @@
 
 static void tcc_predefs(TCCState *s1, CString *cs, int is_asm)
 {
-    cstr_printf(cs, "#define __TINYC__ 9%.2s\n", &TCC_VERSION[4]);
+    cstr_printf(cs, "#define __TINYC__ 9%.2s\n", *& TCC_VERSION + 4);
     putdefs(cs, target_machine_defs);
     putdefs(cs, target_os_defs);
 

--- 文件: ./tccrun.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tccrun.c	2025-09-27 10:22:27.992982541 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tccrun.c	2025-07-24 10:06:35.142441577 +0800
@@ -312,7 +312,6 @@
     addr_t mem, addr;
 
     if (NULL == ptr) {
-        s1->nb_errors = 0;
 #ifdef TCC_TARGET_PE
         pe_output_file(s1, NULL);
 #else
@@ -496,6 +495,10 @@
 {
 #ifdef CONFIG_TCC_BACKTRACE
     rt_context *rc;
+#ifdef CONFIG_TCC_BCHECK
+    void *p;
+#endif
+
     if (!s1->do_backtrace)
         return;
     rc = tcc_get_symbol(s1, "__rt_info");
@@ -508,7 +511,6 @@
         rc->prog_base &= 0xffffffff00000000ULL;
 #ifdef CONFIG_TCC_BCHECK
     if (s1->do_bounds_check) {
-        void *p;
         if ((p = tcc_get_symbol(s1, "__bound_init")))
             ((void(*)(void*,int))p)(rc->bounds_start, 1);
     }
@@ -597,13 +599,6 @@
     s = rt_find_state(f);
     rt_post_sem();
     if (s && s->run_lj) {
-#ifdef CONFIG_TCC_BCHECK
-        if (f->fp) { /* called from signal */
-            void *p = tcc_get_symbol(s, "__bound_exit");
-            if (p)
-                ((void (*)(void))p)();
-        }
-#endif
         if (code == 0)
             code = RT_EXIT_ZERO;
         ((void(*)(void*,int))s->run_lj)(s->run_jb, code);

--- 文件: ./tcctok.h ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tcctok.h	2025-09-27 10:22:27.992982541 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tcctok.h	2025-07-24 10:06:35.142441577 +0800
@@ -290,9 +290,6 @@
      DEF(TOK___fixdfdi, "__fixdfdi")
      DEF(TOK___fixxfdi, "__fixxfdi")
 #endif
-#if defined TCC_TARGET_X86_64
-     DEF(TOK___fixxfdi, "__fixxfdi")
-#endif
 
 #if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64
      DEF(TOK_alloca, "alloca")

--- 文件: ./tcctools.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tcctools.c	2025-09-27 10:22:27.992982541 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tcctools.c	2025-07-24 10:06:35.142441577 +0800
@@ -54,7 +54,7 @@
     return ret;
 }
 
-ST_FUNC int tcc_tool_ar(int argc, char **argv)
+ST_FUNC int tcc_tool_ar(TCCState *s1, int argc, char **argv)
 {
     static const ArHdr arhdr_init = {
         "/               ",
@@ -360,7 +360,7 @@
 
 #ifdef TCC_TARGET_PE
 
-ST_FUNC int tcc_tool_impdef(int argc, char **argv)
+ST_FUNC int tcc_tool_impdef(TCCState *s1, int argc, char **argv)
 {
     int ret, v, i;
     char infile[260];
@@ -487,9 +487,9 @@
 
 #if !defined TCC_TARGET_I386 && !defined TCC_TARGET_X86_64
 
-ST_FUNC int tcc_tool_cross(char **argv, int option)
+ST_FUNC int tcc_tool_cross(TCCState *s1, char **argv, int option)
 {
-    fprintf(stderr, "tcc -m%d not implemented\n", option);
+    tcc_error_noabort("-m%d not implemented.", option);
     return 1;
 }
 
@@ -546,7 +546,7 @@
 #define execvp execvp_win32
 #endif /* _WIN32 */
 
-ST_FUNC int tcc_tool_cross(char **argv, int target)
+ST_FUNC int tcc_tool_cross(TCCState *s1, char **argv, int target)
 {
     char program[4096];
     char *a0 = argv[0];
@@ -565,7 +565,7 @@
 
     if (strcmp(a0, program))
         execvp(argv[0] = program, argv);
-    fprintf(stderr, "tcc: could not run '%s'\n", program);
+    tcc_error_noabort("could not run '%s'", program);
     return 1;
 }
 

--- 文件: ./tests/boundtest.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tests/boundtest.c	2025-09-27 10:22:27.996982560 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tests/boundtest.c	2025-07-24 10:06:35.146441596 +0800
@@ -204,15 +204,14 @@
 int test16()
 {
     char *demo = "This is only a test.";
-    char *p, *q;
+    char *p;
 
     p = alloca(16);
     strcpy(p,"12345678901234");
 
     /* Test alloca embedded in a larger expression */
-    printf("alloca : %s : %s\n", p, strcpy(q=alloca(strlen(demo)+1),demo) );
+    printf("alloca : %s : %s\n", p, strcpy(alloca(strlen(demo)+1),demo) );
     allocf(p);
-    allocf(q);
 
     return 0;
 }
@@ -221,15 +220,14 @@
 int test17()
 {
     char *demo = "This is only a test.";
-    char *p, *q;
+    char *p;
 
     p = alloca(16);
     strcpy(p,"12345678901234");
 
     /* Test alloca embedded in a larger expression */
-    printf("alloca : %s : %s\n", p, strcpy(q=alloca(strlen(demo)),demo) );
+    printf("alloca : %s : %s\n", p, strcpy(alloca(strlen(demo)),demo) );
     allocf(p);
-    allocf(q);
 
     return 0;
 }

--- 文件: ./tests/tcctest.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tests/tcctest.c	2025-09-27 10:22:28.000982579 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tests/tcctest.c	2025-07-24 10:06:35.150441616 +0800
@@ -17,6 +17,10 @@
 /* __VA_ARGS__ and __func__ support */
 #define C99_MACROS
 
+#ifndef __TINYC__
+typedef __SIZE_TYPE__ uintptr_t;
+#endif
+
 #if defined(_WIN32) \
     || (defined(__arm__) \
         && (defined(__FreeBSD__) \
@@ -62,10 +66,6 @@
 
 #include "tcctest.h"
 
-#ifndef _TINYC_STDDEF
-#include <stdint.h>
-#endif
-
 /* Test two more ways to include a file named like a pp-number */
 #define INC(name) <tests/name.h>
 #define funnyname 42test.h
@@ -1767,13 +1767,9 @@
 };
 
 typedef int arrtype1[];
-arrtype1 sinit19;
-arrtype1 sinit20;
 arrtype1 sinit19 = {1};
 arrtype1 sinit20 = {2,3};
 typedef int arrtype2[3];
-arrtype2 sinit21;
-arrtype2 sinit22;
 arrtype2 sinit21 = {4};
 arrtype2 sinit22 = {5,6,7};
 

--- 文件: ./tests/tests2/101_cleanup.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tests/tests2/101_cleanup.c	2025-09-27 10:22:28.000982579 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tests/tests2/101_cleanup.c	2025-07-24 10:06:35.150441616 +0800
@@ -5,8 +5,6 @@
 typedef struct { int a; int b; int c; int d; } tsti;
 typedef struct { double a; double b; } tstd;
 typedef struct { long double a; } tstld;
-typedef struct { int a; double b; } tstm;
-typedef struct { float a; float b; float c; float d; } tstf;
 
 void incr_glob_i(int *i)
 {
@@ -260,44 +258,6 @@
     return n;
 }
 
-void my_cleanup6(tstm *p) {
-    printf("%d %g\n", p->a, p->b);
-    p->a = 90;
-    p->b = 91.0;
-}
-
-tstm test_cleanup6(void) {
-    tstm __attribute__((cleanup(my_cleanup6))) n;
-    n.a = 42;
-    n.b = 43.0;
-    return n;
-}
-
-void my_cleanup7(tstf *p) {
-    printf("%f %f %f %f\n", p->a, p->b, p->c, p->d);
-    p->a = 0x90; p->b = 0x91; p->c = 0x92; p->d = 0x93;
-}
-
-tstf test_cleanup7(void) {
-    tstf __attribute__((cleanup(my_cleanup7))) n;
-    n.a = 42; n.b = 43; n.c = 44; n.d = 45;
-    return n;
-}
-
-void my_cleanup8(int **p) {
-    **p = 0x90;
-}
-
-int test_cleanup8(void) {
-    int n = 42;
-    int __attribute__((cleanup(my_cleanup8))) *p = &n;
-    return n;
-}
-
-static void my_cleanupe(int *p) {
-    *p = 0x90;
-}
-
 int main()
 {
     int i __attribute__ ((__cleanup__(check))) = 0, not_i;
@@ -307,8 +267,6 @@
     tsti ti;
     tstd td;
     tstld tld;
-    tstm tm;
-    tstf tf;
 
     {
 	__attribute__ ((__cleanup__(check_oh_i))) char oh_i = 'o', o = 'a';
@@ -341,14 +299,6 @@
     printf("%g %g\n", td.a, td.b);
     tld = test_cleanup5();
     printf("%Lf\n", tld.a);
-    tm = test_cleanup6();
-    printf("%d %g\n", tm.a, tm.b);
-    tf = test_cleanup7();
-    printf("%f %f %f %f\n", tf.a, tf.b, tf.c, tf.d);
-    printf("%d\n", test_cleanup8());
-    printf("%d\n", ({
-            int __attribute__ ((cleanup(my_cleanupe))) n = 42;
-            n; }));
     return i;
 }
 

--- 文件: ./tests/tests2/111_conversion.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tests/tests2/111_conversion.c	2025-09-27 10:22:28.000982579 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tests/tests2/111_conversion.c	2025-07-24 10:06:35.150441616 +0800
@@ -14,11 +14,9 @@
 int main (void)
 {
     union u v;
-    double d = 1234567890.0;
 
     v.ld = 42;
     conv (&v);
     printf ("%lu\n", v.ul);
-    printf ("%llu\n", (unsigned long long)d);
     return 0;
 }

--- 文件: ./tests/tests2/121_struct_return.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tests/tests2/121_struct_return.c	2025-09-27 10:22:28.004982598 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tests/tests2/121_struct_return.c	2025-07-24 10:06:35.154441635 +0800
@@ -6,10 +6,6 @@
     double d2;
 } Node;
 
-typedef struct {
-    int a, b, c;
-} A;
-
 Node init(Node self) {
     self.data[0] = 0;
     self.data[1] = 1;
@@ -29,25 +25,11 @@
             data.d1, data.d2);
 }
 
-A test(void)
-{
-    int i;
-    A arr[30];
-
-    for (i = 0; i < 30; i++)
-        arr[i].b = i;
-    return arr[29];
-}
-
 int main(void) {
     /* This code resulted in a bounds checking error */
     Node data;
-    A a;
     dummy (data);
     char val;
     data = init (data);
     print_data(data);
-    a = test();
-    printf("%d\n", a.b);
-    return 0;
 }

--- 文件: ./tests/tests2/124_atomic_counter.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tests/tests2/124_atomic_counter.c	2025-09-27 10:22:28.004982598 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tests/tests2/124_atomic_counter.c	2025-07-24 10:06:35.154441635 +0800
@@ -14,12 +14,18 @@
             abort(); \
     } while (0)
 
+#if defined __x86_64__ || defined __aarch64__ || defined __riscv
+#define HAS_64BITS
+#endif
+
 typedef struct {
     atomic_flag flag;
     atomic_uchar uc;
     atomic_ushort us;
     atomic_uint ui;
+#ifdef HAS_64BITS
     atomic_size_t ul;
+#endif
 } counter_type;
 
 static
@@ -32,7 +38,9 @@
         atomic_fetch_add_explicit(&counter->uc, 1, memory_order_relaxed);
         atomic_fetch_add_explicit(&counter->us, 1, memory_order_relaxed);
         atomic_fetch_add_explicit(&counter->ui, 1, memory_order_relaxed);
+#ifdef HAS_64BITS
         atomic_fetch_add_explicit(&counter->ul, 1, memory_order_relaxed);
+#endif
     }
 
     return NULL;
@@ -48,11 +56,15 @@
         unsigned char xchgc;
         unsigned short xchgs;
         unsigned int xchgi;
+#ifdef HAS_64BITS
         size_t xchgl;
+#endif
         unsigned char cmpc = atomic_load_explicit(&counter->uc, memory_order_relaxed);
         unsigned short cmps = atomic_load_explicit(&counter->us, memory_order_relaxed);
         unsigned int cmpi = atomic_load_explicit(&counter->ui, memory_order_relaxed);
+#ifdef HAS_64BITS
         size_t cmpl = atomic_load_explicit(&counter->ul, memory_order_relaxed);
+#endif
 
         do {
             xchgc = (cmpc + 1);
@@ -66,10 +78,12 @@
             xchgi = (cmpi + 1);
         } while (!atomic_compare_exchange_strong_explicit(&counter->ui,
             &cmpi, xchgi, memory_order_relaxed, memory_order_relaxed));
+#ifdef HAS_64BITS
         do {
             xchgl = (cmpl + 1);
         } while (!atomic_compare_exchange_strong_explicit(&counter->ul,
             &cmpl, xchgl, memory_order_relaxed, memory_order_relaxed));
+#endif
     }
 
     return NULL;
@@ -86,7 +100,9 @@
         ++counter->uc;
         ++counter->us;
         ++counter->ui;
+#ifdef HAS_64BITS
         ++counter->ul;
+#endif
         atomic_flag_clear(&counter->flag);
     }
 
@@ -104,7 +120,9 @@
     atomic_init(&counter.uc, 0);
     atomic_init(&counter.us, 0);
     atomic_init(&counter.ui, 0);
+#ifdef HAS_64BITS
     atomic_init(&counter.ul, 0);
+#endif
 
     for (index = 0; index < NR_THREADS; ++index)
         BUG_ON(pthread_create(&thread[index], NULL, adder, (void *)&counter));
@@ -115,7 +133,9 @@
     if (atomic_load(&counter.uc) == ((NR_THREADS * NR_STEPS) & 0xffu)
         && atomic_load(&counter.us) == ((NR_THREADS * NR_STEPS) & 0xffffu)
         && atomic_load(&counter.ui) == (NR_THREADS * NR_STEPS)
+#ifdef HAS_64BITS
         && atomic_load(&counter.ul) == (NR_THREADS * NR_STEPS)
+#endif
         )
         printf("SUCCESS\n");
     else

--- 文件: ./tests/tests2/125_atomic_misc.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tests/tests2/125_atomic_misc.c	2025-09-27 10:22:28.004982598 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tests/tests2/125_atomic_misc.c	2025-07-24 10:06:35.154441635 +0800
@@ -63,7 +63,12 @@
 #define OP1(func, v, e1, e2) atomic_##func(&c, v) == e1 && c == e2
 #define OP2(func, v, e1, e2) atomic_##func(&s, v) == e1 && s == e2
 #define OP4(func, v, e1, e2) atomic_##func(&i, v) == e1 && i == e2
+#if defined __x86_64__ || defined __aarch64__ || defined __riscv
 #define OP8(func, v, e1, e2) atomic_##func(&l, v) == e1 && l == e2
+#define HAS_64BITS
+#else
+#define OP8(func, v, e1, e2) 1
+#endif
 
 #define OP(func, v, e1, e2) printf ("%s: %s\n", #func,                        \
                                     OP1(func,v,e1,e2) && OP2(func,v,e1,e2) && \
@@ -75,12 +80,16 @@
     atomic_char c;
     atomic_short s;
     atomic_int i;
+#ifdef HAS_64BITS
     atomic_size_t l;
+#endif
 
     atomic_init(&c, 0);
     atomic_init(&s, 0);
     atomic_init(&i, 0);
+#ifdef HAS_64BITS
     atomic_init(&l, 0);
+#endif
 
     OP(fetch_add, 10, 0, 10);
     OP(fetch_sub, 5, 10, 5);
@@ -99,8 +108,13 @@
     __atomic_##func(&s, v, __ATOMIC_SEQ_CST) == e1 && s == e2
 #define OP4(func, v, e1, e2)\
     __atomic_##func(&i, v, __ATOMIC_SEQ_CST) == e1 && i == e2
+#if defined __x86_64__ || defined __aarch64__ || defined __riscv
 #define OP8(func, v, e1, e2)\
     __atomic_##func(&l, v, __ATOMIC_SEQ_CST) == e1 && l == e2
+#define HAS_64BITS
+#else
+#define OP8(func, v, e1, e2) 1
+#endif
 
 #define OP(func, v, e1, e2) printf ("%s: %s\n", #func,                        \
                                     OP1(func,v,e1,e2) && OP2(func,v,e1,e2) && \
@@ -112,12 +126,16 @@
     signed char c;
     short s;
     int i;
+#ifdef HAS_64BITS
     size64_t l;
+#endif
 
     atomic_init(&c, 0);
     atomic_init(&s, 0);
     atomic_init(&i, 0);
+#ifdef HAS_64BITS
     atomic_init(&l, 0);
+#endif
 
     OP(fetch_add, 10, 0, 10);
     OP(fetch_sub, 5, 10, 5);
@@ -129,7 +147,9 @@
     atomic_init(&c, 0);
     atomic_init(&s, 0);
     atomic_init(&i, 0);
+#ifdef HAS_64BITS
     atomic_init(&l, 0);
+#endif
 
     OP(add_fetch, 10, 10, 10);
     OP(sub_fetch, 5, 5, 5);

--- 文件: ./tests/tests2/129_scopes.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tests/tests2/129_scopes.c	2025-09-27 10:22:28.004982598 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tests/tests2/129_scopes.c	2025-07-24 10:06:35.154441635 +0800
@@ -1,11 +1,7 @@
-int printf(const char*, ...);
-
-#define myassert(x) \
-    printf("%s:%d: %s : \"%s\"\n", __FILE__,__LINE__,(x)?"ok":"error",#x)
-
+#include <stdio.h>
 enum{ in = 0};
-
-int main_1(){
+#define myassert(X) do{ if(!X) printf("%d: assertion failed\n", __LINE__); }while(0)
+int main(){
     {
         myassert(!in);
         if(sizeof(enum{in=1})) myassert(in);
@@ -42,145 +38,6 @@
         for(;sizeof(enum{in=1});){ myassert(in); break; }
         myassert(!in); //OK
     }
-    return 0;
-}
-
-/* --------------------------------------------- */
-int main_2()
-{
-  char c = 'a';
-  void func1(char c); /* param 'c' must not shadow local 'c' */
-  func1(c);
-  return 0;
-}
-
-void func1(char c)
-{
-    myassert(c == 'a');
-}
-
-struct st { int a; };
-
-/* --------------------------------------------- */
-int main_3()
-{
-  struct st func(void);
-  struct st st = func(); /* not an 'incompatible redefinition' */
-  myassert(st.a == 10);
-  return 0;
-}
-
-struct st func(void)
-{
-  struct st st = { 10 };
-  return st;
-}
-
-/* --------------------------------------------- */
-/* func* 'md' must not be shadowed by param 'md' */
-static void f4(char *(*md)(char *md))
-{
-   (*md)("test");
-}
-static char *a4(char *a)
-{
-    int strcmp();
-    myassert(!strcmp(a, "test"));
-    return a;
-}
-
-int main_4()
-{
-    f4(a4);
-    return 0;
-}
-
-/* --------------------------------------------- */
-int a5[3], b5[];
-int f5(void);
-int main_5()
-{
-    extern int a5[3], b5[3];
-    a5[2]=10, b5[2]=4;
-    myassert(f5() == 10 + 4);
-    return 0;
-}
-int f5(void)
-{
-    return a5[2]+b5[2];
-}
-int b5[3];
-
-/* --------------------------------------------- */
-static int f6(int);
-int i6 = 11;
-
-int main_6()
-{
-    {
-        int i6 = 33, f6 = 44;
-        myassert(i6 == 33 && f6 == 44);
-        {
-            int f6(int);
-            extern int i6;
-            myassert(i6 == 11 && f6(22) == 22);
-        }
-        myassert(i6 == 33 && f6 == 44);
-    }
-    myassert(i6 == 11 && f6(22) == 22);
-    return 0;
-}
-
-int f6(int x)
-{
-    return x;
-}
-
-/* --------------------------------------------- */
-
-#if defined __TINYC__ \
-    ? !defined __leading_underscore \
-    : !(defined __APPLE__ || defined _WIN32)
-# define _
-#else
-# define _ "_"
-#endif
 
-struct xx7 { int a, b; };
-
-void f7()
-{
-    struct xx7 { int c; } x;
-    {
-        extern struct xx7 { int a, b; } x __asm__(_"z7");
-        x.a = 12;
-        struct xx7 y = { 0,0 };
-    }
-    struct xx7 y = { 90 };
-    x.c = 78;
-    printf("xx7 (1) : %d %d\n", x.c, y.c);
 }
 
-int main_7()
-{
-    f7();
-    extern struct xx7 y __asm__(_"z7");
-    printf("xx7 (2) : %d %d\n", y.a, y.b);
-    return 0;
-}
-
-
-struct xx7 z7 = { 0, 34 };
-
-/* --------------------------------------------- */
-int main()
-{
-    main_1();
-    main_2();
-    main_3();
-    main_4();
-    main_5();
-    main_6();
-    main_7();
-    return 0;
-}

--- 文件: ./tests/tests2/132_bound_test.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tests/tests2/132_bound_test.c	2025-09-27 10:22:28.004982598 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tests/tests2/132_bound_test.c	2025-07-24 10:06:35.154441635 +0800
@@ -21,17 +21,9 @@
     return x.d;
 }
 
-void mul(double *p)
-{
-    *p *= 2.0;
-}
-
 int
 main(void)
 {
-    double d = 4.0;
     printf("%g\n", scale(42));
-    mul(&d);
-    printf("%g\n", d);
     return 0;
 }

--- 文件: ./tests/tests2/136_atomic_gcc_style.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tests/tests2/136_atomic_gcc_style.c	2025-09-27 10:22:28.004982598 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tests/tests2/136_atomic_gcc_style.c	2025-07-24 10:06:35.154441635 +0800
@@ -1,11 +1,8 @@
 #include <stdatomic.h>
 #include <stdbool.h>
+#include <assert.h>
 #include <stdio.h>
 
-// standard assert would popup a dialog box on windows
-#define assert(x) \
-    printf("assert \"%s\" : %s\n", #x, (x) ? "yes" : "no");
-
 int main() {
     // Test 1: Basic functionality of __atomic_store_n and __atomic_load_n
     {

--- 文件: ./tests/tests2/35_sizeof.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tests/tests2/35_sizeof.c	2025-09-27 10:22:28.008982617 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tests/tests2/35_sizeof.c	2025-07-24 10:06:35.154441635 +0800
@@ -1,30 +1,14 @@
-int printf(const char*, ...);
+#include <stdio.h>
 
 int main()
 {
-    char a;
-    short b;
+   char a;
+   short b;
 
-    printf("sizeof a : %d %d\n", sizeof(char), sizeof(a));
-    printf("sizeof b : %d %d\n", sizeof(short), sizeof(b));
+   printf("%d %d\n", sizeof(char), sizeof(a));
+   printf("%d %d\n", sizeof(short), sizeof(b));
 
-    int ii[] = {}; /* gnu extension, size = 0 */
-    printf("sizeof ii : %d\n", sizeof ii);
-
-    int kk[] = { 1 };
-    printf("sizeof kk : %d\n", sizeof kk);
-
-    char cc[] = "12";
-    printf("sizeof cc : %d\n", sizeof cc);
-
-    __WCHAR_TYPE__ ll[] = L"12345";
-    printf("len-of ll : %d\n", sizeof ll / sizeof ll[0]);
-
-    static struct {
-        int a,b,c;
-        int d[];
-    } ss[] = {{ 1, 2, 3, {} }};
-    printf("sizeof ss : %d\n", sizeof ss);
-
-    return 0;
+   return 0;
 }
+
+/* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/

--- 文件: ./tests/tests2/39_typedef.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tests/tests2/39_typedef.c	2025-09-27 10:22:28.008982617 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tests/tests2/39_typedef.c	2025-07-24 10:06:35.158441655 +0800
@@ -12,12 +12,8 @@
 
 typedef MyFunStruct *MoreFunThanEver;
 
-typedef int t[];
-int tints[];
-
 int main()
 {
-   int i, *p;
    MyInt a = 1;
    printf("%d\n", a);
 
@@ -29,22 +25,6 @@
    MoreFunThanEver c = &b;
    printf("%d,%d\n", c->i, c->j);
 
-   p = (t){1,2,3};
-   for (i = 0; i < 3 ; i++) printf("%d ", *p++); printf("\n");
-   p = (t){1,2,3,4};
-   for (i = 0; i < 4 ; i++) printf("%d ", *p++); printf("\n");
-
-   printf("%d\n", (int)sizeof((t){1,2,3}));
-   printf("%d\n", (int)sizeof((t){1,2,3,4}));
-
-   /* two arrays derived from same base type */
-   t t3 = { 1,2,3 }, t4 = { 4,5,6,7 };
-   for (p = t3, i = 0; i < 3 ; i++) printf("%d ", *p++);
-   for (p = t4, i = 0; i < 4 ; i++) printf("%d ", *p++); printf("\n");
-   typeof(tints) t5 = { 1,2,3 }, t6 = { 4,5,6,7 };
-   for (p = t5, i = 0; i < 3 ; i++) printf("%d ", *p++);
-   for (p = t6, i = 0; i < 4 ; i++) printf("%d ", *p++); printf("\n");
-
    return 0;
 }
 

--- 文件: ./tests/tests2/60_errors_and_warnings.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tests/tests2/60_errors_and_warnings.c	2025-09-27 10:22:28.008982617 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tests/tests2/60_errors_and_warnings.c	2025-07-24 10:06:35.158441655 +0800
@@ -1,9 +1,9 @@
-int printf(const char*, ...);
-
 #if defined test_56_btype_excess_1
 struct A {} int i;
+
 #elif defined test_57_btype_excess_2
 char int i;
+
 #elif defined test_58_function_redefinition
 int f(void) { return 0; }
 int f(void) { return 1; }
@@ -253,7 +253,7 @@
     hello(123);
     return 0;
 }
-
+int printf(const char*, ...);
 #if defined test_func_3
 static int hello(int a)
 #elif defined test_func_5
@@ -272,7 +272,7 @@
 int xxx[];
 #endif
 int bar();
-
+int printf(const char*, ...);
 int main ()
 {
 #if !defined test_var_3
@@ -333,7 +333,7 @@
 x
 
 #elif defined test_stray_backslash2
-
+int printf(const char*, ...);
 int main()
 {
 #define _S(x) #x
@@ -438,7 +438,7 @@
 int amain(int argc, char *argv[static argc + 1])
 {
     int i;
-
+    int printf(const char*, ...);
     for (i = 0; i < argc; ++i)
         printf("arg[%d] = \"%s\"\n", i, argv[i]);
     return 0;
@@ -510,45 +510,10 @@
 #ifdef test_reverse_funcargs
 # pragma comment(option, "-freverse-funcargs")
 #endif
-
+int printf(const char*, ...);
 int main()
 {
     printf(" %d %d %d\n", printf("1"), printf("22"), printf("333"));
 }
 
-#elif defined test_scope_1 \
-   || defined test_scope_2 \
-   || defined test_scope_3
-
-struct xxx {int x[4];};
-
-/* 'ee' not defined outside of function, 'i' not redefined */
-int bar(enum ee { a = 12, b = 34 } i, int(*f)(int i))
-{
-    printf("bar %d %d %d\n", i, a, b);
-    return 0;
-}
-/* 'xxx' not defined outside of function */
-int foo(struct xxx {int x[3];}*p)
-{
-    printf("foo %d", sizeof *p);
-    return p->x[3];
-}
-#ifdef test_scope_2
-/* incompatible redefinition */
-int foo(struct xxx {int x[2];}*p);
-#endif
-#ifndef test_scope_3
-enum ee { a = 1, b };
-#endif
-
-struct xxx x = { 11,22,33,44 };
-int main(int argc, char **argv)
-{
-    printf(" %d %d\n", foo(&x), sizeof (struct xxx));
-    enum ee e = b;
-    bar(13 + e, 0);
-
-}
-
 #endif

--- 文件: ./tests/tests2/93_integer_promotion.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./tests/tests2/93_integer_promotion.c	2025-09-27 10:22:28.012982636 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./tests/tests2/93_integer_promotion.c	2025-07-24 10:06:35.158441655 +0800
@@ -6,106 +6,66 @@
 int main (void)
 {
     struct {
-        unsigned u3:3;
-        unsigned u31:31;
-        unsigned u32:32;
-        unsigned long ul31:31;
-        unsigned long ul32:32;
-        unsigned long long ull31:31;
-        unsigned long long ull32:32;
-        unsigned long long ull33:33;
-        unsigned long long ull64:64;
+        unsigned ub:3;
+        unsigned u:32;
+        unsigned long long ullb:35;
+        unsigned long long ull:64;
         unsigned char c;
-    } s = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
+    } s = { 1, 1, 1 };
 
-    promote(s.u3);
-    promote(s.u31);
-    promote(s.u32);
-    promote(s.ul31);
-    promote(s.ul32);
-    promote(s.ull31);
-    promote(s.ull32);
-    promote(s.ull33);
-    promote(s.ull64);
+    promote(s.ub);
+    promote(s.u);
+    promote(s.ullb);
+    promote(s.ull);
     promote(s.c);
     printf("\n");
 
-    promote((1 ? s.u3 : 1));
-    promote((1 ? s.u31 : 1));
-    promote((1 ? s.u32 : 1));
-    promote((1 ? s.ul31 : 1));
-    promote((1 ? s.ul32 : 1));
-    promote((1 ? s.ull31 : 1));
-    promote((1 ? s.ull32 : 1));
-    promote((1 ? s.ull33 : 1));
-    promote((1 ? s.ull64 : 1));
+    promote((1 ? s.ub : 1));
+    promote((1 ? s.u : 1));
+    promote((1 ? s.ullb : 1));
+    promote((1 ? s.ull : 1));
     promote((1 ? s.c : 1));
     printf("\n");
 
-    promote(s.u3 << 1);
-    promote(s.u31 << 1);
-    promote(s.u32 << 1);
-    promote(s.ul31 << 1);
-    promote(s.ul32 << 1);
-    promote(s.ull31 << 1);
-    promote(s.ull32 << 1);
-    promote(s.ull33 << 1);
-    promote(s.ull64 << 1);
+    promote(s.ub << 1);
+    promote(s.u << 1);
+    promote(s.ullb << 1);
+    promote(s.ull << 1);
     promote(s.c << 1);
     printf("\n");
 
-    promote(+s.u3);
-    promote(+s.u31);
-    promote(+s.u32);
-    promote(+s.ul31);
-    promote(+s.ul32);
-    promote(+s.ull31);
-    promote(+s.ull32);
-    promote(+s.ull33);
-    promote(+s.ull64);
+    promote(+s.ub);
+    promote(+s.u);
+    promote(+s.ullb);
+    promote(+s.ull);
     promote(+s.c);
     printf("\n");
 
-    promote(-s.u3);
-    promote(-s.u31);
-    promote(-s.u32);
-    promote(-s.ul31);
-    promote(-s.ul32);
-    promote(-s.ull31);
-    promote(-s.ull32);
-    promote(-s.ull33);
-    promote(-s.ull64);
+    promote(-s.ub);
+    promote(-s.u);
+    promote(-s.ullb);
+    promote(-s.ull);
     promote(-s.c);
     printf("\n");
 
-    promote(~s.u3);
-    promote(~s.u31);
-    promote(~s.u32);
-    promote(~s.ul31);
-    promote(~s.ul32);
-    promote(~s.ull31);
-    promote(~s.ull32);
-    promote(~s.ull33);
-    promote(~s.ull64);
+    promote(~s.ub);
+    promote(~s.u);
+    promote(~s.ullb);
+    promote(~s.ull);
     promote(~s.c);
     printf("\n");
 
-    promote(!s.u3);
-    promote(!s.u31);
-    promote(!s.u32);
-    promote(!s.ul31);
-    promote(!s.ul32);
-    promote(!s.ull31);
-    promote(!s.ull32);
-    promote(!s.ull33);
-    promote(!s.ull64);
+    promote(!s.ub);
+    promote(!s.u);
+    promote(!s.ullb);
+    promote(!s.ull);
     promote(!s.c);
     printf("\n");
 
-    promote(+(unsigned)s.u3);
-    promote(-(unsigned)s.u3);
-    promote(~(unsigned)s.u3);
-    promote(!(unsigned)s.u3);
+    promote(+(unsigned)s.ub);
+    promote(-(unsigned)s.ub);
+    promote(~(unsigned)s.ub);
+    promote(!(unsigned)s.ub);
 
     return 0;
 }

--- 文件: ./TODO ---
--- /workspace/self-evolve-ai/third_party/tinycc/./TODO	2025-09-27 10:22:27.952982352 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./TODO	2025-07-24 10:06:35.126441498 +0800
@@ -3,7 +3,6 @@
 Releases:
 
 - release tcc on a regular basis
-- testing repo.or.cz
 
 Bugs:
 

--- 文件: ./win32/include/stdlib.h ---
--- /workspace/self-evolve-ai/third_party/tinycc/./win32/include/stdlib.h	2025-09-27 10:22:28.016982654 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./win32/include/stdlib.h	2025-07-24 10:06:35.162441674 +0800
@@ -376,16 +376,10 @@
   _CRTIMP int __cdecl _set_error_mode(int _Mode);
   void __cdecl srand(unsigned int _Seed);
   double __cdecl strtod(const char *_Str,char **_EndPtr);
+  float __cdecl strtof(const char *nptr, char **endptr);
 #if !defined __NO_ISOCEXT  /* in libmingwex.a */
-#if __TINYC__
-  __CRT_INLINE float __cdecl strtof (const char *p, char ** e) { return strtod(p, e); }
-  __CRT_INLINE long double __cdecl strtold(const char *p, char ** e) { return strtod(p, e); }
-#else
   float __cdecl strtof (const char * __restrict__, char ** __restrict__);
   long double __cdecl strtold(const char * __restrict__, char ** __restrict__);
-#endif
-#else
-  float __cdecl strtof(const char *nptr, char **endptr);
 #endif /* __NO_ISOCEXT */
   _CRTIMP double __cdecl _strtod_l(const char *_Str,char **_EndPtr,_locale_t _Locale);
   long __cdecl strtol(const char *_Str,char **_EndPtr,int _Radix);

--- 文件: ./win32/include/winapi/winbase.h ---
--- /workspace/self-evolve-ai/third_party/tinycc/./win32/include/winapi/winbase.h	2025-09-27 10:22:28.020982673 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./win32/include/winapi/winbase.h	2025-07-24 10:06:35.166441694 +0800
@@ -859,7 +859,7 @@
   }
 #endif
 
-#ifndef InterlockedAnd64
+#ifndef !defined (InterlockedAnd64)
 #define InterlockedAnd64 InterlockedAnd64_Inline
 
   __CRT_INLINE LONGLONG InterlockedAnd64_Inline (LONGLONG volatile *Destination,LONGLONG Value) {
@@ -1847,7 +1847,7 @@
 #define LOAD_LIBRARY_AS_DATAFILE 0x2
 #define LOAD_WITH_ALTERED_SEARCH_PATH 0x8
 #define LOAD_IGNORE_CODE_AUTHZ_LEVEL 0x10
-#define LOAD_LIBRARY_AS_IMAGE_RESOURCE 0x20
+#define LOAD_LINRARY_AS_IMAGE_RESOURCE 0x20
 #define LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE 0x40
 #define LOAD_LIBRARY_REQUIRE_SIGNED_TARGET 0x80
 #define LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR 0x100

--- 文件: ./x86_64-gen.c ---
--- /workspace/self-evolve-ai/third_party/tinycc/./x86_64-gen.c	2025-09-27 10:22:28.028982711 +0800
+++ /workspace/self-evolve-ai/third_party/tcc/src/./x86_64-gen.c	2025-07-24 10:06:35.166441694 +0800
@@ -120,7 +120,6 @@
 
 ST_DATA const char * const target_machine_defs =
     "__x86_64__\0"
-    "__x86_64\0"
     "__amd64__\0"
     ;
 
@@ -397,7 +396,6 @@
             v1.type.t = VT_PTR;
             v1.r = VT_LOCAL | VT_LVAL;
             v1.c.i = fc;
-	    v1.sym = NULL;
             fr = r;
             if (!(reg_classes[fr] & (RC_INT|RC_R11)))
                 fr = get_reg(RC_INT);
@@ -410,7 +408,6 @@
 	    v1.type.t = VT_LLONG;
 	    v1.r = VT_CONST;
 	    v1.c.i = sv->c.i;
-	    v1.sym = NULL;
 	    fr = r;
 	    if (!(reg_classes[fr] & (RC_INT|RC_R11)))
 	        fr = get_reg(RC_INT);
@@ -812,8 +809,6 @@
         gbound_args(nb_args);
 #endif
 
-    save_regs(nb_args);
-
     args_size = (nb_args < REGN ? REGN : nb_args) * PTR_SIZE;
     arg = nb_args;
 
@@ -911,7 +906,7 @@
         }
         vtop--;
     }
-
+    save_regs(0);
     /* Copy R10 and R11 into RCX and RDX, respectively */
     if (nb_args > 0) {
         o(0xd1894c); /* mov %r10, %rcx */
@@ -975,7 +970,8 @@
             if (reg_param_index < REGN) {
                 gen_modrm64(0x89, arg_regs[reg_param_index], VT_LOCAL, NULL, addr);
             }
-            gfunc_set_param(sym, addr, 1);
+            sym_push(sym->v & ~SYM_FIELD, type,
+                     VT_LLOCAL | VT_LVAL, addr);
         } else {
             if (reg_param_index < REGN) {
                 /* save arguments passed by register */
@@ -988,7 +984,8 @@
                     gen_modrm64(0x89, arg_regs[reg_param_index], VT_LOCAL, NULL, addr);
                 }
             }
-            gfunc_set_param(sym, addr, 0);
+            sym_push(sym->v & ~SYM_FIELD, type,
+		     VT_LOCAL | VT_LVAL, addr);
         }
         addr += 8;
         reg_param_index++;
@@ -1252,8 +1249,6 @@
         gbound_args(nb_args);
 #endif
 
-    save_regs(nb_args);
-
     /* calculate the number of integer/float register arguments, remember
        arguments to be passed via stack (in onstack[]), and also remember
        if we have to align the stack pointer to 16 (onstack[i] == 2).  Needs
@@ -1369,6 +1364,9 @@
 
     tcc_free(onstack);
 
+    /* XXX This should be superfluous.  */
+    save_regs(0); /* save used temporary registers */
+
     /* then, we prepare register passing arguments.
        Note that we cannot set RDX and RCX in this loop because gv()
        may break these temporary registers. Let's use R10 and R11
@@ -1418,6 +1416,12 @@
     assert(gen_reg == 0);
     assert(sse_reg == 0);
 
+    /* We shouldn't have many operands on the stack anymore, but the
+       call address itself is still there, and it might be in %eax
+       (or edx/ecx) currently, which the below writes would clobber.
+       So evict all remaining operands here.  */
+    save_regs(0);
+
     /* Copy R10 and R11 into RDX and RCX, respectively */
     if (nb_reg_args > 2) {
         o(0xd2894c); /* mov %r10, %rdx */
@@ -1502,7 +1506,7 @@
 	gen_le32(seen_stack_size);
 	/* movq %r11, -0x10(%rbp) */
 	o(0xf05d894c);
-	/* leaq $-200(%rbp), %r11 */
+	/* leaq $-192(%rbp), %r11 */
 	o(0x9d8d4c);
 	gen_le32(-176 - 24);
 	/* movq %r11, -0x8(%rbp) */
@@ -1585,7 +1589,8 @@
         }
 	default: break; /* nothing to be done for x86_64_mode_none */
         }
-        gfunc_set_param(sym, param_addr, 0);
+        sym_push(sym->v & ~SYM_FIELD, type,
+                 VT_LOCAL | VT_LVAL, param_addr);
     }
 
 #ifdef CONFIG_TCC_BCHECK
@@ -1937,7 +1942,6 @@
                 v1.type.t = VT_PTR;
                 v1.r = VT_LOCAL | VT_LVAL;
                 v1.c.i = fc;
-                v1.sym = NULL;
                 load(r, &v1);
                 fc = 0;
                 vtop->r = r = r | VT_LVAL;
@@ -2006,7 +2010,6 @@
                 v1.type.t = VT_PTR;
                 v1.r = VT_LOCAL | VT_LVAL;
                 v1.c.i = fc;
-	        v1.sym = NULL;
                 load(r, &v1);
                 fc = 0;
                 vtop->r = r = r | VT_LVAL;
@@ -2018,7 +2021,6 @@
                 gv(RC_FLOAT);
                 vswap();
                 fc = vtop->c.i; /* bcheck may have saved previous vtop[-1] */
-                r = vtop->r;
             }
             
             if ((ft & VT_BTYPE) == VT_DOUBLE) {
@@ -2153,15 +2155,6 @@
     ft = vtop->type.t;
     bt = ft & VT_BTYPE;
     if (bt == VT_LDOUBLE) {
-	if (t != VT_INT) {
-	    vpush_helper_func(TOK___fixxfdi);
-	    vswap();
-	    gfunc_call(1);
-	    vpushi(0);
-	    vtop->r = REG_IRET;
-	    vtop->r2 = REG_IRE2;
-	    return;
-	}
         gen_cvt_ftof(VT_DOUBLE);
         bt = VT_DOUBLE;
     }
